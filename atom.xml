<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Maxie&#39;s Notes</title>
  <subtitle>Stay hungry , Stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-04-12T13:45:50.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>阿蓝</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>bash脚本编程基础（一）</title>
    <link href="http://yoursite.com/2017/04/12/shell-programming-basis/"/>
    <id>http://yoursite.com/2017/04/12/shell-programming-basis/</id>
    <published>2017-04-12T11:12:50.000Z</published>
    <updated>2017-04-12T13:45:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">Bash(Bourne Again Shell)，是一款在大多数Linux系统中默认的shell。<br>值得注意的是shell与shell script是两个不同的概念。<br></blockquote>

<p><strong>常见的shell</strong></p>
<blockquote>
<p>Bourne Shell (/usr/bin/sh或/bin/sh)<br>Bourne Again Shell (/bin/bash)<br>C Shell (/usr/bin/csh)<br>K Shell (/usr/bin/ksh)<br>Z Shell (/usr/bin/zsh)<br>Shell for Root (/sbin/sh)</p>
</blockquote>
<p>要想成为一个使用Linux的dalao，就离不开shell，那么也就是说离不开shell编程。很多时候服务器都需要编写一些计划任务来定时运行的，所以掌握一些基本的shell编程基础很有必要。</p>
<a id="more"></a>
<hr>
<div class="note primary"><h2 id="什么是Shell脚本"><a href="#什么是Shell脚本" class="headerlink" title="什么是Shell脚本"></a>什么是Shell脚本</h2></div>
<p>先看个例子吧！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="built_in">cd</span> /root</div><div class="line">mkdir script</div><div class="line"><span class="built_in">cd</span> script</div><div class="line"><span class="keyword">for</span> ((i=0; i&lt;10; i++)); <span class="keyword">do</span></div><div class="line">    touch test_<span class="variable">$i</span>.txt</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p>例子解释：</p>
<ul>
<li>第一行：指定脚本的解释器，这里使用的是/bin/bash</li>
<li>第二行：切换到<code>root</code>用户的家目录</li>
<li>第三行：创建一个目录<code>script</code></li>
<li>第四行：切换到<code>script</code>目录下</li>
<li>第五行：for循环以及循环的条件</li>
<li>第六行：创建一个test_1..10.txt的文件</li>
<li>第七行：循环结束</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> mkdir touch 都是系统內建的程序。</div><div class="line"><span class="keyword">for</span> <span class="keyword">do</span> <span class="keyword">done</span> 是bash脚本语言的关键字。</div></pre></td></tr></table></figure>
<hr>
<div class="note success"><h2 id="shell和shell脚本的概念"><a href="#shell和shell脚本的概念" class="headerlink" title="shell和shell脚本的概念"></a>shell和shell脚本的概念</h2></div>
<p>shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p>
<p>Ken Thompson的sh是第一种Unix Shell，Windows Explorer是一个典型的图形界面Shell。shell脚本（shell script），是一种为shell编写的脚本程序。</p>
<p>业界所说的shell通常都是指shell脚本，但读者朋友要知道，shell和shell script是两个不同的概念。</p>
<p>由于习惯的原因，简洁起见，本文出现的“shell编程”都是指shell脚本编程，不是指开发shell自身（如Windows Explorer扩展开发）。</p>
<p>环境shell编程跟java、php编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p>
<p>OS当前主流的操作系统都支持shell编程，本文档所述的shell编程是指Linux下的shell，讲的基本都是POSIX标准下的功能，所以，也适用于Unix及BSD（如Mac OS）。</p>
<p>LinuxLinux默认安装就带了shell解释器。</p>
<p>Mac OSMac OS不仅带了sh、bash这两个最基础的解释器，还内置了ksh、csh、zsh等不常用的解释器。</p>
<p>Windows上的模拟器windows出厂时没有内置shell解释器，需要自行安装，为了同时能用grep, awk, curl等工具，最好装一个cygwin或者mingw来模拟linux环境。</p>
<p>cygwin<br>mingw</p>
<hr>
<div class="note info"><h2 id="脚本解释器-sh"><a href="#脚本解释器-sh" class="headerlink" title="脚本解释器 sh"></a>脚本解释器 sh</h2></div>
<p>即Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh，由Bell Labs开发。</p>
<p>bashBash是Bourne shell的替代品，属GNU Project，二进制文件路径通常是/bin/bash。业界通常混用bash、sh、和shell，比如你会经常在招聘运维工程师的文案中见到：熟悉Linux Bash编程，精通Shell编程。</p>
<p>在CentOS里，/bin/sh是一个指向/bin/bash的符号链接:<br><img src="http://ww3.sinaimg.cn/large/006tNc79ly1fek5u6o8ltj30zw0bqgq5.jpg" alt=""></p>
<p>但在Mac OS上不是，/bin/sh和/bin/bash是两个不同的文件，尽管它们的大小只相差100字节左右:<br><img src="http://ww1.sinaimg.cn/large/006tNc79ly1fek5vty07dj310006swhd.jpg" alt=""></p>
<hr>
<div class="note danger"><h2 id="运行bash脚本"><a href="#运行bash脚本" class="headerlink" title="运行bash脚本"></a>运行bash脚本</h2></div>
<p>运行shell脚本有两种方法：</p>
<p><strong>1、作为可执行程序</strong></p>
<p>将下面的代码输入到test.sh文件中，并给予权限。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="built_in">cd</span> /root</div><div class="line">mkdir script</div><div class="line"><span class="built_in">cd</span> script</div><div class="line"><span class="keyword">for</span> ((i=0; i&lt;10; i++)); <span class="keyword">do</span></div><div class="line">    touch test_<span class="variable">$i</span>.txt</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p>给予文件执行权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chmod +x test.sh</div></pre></td></tr></table></figure>
<p>执行脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./test.sh</div></pre></td></tr></table></figure>
<p><em>注意：</em></p>
<ul>
<li>一定要写成<code>./test.sh</code>，而不是<code>test.sh</code>，运行其他二进制程序也一样。</li>
<li>直接写成<code>test.sh</code>，系统会去<code>$PATH</code>环境变量中的路径中查找有没有叫<code>test.sh</code>文件。</li>
<li>你的当前目录一般不在<code>$PATH</code>设置的路径中，所以写成<code>test.sh</code>是不会找到命令的，要用<code>./test.sh</code>告诉系统，就在当前目录查找。</li>
</ul>
<p><strong>2、作为解释器参数</strong></p>
<p>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div><div class="line">$ sh test.sh</div><div class="line">$ /bin/bash test.sh</div><div class="line">$ /bin/sh test.sh</div></pre></td></tr></table></figure>
<p>这种方式运行的脚本，不用在第一行指定注释信息，也就是<code>shebang</code></p>
<hr>
<div class="note warning"><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2></div>
<p>定义变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ name=value</div><div class="line">或者</div><div class="line">$ name=<span class="string">"value"</span></div></pre></td></tr></table></figure>
<p>注意：变量名和等号之间不能有空格。</p>
<p><strong>变量命名法则：</strong></p>
<ol>
<li>首个字母必须为字母或下划线</li>
<li>中间不能有空格，可以使用下划线</li>
<li>不能程序中的保留字：例如if、for</li>
<li>见名知义</li>
<li>统一命名规则：驼峰原则</li>
</ol>
<p><strong>变量种类</strong></p>
<ol>
<li>本地变量：生效范围为当前shell进程；对当前shell之外的其他shell，包括当前shell的子进程均无效</li>
<li>环境变量：生效范围为当前shell及其它shell进程，使用<code>export</code>定义变量</li>
<li>局部变量：生效范围为当前shell进程中某代码片段，通常在函数里面，使用local定义变量</li>
<li>位置变量：$1,$2,$3，用于让脚本在脚本在代码中调用通过命令行传递给它的参数。</li>
<li>特殊变量：$?,$0,$*,$@,$#</li>
</ol>
<p>除了使用上面那样的方式给变量赋值，还可以用语句给变量赋值，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> I <span class="keyword">in</span> `ls /etc`</div></pre></td></tr></table></figure>
<ul>
<li>说明：上面的意思就是把<code>ls /etc</code>的命令输出结果赋值给变量<code>I</code>，并循环显示出来。</li>
</ul>
<p><strong>使用变量</strong></p>
<p>使用一个定义过的变量，只要在变量名之前加上<code>$</code>符号即可。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ name=<span class="string">"value"</span></div><div class="line">$ <span class="built_in">echo</span> <span class="variable">$value</span></div><div class="line">或者</div><div class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;value&#125;</span></div></pre></td></tr></table></figure>
<p>变量名外的花括号是可选的，可加可不加，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> skill <span class="keyword">in</span> Java Python C Go; <span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"I am good at <span class="variable">$&#123;skill&#125;</span>program."</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p>推荐给所有变量加上花括号，这是shell编程的好习惯。</p>
<p>对于已定义的变量，可以被重新定义，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ name=<span class="string">"value"</span></div><div class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;name&#125;</span></div><div class="line">$ name=<span class="string">"maxie"</span></div><div class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;maxie&#125;</span></div></pre></td></tr></table></figure>
<p><strong>只读变量</strong></p>
<p>使用<code>readonly</code>命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>
<p>下面的例子就说明了这一切：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ name=<span class="string">"maxie"</span></div><div class="line">$ <span class="built_in">readonly</span> name</div><div class="line">$ name=<span class="string">"value"</span></div><div class="line">-bash: name: 只读变量</div></pre></td></tr></table></figure>
<p><strong>删除变量</strong></p>
<p>使用<code>unset</code>命令可以删除变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">unset</span> name</div></pre></td></tr></table></figure>
<p>变量被删除后不能再次被使用，unset命令不能删除只读变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ name=<span class="string">"value"</span></div><div class="line">$ <span class="built_in">unset</span> name</div><div class="line">$ <span class="built_in">echo</span> <span class="variable">$name</span></div></pre></td></tr></table></figure>
<hr>
<div class="note default"><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2></div>
<p>字符串是 shell 编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了）。</p>
<p>字符串可以用单引号，也可以用双引号，也可以不用引号。</p>
<p><strong>单引号</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ str=<span class="string">'this is a string'</span></div></pre></td></tr></table></figure>
<p>单引号的特性：</p>
<ul>
<li>单引号里的任何字符都会原样输出，单引号中的变量不会被替换</li>
<li>单引号里不能出现单引号（嵌套）</li>
</ul>
<p><strong>双引号</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ name=<span class="string">"maxie"</span></div><div class="line">$ HELLO=<span class="string">"Hello, I know u r <span class="variable">$&#123;name&#125;</span>! \n "</span></div></pre></td></tr></table></figure>
<p>双引号的特性：</p>
<ul>
<li>双引号里可以有变量，并且会被替换</li>
<li>双引号可以使转义字符生效</li>
</ul>
<p><strong>获取字符串长度</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ alpha=<span class="string">"abcde"</span></div><div class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;#alpha&#125;</span></div><div class="line">5</div></pre></td></tr></table></figure>
<p><strong>提取字符串</strong></p>
<p>从以下实例的字符串第4个字符开始截取4个字符：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BJ=<span class="string">"BeiJing is a nice city"</span></div><div class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;BJ:3:4&#125;</span></div><div class="line">Jing</div></pre></td></tr></table></figure>
<hr>
<div class="note primary"><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2></div>
<p>Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小</p>
<p>获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。</p>
<p>数组中可以存放多个值，与大部分编程语言类似，数组元素的下标由0开始。</p>
<p><strong>定义数组</strong></p>
<p>在shell中，用括号来表示数组，数组元素用“空格”符号分隔开。</p>
<p>定义数组的一般形式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">数组名=(值1 值2 值3 ... 值n)</div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array=(value1 value2 value3)</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">array=(</div><div class="line">value1</div><div class="line">value2</div><div class="line">value3</div><div class="line">)</div></pre></td></tr></table></figure>
<p>还可以单独定义数组的各个分量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">array[1]=value1</div><div class="line">array[2]=value2</div><div class="line">array[3]=value3</div></pre></td></tr></table></figure>
<p>可以不使用连续的下标，而且下标的范围没有限制。</p>
<p><strong>读取数组</strong></p>
<p>读取数组元素值的一般格式是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$&#123;数组名[下标]&#125;</span></div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">values=<span class="variable">$&#123;array[n]&#125;</span></div></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">my_array=(A B <span class="string">"C"</span> D)</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"第一个元素为: <span class="variable">$&#123;my_array[0]&#125;</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"第二个元素为: <span class="variable">$&#123;my_array[1]&#125;</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"第三个元素为: <span class="variable">$&#123;my_array[2]&#125;</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"第四个元素为: <span class="variable">$&#123;my_array[3]&#125;</span>"</span></div></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ chmod +x test.sh </div><div class="line">$ ./test.sh</div><div class="line">第一个元素为: A</div><div class="line">第二个元素为: B</div><div class="line">第三个元素为: C</div><div class="line">第四个元素为: D</div></pre></td></tr></table></figure>
<p>使用 @ 或者 * 符号可以获取数组中的所有元素，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[@]&#125;</span></div></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line">my_array[0]=A</div><div class="line">my_array[1]=B</div><div class="line">my_array[2]=C</div><div class="line">my_array[3]=D</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"数组的元素为: <span class="variable">$&#123;my_array[*]&#125;</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"数组的元素为: <span class="variable">$&#123;my_array[@]&#125;</span>"</span></div></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ chmod +x test.sh </div><div class="line">$ ./test.sh</div><div class="line">数组的元素为: A B C D</div><div class="line">数组的元素为: A B C D</div></pre></td></tr></table></figure>
<p><strong>获取数组的长度</strong></p>
<p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 取得数组元素的个数</span></div><div class="line">length=<span class="variable">$&#123;#array[@]&#125;</span></div><div class="line"><span class="comment"># 或者</span></div><div class="line">length=<span class="variable">$&#123;#array[*]&#125;</span></div><div class="line"><span class="comment"># 取得数组单个元素的长度</span></div><div class="line">lengthn=<span class="variable">$&#123;#array[n]&#125;</span></div></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line">my_array[0]=A</div><div class="line">my_array[1]=B</div><div class="line">my_array[2]=C</div><div class="line">my_array[3]=D</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"数组元素个数为: <span class="variable">$&#123;#my_array[*]&#125;</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"数组元素个数为: <span class="variable">$&#123;#my_array[@]&#125;</span>"</span></div></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ chmod +x test.sh </div><div class="line">$ ./test.sh</div><div class="line">数组元素个数为: 4</div><div class="line">数组元素个数为: 4</div></pre></td></tr></table></figure>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28695603&auto=1&height=66"></iframe>


<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
<p>本文出自<a href="http://maxiecloud.com" target="_blank" rel="external">Maxie’s Notes</a>博客，转载请务必保留此出处。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;Bash(Bourne Again Shell)，是一款在大多数Linux系统中默认的shell。&lt;br&gt;值得注意的是shell与shell script是两个不同的概念。&lt;br&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;常见的shell&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Bourne Shell (/usr/bin/sh或/bin/sh)&lt;br&gt;Bourne Again Shell (/bin/bash)&lt;br&gt;C Shell (/usr/bin/csh)&lt;br&gt;K Shell (/usr/bin/ksh)&lt;br&gt;Z Shell (/usr/bin/zsh)&lt;br&gt;Shell for Root (/sbin/sh)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要想成为一个使用Linux的dalao，就离不开shell，那么也就是说离不开shell编程。很多时候服务器都需要编写一些计划任务来定时运行的，所以掌握一些基本的shell编程基础很有必要。&lt;/p&gt;
    
    </summary>
    
      <category term="linux基础知识" scheme="http://yoursite.com/categories/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="bash" scheme="http://yoursite.com/tags/bash/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
      <category term="programming" scheme="http://yoursite.com/tags/programming/"/>
    
  </entry>
  
  <entry>
    <title>Linux各概念图解</title>
    <link href="http://yoursite.com/2017/04/09/mind-mapping/"/>
    <id>http://yoursite.com/2017/04/09/mind-mapping/</id>
    <published>2017-04-09T09:47:17.000Z</published>
    <updated>2017-04-09T10:46:49.000Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="https://ww3.sinaimg.cn/large/006tNbRwly1feglz4cq9nj31kw16ou10.jpg" alt=""></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fegm48jil8j31kw0zknpd.jpg" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fegm4a9911j31kw0zkhdt.jpg" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fegm4c6wqzj31kw0zk1ky.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="图片" scheme="http://yoursite.com/categories/%E5%9B%BE%E7%89%87/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="picture" scheme="http://yoursite.com/tags/picture/"/>
    
  </entry>
  
  <entry>
    <title>压缩和解压缩</title>
    <link href="http://yoursite.com/2017/04/08/compression-tool/"/>
    <id>http://yoursite.com/2017/04/08/compression-tool/</id>
    <published>2017-04-08T07:45:32.000Z</published>
    <updated>2017-04-12T13:44:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">压缩的目的<br>时间换空间<br>CPU的时间 –&gt; 磁盘空间<br></blockquote>

<p><strong>常见的压缩文件拓展名：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">*.Z         --compress  压缩文件</div><div class="line">*.gz        --gzip      压缩文件</div><div class="line">*.bz2       --bzip2     压缩文件</div><div class="line">*.xz        --xz        压缩文件</div><div class="line">*.tar       --tar       打包文件,并没有经过压缩</div><div class="line">*.tar.gz    --tar       打包文件,其中并且经过 gzip 的压缩</div><div class="line">*.tar.bz2   --tar       打包文件,其中并且经过 bzip2 的压缩</div><div class="line">*.tar.xz    --tar       打包文件,其中并且经过 xz 的压缩</div></pre></td></tr></table></figure>
<p>Linux上常见的压缩命令就是<code>gzip</code>和<code>bzip2</code>，还有新兴的<code>xz</code>，至于<code>compress</code>已经”退环境”了，不再适合当前的版本了。</p>
<a id="more"></a>
<h1 id="压缩与解压缩工具"><a href="#压缩与解压缩工具" class="headerlink" title="压缩与解压缩工具"></a>压缩与解压缩工具</h1><div class="note primary"><h2 id="compress-uncompress工具"><a href="#compress-uncompress工具" class="headerlink" title="compress/uncompress工具"></a>compress/uncompress工具</h2></div>
<p>compress这个压缩工具是非常老旧的一款，我们现在使用的 CentOS6.8 与 CentOS7 默认都没有安装这个软件到系统当中。如果想在系统中使用，需要先安装 <code>ncompress</code> 这个软件才可以。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum install -y ncompress</div></pre></td></tr></table></figure>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fefcgrj5n0j310y1f4gvr.jpg" alt=""></p>
<p>安装完成之后，我们就可以开始使用 <code>compress</code> 软件来对文件进行压缩/解压缩的操作了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ compress [-cdv] FILE</div><div class="line"></div><div class="line">各选项意义：</div><div class="line">-c          --压缩结果输出至标准输出,不删除原文件</div><div class="line">-d          --解压缩,相当于uncompress</div><div class="line">-v          --显示压缩过程</div></pre></td></tr></table></figure>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwly1fefcs2iv3mj310y0rw44l.jpg" alt=""></p>
<p><strong>注意：</strong>从上图我们可以看出，<code>compress</code> 在压缩文件时，会自动删除原文件。我们使用<code>-c</code>选项，并把标准输出中的内容重定向至一个压缩文件中，这样我们即压缩了文件，又保留了原文件，岂不美哉~</p>
<p>还有一个小tips，就是使用 <code>zcat</code> 命令可以查看 <code>compress</code> 压缩的文件内的文本内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ zcat file.Z</div></pre></td></tr></table></figure>
<hr>
<div class="note success"><h2 id="gzip-gunzip工具"><a href="#gzip-gunzip工具" class="headerlink" title="gzip/gunzip工具"></a>gzip/gunzip工具</h2></div>
<p><code>gzip</code> 可以说是Linux中应用最广泛，使用最多的压缩命令了。使用 <code>gzip</code> 创建的压缩文件的后缀是 <code>*.gz</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ gzip [-cdv<span class="comment">#] FILE</span></div><div class="line"></div><div class="line">各选项意义：</div><div class="line">-c          --将压缩的数据输出至标准输出,可以通过重定向来处理</div><div class="line"><span class="_">-d</span>          --解压缩,相当于gunzip</div><div class="line">-v          --显示压缩过程信息</div><div class="line">-<span class="comment">#          --压缩比，默认为6，越大越好，但也越慢，越耗CPU</span></div></pre></td></tr></table></figure>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fefd4ytimej310y0rwaha.jpg" alt=""></p>
<p>与 <code>compress</code> 类似，使用 <code>gzip</code> 压缩文件后，会自动把原文件删除，所以日常使用时我们要在 <code>gzip</code> 后面加上 <code>-c</code> 选项，再重定向至压缩文件中，这样我们即压缩了文件，也保留了原文件。</p>
<p>而且我们可以对比 <code>compress</code> 看出， <code>gzip</code> 的压缩比明显更好，压缩后的文件占用空间更少；我们还可以使用 <code>zcat</code> 查看压缩后的文件中的内容。</p>
<hr>
<div class="note info"><h2 id="bzip2-bunzip2工具"><a href="#bzip2-bunzip2工具" class="headerlink" title="bzip2/bunzip2工具"></a>bzip2/bunzip2工具</h2></div>
<p>如果说 <code>gzip</code> 是为了替代 <code>compress</code> 出现的，那么 <code>bzip2</code> 就是为了替代 <code>gzip</code> 出现的。 <code>bzip2</code> 的压缩比比 <code>gzip</code> 还要好，但是目前来说使用最广泛的还是 <code>gzip</code>。</p>
<p>让我们看看如何使用 <code>bzip2</code> 吧！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ bzip2 [-cdkv<span class="comment">#] FILE</span></div><div class="line"></div><div class="line">各参数意义：</div><div class="line">-c          --将压缩的数据输出至标准输出,可以通过重定向来处理</div><div class="line"><span class="_">-d</span>          --解压缩,相当于bunzip2</div><div class="line">-v          --显示压缩过程信息</div><div class="line">-<span class="comment">#          --压缩比，默认为6，越大越好，但也越慢，越耗CPU</span></div></pre></td></tr></table></figure>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fefdgfkhb0j310y0rwwlu.jpg" alt=""></p>
<p>使用方法与 <code>gzip</code> 其实并没有什么区别，只是要查看使用 <code>bzip2</code> 压缩的文件内的文本内容，就需要使用 <code>bzcat</code> 这个命令来查看了。</p>
<hr>
<div class="note danger"><h2 id="xz-unxz工具"><a href="#xz-unxz工具" class="headerlink" title="xz/unxz工具"></a>xz/unxz工具</h2></div>
<p><code>xz</code> 是一个使用 <a href="https://zh.wikipedia.org/wiki/LZMA" target="_blank" rel="external">LZMA/LZMA2</a> 压缩算法的无损数据压缩文件格式。和 <code>gzip</code> 与 <code>bzip2</code> 一样，同时支持多文件压缩，但是不能将多于一个目标文件压缩进同一个档案(包)里。<code>xz</code> 生成的压缩文件比 <code>gzip/bzip2</code> 生成的压缩文件更小，而且压缩速度也很快。其生成的压缩文件扩展名为 <code>*.xz</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ xz [-kdv<span class="comment">#]         </span></div><div class="line"></div><div class="line">各选项意义：</div><div class="line">-k          --保留原文件，无需使用重定向</div><div class="line"><span class="_">-d</span>          --解压缩，与unxz效果相同</div><div class="line">-v          --显示压缩时的信息</div><div class="line">-<span class="comment">#          --压缩比，默认为6</span></div></pre></td></tr></table></figure>
<p><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fefjjezcgmj310y0rwjx5.jpg" alt=""></p>
<p>由于压缩的文件比较小，所以对比 <code>gzip/bzip2</code> 的优势不是那么明显，但是也还是可以看出 <code>xz</code> 以略微的优势占领了上风。</p>
<p>使用 <code>xzcat</code>同样可以看到压缩后文件内的文本内容。</p>
<hr>
<h1 id="打包-归档-命令"><a href="#打包-归档-命令" class="headerlink" title="打包(归档)命令"></a>打包(归档)命令</h1><p>上面我们说完了压缩/解压缩命令，但是前面的命令只能压缩单一文件，而不能对目录进行压缩的操作。<br>下面我们讲一讲，如何使用打包命令将目录包成一个大文件。</p>
<div class="note warning"><h2 id="tar工具"><a href="#tar工具" class="headerlink" title="tar工具"></a>tar工具</h2></div>
<p><code>tar</code> 可以将多个目录或文件打包成一个大文件，同时它还可以搭配 <code>gzip/bzip2/xz</code> 将此大文件进行压缩。</p>
<p><code>tar</code> 的参数非常多，下面只列取一些常用的选项</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ tar [-j|-J|-z] [cv] [<span class="_">-f</span> 创建的归档的文件名] FILE         --打包与压缩</div><div class="line">$ tar [-j|-J|-z] [xv] [<span class="_">-f</span> 创建的归档的文件名] [-C 目录]    --此选项是将归档文件解压到指定目录</div><div class="line">$ tar [-j|-J|-z] [tv] [<span class="_">-f</span> 创建的归档的文件名]              --查看归档文件内的文件列表</div><div class="line"></div><div class="line">各选项意义：</div><div class="line">-c          --创建归档文件</div><div class="line"><span class="_">-f</span>          --指定归档的文件名(f必须与归档文件名在一起，例如：cf，xf；而非：<span class="built_in">fc</span>)</div><div class="line">-x          --展开归档，通常与-v，-C结合使用</div><div class="line">-t          --查看归档文件内的文件列表</div><div class="line">-v          --在归档/解包的过程中将正在处理的档名显示出来</div><div class="line">-j          --通过 bzip2 将文件归档并压缩；后缀名最好为 *.tar.bz2</div><div class="line">-J          --通过 xz 将文件归档并压缩；后缀名最好为 *.tar.xz</div><div class="line">-z          --通过 gzip 将文件归档并压缩；后缀名最好为 *.tar.gz</div><div class="line">-C          --解压缩时，指定解压缩的位置</div><div class="line">-P          --保留绝对路径</div><div class="line">-p          --保留文件的原本权限和属性，常用于备份重要的文档</div><div class="line">--exclude=FILE      --压缩的过程中，不要将 FILE 这个文件打包</div></pre></td></tr></table></figure>
<p>其实，在生产环境与日常操作练习时，我们只需使用以下的几种方式即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">压  缩: tar -zcv <span class="_">-f</span> filename.tar.gz</div><div class="line">查  询: tar -ztv <span class="_">-f</span> filename.tar.gz</div><div class="line">解压缩: tar -zxv <span class="_">-f</span> filename.tar.gz</div></pre></td></tr></table></figure>
<p>由于现在流行使用的压缩工具大多是 <code>gz</code> 格式的，我们这里就列举了 <code>gz</code> 的三种操作方法。至于其他两种，替换 <code>-z</code> 即可。</p>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwly1fefkii0eikj310y0rwgsb.jpg" alt=""></p>
<p>上图中，我们可以看到有三个归档文件，是三种不同类型的，我执行了以下的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ tar -zcvf etc.tar.gz /etc</div><div class="line">$ tar -Jcvf etc.tar.xz /etc</div><div class="line">$ tar -jcf etc.tar.bz2 /etc</div></pre></td></tr></table></figure>
<p>通过对比，明显看出 <code>xz</code> 的优势蛮大的，<code>bzip2</code> 与 <code>gzip</code> 倒是不分伯仲。</p>
<p>当我们把/etc目录归档好了之后，就可以使用 <code>-t</code> 选项查看我们备份了哪些目录和文件了。</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fefknl2lvej310y0rwqdp.jpg" alt=""></p>
<p>不过由于文件内容过多，我们只取前10行的内容。</p>
<p>现在我们想把其中的 <code>etc/fstab</code> 文件取出来，就可以使用 <code>tar -zxcf etc.tar.gz etc/fstab</code> 命令取出文件了！</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fefkrjz1iij310608m76k.jpg" alt=""></p>
<p>这样，我们就把归档文件内的 <code>etc/fstab</code> 文件单个取出来来啦！</p>
<p>下面我们将把 <code>etc.tar.gz</code> 文件解压到 <code>/tmp</code> 目录下，这时就需要使用 <code>-C</code> 选项了。</p>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwly1fefl0x01z2j310y0rwgtd.jpg" alt=""></p>
<p>注意 <code>-C</code> 选项的位置，在归档文件名之后，目标位置之前。</p>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28458114&auto=0&height=66"></iframe>

<p>本文出自<a href="http://maxiecloud.com" target="_blank" rel="external">Maxie’s Notes</a>博客，转载请务必保留此出处。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;压缩的目的&lt;br&gt;时间换空间&lt;br&gt;CPU的时间 –&amp;gt; 磁盘空间&lt;br&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;常见的压缩文件拓展名：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;*.Z         --compress  压缩文件&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*.gz        --gzip      压缩文件&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*.bz2       --bzip2     压缩文件&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*.xz        --xz        压缩文件&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*.tar       --tar       打包文件,并没有经过压缩&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*.tar.gz    --tar       打包文件,其中并且经过 gzip 的压缩&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*.tar.bz2   --tar       打包文件,其中并且经过 bzip2 的压缩&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*.tar.xz    --tar       打包文件,其中并且经过 xz 的压缩&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Linux上常见的压缩命令就是&lt;code&gt;gzip&lt;/code&gt;和&lt;code&gt;bzip2&lt;/code&gt;，还有新兴的&lt;code&gt;xz&lt;/code&gt;，至于&lt;code&gt;compress&lt;/code&gt;已经”退环境”了，不再适合当前的版本了。&lt;/p&gt;
    
    </summary>
    
      <category term="linux基础知识" scheme="http://yoursite.com/categories/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="compress" scheme="http://yoursite.com/tags/compress/"/>
    
  </entry>
  
  <entry>
    <title>vim编辑器入门使用教程</title>
    <link href="http://yoursite.com/2017/04/06/how-to-use-vim/"/>
    <id>http://yoursite.com/2017/04/06/how-to-use-vim/</id>
    <published>2017-04-06T05:59:28.000Z</published>
    <updated>2017-04-06T09:59:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">Vim是一个高度可配置的文本编辑器，用于创建和更改任何类型的文本非常高效。<br>它与大多数UNIX系统、Linux系统和Apple OS X一起被列为“vi”<br></blockquote>

<p><strong>vim的功能包括：</strong></p>
<ul>
<li>广泛的插件系统</li>
<li>支持数百种编程语言和文件格式</li>
<li>强大的搜索和替换功能</li>
<li>与许多工具集成</li>
</ul>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwly1fecxo9nswuj31040rw77l.jpg" alt=""></p>
<a id="more"></a>
<hr>
<p>下面是vim添加插件之后的效果，很酷吧！</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fecxocn6odj31040rwq5x.jpg" alt=""></p>
<p>让我们一起来学习如何使用这款风靡各个操作系统之间的文本编辑器吧！</p>
<hr>
<h1 id="vim基本概念"><a href="#vim基本概念" class="headerlink" title="vim基本概念"></a>vim基本概念</h1><p>基本上vim可以分为三种模式。分别是：</p>
<ol>
<li>命令模式（Command mode）</li>
<li>插入模式（Insert mode）</li>
<li>末行模式（Last line mode）</li>
</ol>
<p>各模式的功能如下：</p>
<div class="note primary"><p>（1）命令模式：<br>    在<strong>命令模式</strong>，我们可以控制屏幕光标的移动，字符或行的删除，移动复制文本。在<strong>命令模式</strong>可以随时切换到<strong>插入模式</strong>与<strong>末行模式</strong>。  </p>
</div>
<div class="note success"><p>（2）插入模式：<br>    在<strong>插入模式</strong>，我们可以进行文字的输入、删除、修改等操作。按<strong>[ESC]</strong>键可回到<strong>命令模式</strong>。  </p>
</div>
<div class="note warning"><p>（3）末行模式：<br>    在<strong>末行模式</strong>，我们可以将文件保存或退出vim，也可以设置vim的编辑环境。如设置是否显示行号、括号匹配高亮显示和语法高亮等等。 </p>
</div>
<hr>
<div class="note primary"><h1 id="如何在Linux中使用vim"><a href="#如何在Linux中使用vim" class="headerlink" title="如何在Linux中使用vim"></a>如何在Linux中使用vim</h1></div>
<p>了解了<strong>vim</strong>的三个模式之后，我们就开始学习如何在Linux使用<strong>vim</strong>来编辑文件吧！</p>
<p>在Linux的命令行输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim [FILENAME]</div></pre></td></tr></table></figure>
<p>即可打开文件开始编辑了。</p>
<ul>
<li>如果文件事先存在，这时<strong>vim</strong>将会把存在的文件打开，并把光标移动至文本首行的行首。</li>
<li>如果文件不存在，<strong>vim</strong>将会为我们打开一个新的文件，并让我们编辑。</li>
</ul>
<p><em>下面这张图就是在当前工作目录下打开一个新的文件。（这时我们处在命令模式）</em></p>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwly1fecyffn7vqj310y0rwtaf.jpg" alt=""></p>
<hr>
<div class="note warning"><h2 id="各模式使用方法"><a href="#各模式使用方法" class="headerlink" title="各模式使用方法"></a>各模式使用方法</h2></div>
<p>当我们使用<strong>vim</strong>打开一个文件后的最要紧的就是进行文本的输入，然后保存。<br>所以，熟练掌握各模式之间切换的方法至关重要。</p>
<h3 id="各模式之间切换"><a href="#各模式之间切换" class="headerlink" title="各模式之间切换"></a>各模式之间切换</h3><ul>
<li><strong>命令模式 –&gt; 插入模式</strong></li>
</ul>
<p>使用以下<strong>实体键</strong>可以在命令模式<strong>切换</strong>到插入模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">i:insert,在光标所在处输入</div><div class="line">a:append,在光标所在处的后方输入</div><div class="line">o:在光标所在出下方打开一个新行</div><div class="line">A:在光标所在出的行尾输入</div><div class="line">I:在光标所在处的行首输入</div><div class="line">O:在光标所在处的上方打开一个新行</div></pre></td></tr></table></figure>
<ul>
<li><strong>插入模式 –&gt; 命令模式</strong></li>
</ul>
<p>按<strong>[ESC]</strong>即可从插入模式退出到命令模式。如果为了万全，可以按两次。</p>
<ul>
<li><strong>命令模式 –&gt; 末行模式</strong></li>
</ul>
<p>按 <strong>:</strong> 即可进入到末行模式</p>
<ul>
<li><strong>末行模式 –&gt; 命令模式</strong></li>
</ul>
<p>按<strong>[ESC]</strong>即可从末行模式退出到命令模式。如果为了万全，可以按两次。</p>
<h3 id="命令模式下的操作方法"><a href="#命令模式下的操作方法" class="headerlink" title="命令模式下的操作方法"></a>命令模式下的操作方法</h3><div class="note warning"><h4 id="光标跳转"><a href="#光标跳转" class="headerlink" title="光标跳转"></a>光标跳转</h4></div>
<p><strong>字符间跳转：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">h键          --向左跳转一个字符</div><div class="line">l键          --向右跳转一个字符</div><div class="line">j键          --向下跳转一个字符</div><div class="line">k键          --向上跳转一个字符</div></pre></td></tr></table></figure>
<p>如果键盘上有上、下、左、右箭头的导航键，也可以使用其来完成光标的移动。</p>
<p><strong>单词间跳转：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">w键          --跳到下一个单词的词首</div><div class="line">b键          --跳到当前或前一个单词的词首</div><div class="line">e键          --跳到当前或后一个单词的词尾</div></pre></td></tr></table></figure>
<p><strong>行首/尾间跳转：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">^键          --跳转至行首第一个非空白字符</div><div class="line">0键          --跳转至行首(tab键不算）</div><div class="line">$键          --跳转至行尾</div></pre></td></tr></table></figure>
<p><strong>行间跳转：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#G           --跳转至由#号指定的行的行首</span></div><div class="line">1G/gg        --跳转至第一行的行首(这两种方法都可以)</div><div class="line">G键          --跳转至最后一行的行首</div></pre></td></tr></table></figure>
<p><strong>翻屏操作：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Ctrl+f键         --向文件尾部翻一屏</div><div class="line">Ctrl+b键         --向文件首部翻一屏</div><div class="line">Ctrl+d键         --向文件尾部翻半屏</div><div class="line">Ctrl+u键         --向文件首部翻半屏</div><div class="line">Enter键          --按行向后翻</div><div class="line">b键              --按行向前翻</div></pre></td></tr></table></figure>
<p><strong>当前页跳转：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">H键          --跳转至当前页的页首</div><div class="line">M键          --跳转至当前页的中间行位置</div><div class="line">L键          --跳转至当前页的页底</div></pre></td></tr></table></figure>
<p><strong>句间跳转：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">)键          --跳转至前一句</div><div class="line">(键          --跳转至后一句</div></pre></td></tr></table></figure>
<p><strong>段间跳转：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#125;键          --跳转至前一段</div><div class="line">&#123;键          --跳转至后一段</div></pre></td></tr></table></figure>
<div class="note success"><h4 id="替换和删除"><a href="#替换和删除" class="headerlink" title="替换和删除"></a>替换和删除</h4></div>
<p><strong>字符编辑：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x键          --删除光标所在处的字符</div><div class="line">6x键         --删除光标所在处起始的 6 个字符</div><div class="line">nx键         --删除光标所在处的后 n 个字符</div><div class="line">xp键         --交换光标所在处的字符以及后面字符的位置</div></pre></td></tr></table></figure>
<p><strong>替换命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">r键          --替换光标所在处的字符，用任意键替换当前字符</div><div class="line">nrc键        --用 c 替换光标所在处的后 n 个字符</div><div class="line">6rA         --用 A 替换光标所在处的后 6 个字符</div></pre></td></tr></table></figure>
<p><strong>删除命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">d键          --删除命令，可结合光标跳转字符实现范围删除</div><div class="line">d$键         --删除光标所在处到行尾的字符</div><div class="line">d^键         --删除光标所在处到行首的字符</div><div class="line">dd键         --删除光标所在行</div><div class="line">ndd键        --删除光标所在处的行起始共 n 行</div></pre></td></tr></table></figure>
<p><strong>改变命令：</strong></p>
<p>从<strong>命令模式</strong>执行操作之后直接进入到<strong>插入模式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">c键          --改变命令，工作行为相似于d命令</div><div class="line">c$键         --删除光标所在处至行尾的字符，并进入插入模式</div><div class="line">c^键         --删除光标所在处至行首的字符，并进入插入模式</div><div class="line">cw键         --删除光标所在处至当前词尾的字符，并进入插入模式</div><div class="line">cc键         --删除光标所在的行，并进入插入模式</div></pre></td></tr></table></figure>
<div class="note info"><h4 id="其他操作命令"><a href="#其他操作命令" class="headerlink" title="其他操作命令"></a>其他操作命令</h4></div>
<p><strong>复制粘贴：</strong></p>
<p>在vim从正文中删除的内容并没有真正丢失，而是被剪切并复制到一个内存缓冲区中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p键          --小写字母 p ，将缓冲区的内容粘贴至光标所在处的后方</div><div class="line">P键          --大写字母 P ，将缓冲区的内容粘贴至光标所在处的前方</div></pre></td></tr></table></figure>
<p>如果缓冲区的内容是字符或字，直接粘贴在光标的前面或后面；如果缓冲区的内容为整行正文，执行上述粘贴命令将会粘贴在当前光标所在行的上一行或下一行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">y键          --复制命令</div><div class="line">yy键         --复制当前行到内存缓冲区</div><div class="line">nyy键        --复制 n 行内容到内存缓冲区</div></pre></td></tr></table></figure>
<p><strong>撤销和重复：</strong></p>
<p>在编辑文档的过程中，为消除某个错误的编辑命令造成的后果，可以用撤消命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">u键          --撤销此前的操作</div><div class="line">nu键         --撤销此前 n 个操作</div><div class="line"></div><div class="line">Ctrl+r键     --撤销此前的撤销操作</div><div class="line"></div><div class="line">.键          --重复执行前一个修改正文的命令</div></pre></td></tr></table></figure>
<hr>
<h3 id="插入模式下的操作方法"><a href="#插入模式下的操作方法" class="headerlink" title="插入模式下的操作方法"></a>插入模式下的操作方法</h3><div class="note default"><h4 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a>进入插入模式</h4></div>
<p>在命令模式下定位好光标位置后，可以用以下命令进入到<strong>插入模式</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">i:insert,在光标所在处输入</div><div class="line">a:append,在光标所在处的后方输入</div><div class="line">o:在光标所在出下方打开一个新行</div><div class="line">A:在光标所在出的行尾输入</div><div class="line">I:在光标所在处的行首输入</div><div class="line">O:在光标所在处的上方打开一个新行</div></pre></td></tr></table></figure>
<div class="note danger"><h4 id="退出插入模式"><a href="#退出插入模式" class="headerlink" title="退出插入模式"></a>退出插入模式</h4></div>
<p>退出插入模式的方法是，按 ESC 键或组合键 Ctrl+[ ，退出插入模式之后，将会进入编辑模式 。</p>
<hr>
<h3 id="末行模式下的操作方法"><a href="#末行模式下的操作方法" class="headerlink" title="末行模式下的操作方法"></a>末行模式下的操作方法</h3><p>Vim的<strong>末行模式</strong>下，可以使用复杂的命令。在<strong>命令模式</strong>下键入 : ，光标就跳到屏幕最后一行，并在那里显示冒号，此时已进入末行模式，用户输入的内容均显示在屏幕的最后一行，按回车键，Vim 执行命令。</p>
<div class="note primary"><h4 id="打开、保存、退出"><a href="#打开、保存、退出" class="headerlink" title="打开、保存、退出"></a>打开、保存、退出</h4></div>
<p>在已经启动的vim中打开一个文件需要用<code>:e</code>命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:e /PATH/TO/SOMEFILE</div></pre></td></tr></table></figure>
<p>保存当前编辑的文件需要用<code>:w</code>命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:w</div></pre></td></tr></table></figure>
<p>另存为当前编辑的文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:w /path/to/somefile</div></pre></td></tr></table></figure>
<p>在命令模式下，可以使用<code>:q</code>或者<code>ZZ</code>退出vim</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">:q          --在未修改文件内容的情况下退出</div><div class="line">:q!         --放弃修改，退出vim</div><div class="line">ZZ键        --保存并退出</div><div class="line">:wq         --保存并退出</div></pre></td></tr></table></figure>
<div class="note success"><h4 id="地址定界"><a href="#地址定界" class="headerlink" title="地址定界"></a>地址定界</h4></div>
<p>在命令模式下每一行正文都有自己的行号，用以下命令可以将光标移动至指定行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">:n           --将光标移动至第 n 行</div><div class="line">:.           --表示当前行</div><div class="line">:$           --表示正文的最后一行</div><div class="line">:n,m         --指定行范围，n 为起始行,m为结束行(m&gt;n)</div><div class="line">:n,+n        --指定行范围，n为起始行，+n 为 n 的偏移量。</div><div class="line">:1,$         --第一行至最后一行</div><div class="line">:%           --表示全文</div><div class="line">:233         --将光标移动至第 233 行</div><div class="line">:233w file   --将第 233 行写入 file 文件内</div><div class="line">:3,5w file   --将第 3 行至第 5 行写入file文件内</div><div class="line">:1,.w file   --将第1行至当前行写入 file 文件</div><div class="line">:.,<span class="variable">$w</span> file   --将当前行至最后一行写入 file 文件</div><div class="line">:.,.+5w file --从当前行开始将 6 行内容写入 file 文件</div><div class="line">:1,<span class="variable">$w</span> file   --将所有内容写入 file 文件</div></pre></td></tr></table></figure>
<div class="note info"><h4 id="查找与替换"><a href="#查找与替换" class="headerlink" title="查找与替换"></a>查找与替换</h4></div>
<p><strong>末行模式</strong>可以进行字符串搜索，给出一个字符串，可以通过搜索该字符串到达指定行。如果希望进行正向搜索，将待搜索的字符串置于两个 <strong>/</strong> 之间；如果希望反向搜索，则将字符串放在两个 <strong>？</strong> 之间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:/PATTERN           --正向搜索，将光标移到下一个包含字符串 PATTERN 的行</div><div class="line">:?PATTERN           --反向搜索，将光标移到上一个包含字符串 PATTERN 的行</div></pre></td></tr></table></figure>
<p>使用 <code>n</code> 键进行在匹配到的字符串之间向下跳转<br>使用 <code>N</code> 键进行在匹配到的字符串之间向下跳转</p>
<p>在末行模式也可以对正文内容进行替换的操作，使用 <code>:s</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s/要查找的内容/替换为的内容/修饰符</div><div class="line">:%s/str1/str2/          --用字符串 str2 替换全文行中第一次出现的字符串 str1</div><div class="line">:s/str1/str2/g          --用字符串 str2 替换当前光标所在行中所有的 str1</div><div class="line">:n,ms/str1/str2/g       --将从 n 行到 m 行的所有 str1 替换成 str2</div></pre></td></tr></table></figure>
<p>从上述命令可以看到：</p>
<ul>
<li><code>%</code> 表示替换范围是所有行，即全文内容</li>
<li><code>s</code> 后面跟一串替换的命令</li>
<li><code>g</code> 是修饰符，表示全局替换</li>
<li><code>i</code> 是修饰符，表示查找时忽略字符大小写</li>
<li><code>/</code> 是分隔符，而且此分隔符可以替换成其他特殊字符；如：@、#</li>
</ul>
<p>另外一个实用的命令，统计全文中字符串 <code>str1</code> 出现的次数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:%s/str1/&amp;/gn</div></pre></td></tr></table></figure>
<div class="note warning"><h4 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h4></div>
<p>在末行模式下，也可以实现删除正文的功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">:d                              --删除光标当前所在行</div><div class="line">:nd                             --删除光标所在处的行以及下面 n-1 行的内容</div><div class="line">:.,<span class="variable">$d</span>                           --删除当前行至行尾的内容</div><div class="line">:g/^\(.*\)$\n\1$/d              --删除连续相同的行，保留最后一行</div><div class="line">:g/\%(^\1$\n\)\@&lt;=\(.*\)$/d     --删除连续相同的行，保留最开始一行</div><div class="line">:g/^\s*$\n\s*$/d                --删除连续多个空行，只保留一行空行</div><div class="line">:5,20s/^<span class="comment">#//g                    --删除5到20行开头的 # 注释</span></div></pre></td></tr></table></figure>
<h3 id="定制vim的工作特性"><a href="#定制vim的工作特性" class="headerlink" title="定制vim的工作特性"></a>定制vim的工作特性</h3><p>在末行模式下进行定制，仅对当前 <code>vim</code> 进程有效。</p>
<p>永久有效：</p>
<ol>
<li>全局：/etc/vimrc文件</li>
<li>用户个人：~/.vimrc（一般没有，需要手动创建）</li>
</ol>
<p>使用 <code>:set</code> 命令进行设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:<span class="built_in">set</span> [option]           --选项的设置</div></pre></td></tr></table></figure>
<div class="note warning"><p>常见的功能选项包括</p>
</div>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">autoindent          --设置该选项，则正文自动缩进</div><div class="line">ignorecase          --设置该选项，则忽略规则表达式中大小写字母的区别</div><div class="line">number              --设置该选项，则显示正文行号</div><div class="line">ruler               --设置该选项，则在屏幕底部显示光标所在行、列的位置</div><div class="line">tabstop             --设置按 Tab 键跳过的空格数。例如 :<span class="built_in">set</span> tabstop=n，n 默认值为 8</div><div class="line">hlsearch            --设置该选项，则搜索高亮显示</div><div class="line">syntax              --设置该选项，则启动语法高亮</div><div class="line"><span class="built_in">help</span>                --获取帮助</div></pre></td></tr></table></figure>
<h3 id="分屏功能"><a href="#分屏功能" class="headerlink" title="分屏功能"></a>分屏功能</h3><p>如果想同时查看多个文件，就需要用到 <code>vim</code> 的分屏功能。<br><code>vim</code> 的分屏，主要有两种方式：</p>
<ol>
<li>上下分屏（水平）</li>
<li>左右分屏（垂直）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:sp             --上下分屏</div><div class="line">:vsp            --左右分屏</div></pre></td></tr></table></figure>
<p>也可以在终端的命令行就启用分屏功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ vim -o file1 file2 ...    --水平分屏</div><div class="line">$ vim -O file1 file2 ...    --垂直分屏</div></pre></td></tr></table></figure>
<p>理论上，一个<code>vim</code>窗口可以，可以分为多个屏幕，切换屏幕需要使用键盘组合键以及方向键：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Ctrl+w+←        --切换到当前分屏的左边一屏</div><div class="line">Ctrl+w+→        --切换到当前分屏的右边一屏</div><div class="line">Ctrl+w+↓        --切换到当前分屏的下边一屏</div><div class="line">Ctrl+w+↑        --切换到当前分屏的上边一屏</div></pre></td></tr></table></figure>
<hr>
<h1 id="vim插件"><a href="#vim插件" class="headerlink" title="vim插件"></a>vim插件</h1><p>vim“编辑器之神”的称号并不是浪得虚名，然而，这个荣誉的背后，或许近半的功劳要归功于强大的插件支持特性，以及社区开发的各种各样功能强大的插件。</p>
<p>插件的配置，请参考下面的链接：</p>
<ol>
<li>Vim配置、插件和使用技巧：<a href="http://www.jianshu.com/p/a0b452f8f720" target="_blank" rel="external">http://www.jianshu.com/p/a0b452f8f720</a></li>
<li>手把手教你把Vim改装成一个IDE编程环境：<a href="http://blog.csdn.net/wooin/article/details/1858917" target="_blank" rel="external">http://blog.csdn.net/wooin/article/details/1858917</a></li>
</ol>
<hr>
<h1 id="vim官方文档"><a href="#vim官方文档" class="headerlink" title="vim官方文档"></a>vim官方文档</h1><ol>
<li>vim官方文档：<a href="http://vimdoc.sourceforge.net/" target="_blank" rel="external">http://vimdoc.sourceforge.net/</a></li>
<li>vim维基中文文档：<a href="https://wiki.archlinux.org/index.php/Vim_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">https://wiki.archlinux.org/index.php/Vim_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87</a>)</li>
</ol>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29378196&auto=0&height=66"></iframe>

<p>本文出自<a href="http://maxiecloud.com" target="_blank" rel="external">Maxie’s Notes</a>博客，转载请务必保留此出处。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
<!--author：maxie（马驰原）-->
<!--QQ：17045930-->
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;Vim是一个高度可配置的文本编辑器，用于创建和更改任何类型的文本非常高效。&lt;br&gt;它与大多数UNIX系统、Linux系统和Apple OS X一起被列为“vi”&lt;br&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;vim的功能包括：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;广泛的插件系统&lt;/li&gt;
&lt;li&gt;支持数百种编程语言和文件格式&lt;/li&gt;
&lt;li&gt;强大的搜索和替换功能&lt;/li&gt;
&lt;li&gt;与许多工具集成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://ww2.sinaimg.cn/large/006tNbRwly1fecxo9nswuj31040rw77l.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux基础知识" scheme="http://yoursite.com/categories/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之十四  [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%8D%81%E5%9B%9B/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之十四/</id>
    <published>2017-04-02T12:50:05.000Z</published>
    <updated>2017-04-02T13:48:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"> [^ ] 跟[! ]差在哪？ (RE: Regular Expression）<br></blockquote></p>
<hr>
<h3 id="Regular-Expression-正则表达式"><a href="#Regular-Expression-正则表达式" class="headerlink" title="Regular Expression (正则表达式)"></a>Regular Expression (正则表达式)</h3><hr>
<p>接下来的Regular Expression(RE) 可是个大题目，要讲的很多。<br>我这里当然不可能讲得很全。<br>只希望能带给大家一个基本的入门概念，就很足够了…</p>
<p>先来考一下英文好了：What is expression?<br>简单来说，就是”表达”，也就是人们在沟通的时候所要陈述的内容。</p>
<p>然而，生活中，表达方要清楚的将意思描述清楚，<br>而让接收方完整无误地领会，可不是件容易的事情。</p>
<p>因而才会出现那么多的”误会”, 真可叹句”表达不易”啊……</p>
<a id="more"></a>
<p>同样的情形也发生在计算机的数据处理过程中，<br>尤其是当我们在描述一段”文字内容”的时候….<br>那么，我们不禁要问：<br>有何方法可以让大家的误会降至最低程度，<br>而让表达的精确度达到最高程度呢？<br>答案就是”标准化”了，<br>也就是我们这里要谈的<code>Regular Expression</code>啦…^_^</p>
<p>然而，在进入<code>RE</code>介绍之前，不妨先让我们温习一下shell十三问之第4问，<br>那就是关于quoting的部分。</p>
<p><strong>关键是要能够区分 shell command line上的meta与literal的这两种不同的字符类型</strong>。</p>
<p>然后，我这里也跟你讲：<br><strong>RE 表达式里字符也分meta与literal这两种</strong>。</p>
<p>呵，不知亲爱的读者是否被我搞混乱了呢？… ^_^</p>
<p>这也难怪啦，因为这的确是最容易混淆的地方，<br>刚学<code>RE</code>的朋友很多时候，都死在这里！<br>因此，请特别小心理解哦…</p>
<p>简单而言，除非你将<code>RE</code>写在特定程序使用的脚本里，<br>否则，我们的<code>RE</code>也是通过 command line输入的。<br>然而，<br><strong>不少RE所使用的meta字符，跟shell 的meta字符是冲突的</strong>。</p>
<p>比方说，<br><strong><code>*</code>这个字符，在RE里是一个modifier(修饰符);而在command line上，确是wildcard(通配符)</strong>。</p>
<p>那么，我们该如何解决这样的冲突呢？<br>关键就是看你对shell十三问的第4问中所提的quoting是否足够理解了！</p>
<p>若你明白到<br><strong>shell quoting 就是用来在command line上关闭shell meta这一基本原理</strong>，<br>那你就能很轻松的解决 RE meta与shell meta的冲突问题了：<br><strong>用shell quoting 关闭掉shell meta就是了</strong>。<br>就这么简单… ^_^</p>
<p>再以刚提到<code>*</code>字符为例，<br>若在command line的path中没有quoting处理的话，<br>如abc* 就会被作为wildcard expression来扩充及重组了。<br>若将其置于quoting中，即”abc*“，则可以避免wildcard expand的处理。</p>
<p>好了，说了大半天，还没有进入正式的RE介绍呢….<br>大家别急，因为我的教学风格就是要先建立基础，循序渐进的… ^_^<br>因此, 我这里还要再啰嗦一个观念，才会到RE的说明啦…(哈…别打我…)</p>
<p>当我们在谈到RE时，千万别跟wildcard搞混在一起！<br>尤其是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">在command line的位置里，wildcard只作用于argument的path上；</div><div class="line">而RE却只用于&quot;字符串处理&quot; 的程序中，这与路径名一点关系也没有。</div></pre></td></tr></table></figure></p>
<blockquote>
<p> <strong>Tips:</strong><br> RE 所处理的字符串，通常是指纯文本或通过stdin读进的内容。</p>
</blockquote>
<p>okay，够了够了，我已看到一堆人开始出现不耐烦的样子了… ^_^<br>现在，就让我们登堂入室，揭开RE的神秘面纱吧，<br>这样可以放过我了吧？ 哈哈…</p>
<p>在RE的表达式里，主要分为两种字符：<code>literal</code>与<code>meta</code>。<br>所谓<code>literal</code>就是在RE里不具有特殊功能的字符，如abc，123等；<br>而<code>meta</code>,在RE里具有特殊的功能。<br>要关闭之，需要在<code>meta</code>之前使用escape()转义字符。</p>
<p>然而，在介绍<code>meta</code>之前，先让我们来认识一下字符组合(character set)会更好些。</p>
<p>一、所谓的char set就是将多个连续的字符作为一个集合。<br>例如：</p>
<table>
<thead>
<tr>
<th>char set</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>abc</td>
<td>表示abc三个连续的字符，但彼此独立而非集合。(可简单视为三个char set)</td>
</tr>
<tr>
<td>(abc)</td>
<td>表示abc这三个连续字符的集合。(可简单视为一个char set)</td>
</tr>
<tr>
<td>abc\</td>
<td>xyz</td>
<td>表示abc或xyz这两个char set之一</td>
</tr>
<tr>
<td>[abc]</td>
<td>表示单一字符，可为a或b或c;与wildcard的[abc]原理相同，称之为字符类。</td>
</tr>
<tr>
<td>[^abc]</td>
<td>表示单一字符，不为a或b或c即可。(与wildcard [!abc]原理相同)</td>
</tr>
<tr>
<td>.</td>
<td>表示任意单个字符，(与wildcard的?原理相同)</td>
</tr>
</tbody>
</table>
<p>note: abc|xyz  表示abc或xyz这两个char set之一</p>
<p>在认识了RE的char set这个概念之后，然后，在让我们多认识几个RE中常见的meta字符：</p>
<p>二、 锚点(anchor): 用以标识RE在句子中的位置所在。<br>常见的有：  </p>
<table>
<thead>
<tr>
<th>锚点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>表示句首。如，^abc表示以abc开头的句子。</td>
</tr>
<tr>
<td>$</td>
<td>表示句尾。如，abc$表示以abc结尾的句子。</td>
</tr>
<tr>
<td>\&lt;</td>
<td>表示词首。如，\&lt;abc表示以abc开头的词。</td>
</tr>
<tr>
<td>\&gt;</td>
<td>表示词尾。如，abc\&gt;表示以abc结尾的词。</td>
</tr>
</tbody>
</table>
<p>三、 修饰符(modifier)：独立表示时本身不具意义，专门用以修饰前一个char set出现的次数。<br>常见的有：</p>
<table>
<thead>
<tr>
<th>modifier</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>表示前一个char set出现0次或多次，即任意次。如ab*c表示a与c之间可以有0个或多个b。</td>
</tr>
<tr>
<td>?</td>
<td>表示前一个char set出现0次或1次，即至多出现1次。如ab?c 表示a与c之间可以有0个或1个b。</td>
</tr>
<tr>
<td>+</td>
<td>表示前一个char set出现1次或多次，即至少出现1次。如ab+c 表示a与c之间可以有1个或多个b。</td>
</tr>
<tr>
<td>{n}</td>
<td>表示前一个char set出现n次。如ab{n}c 表示a与c之间可以有n个b。</td>
</tr>
<tr>
<td>{n, }</td>
<td>表示前一个char set至少出现n次。如ab{n}c 表示a与c之间至少有n个b。</td>
</tr>
<tr>
<td>{n, m}</td>
<td>表示前一个char set至少出现n次，至多出现m次。如ab{n，m}c 表示a与c之间至少有n个b，至多有m个b。</td>
</tr>
</tbody>
</table>
<p>然而，当我们在识别modifier时，却很容易忽略”边界(boundary)字符”的重要性。</p>
<p>以<code>ab{3,5}c</code>为例，这里的a与c就是边界字符了。<br>若没有边界字符的帮忙，我们很容易做出错误的解读。<br>比方说: 我们用<code>ab{3,5}</code>这个RE（少了c这个边界字符)<br>可以抓到”abbbbbbbbbb”(a后面有10个b)的字符串吗？<br>从刚才的modifier的说明，我们一般认为，我们要的b是3到5个，<br>若超出了此范围，就不是我们所要表达的。<br>因此，我们或许会很轻率地认为这个RE抓不到结果（上述”abbbbbbbbbb”字符串）。</p>
<p>然而，答案却是可以的！为什么呢？<br>让我们重新解读<code>ab{3,5}</code>这个RE看看：<br>我们要表达的是a后接3到5个b即可，但3到5个b后面，我们却没有规定什么，<br>因此，在RE后面可以是任意的字符串，当然包括b也可以啦！(明白了吗？)</p>
<p>同样，我们用<code>b{3,5}c</code>也同样可以抓到”abbbbbbbbbbc”<br>这样的字符串。</p>
<p>但当我们用<code>ab{3,5}c</code>这样的RE时，<br>由于同时有a与c这连个边界字符，就截然不同了！</p>
<p>有空在思考一下，为何我们用下面这些RE都抓到abc这样的字符串呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x*</div><div class="line">ax*, abx*, ax*b</div><div class="line">abcx*, abx*c, ax*bc</div><div class="line">bx*c, bcx*, x*bc</div></pre></td></tr></table></figure></p>
<p>但, 若我们在这些RE前后分别加<code>^</code>与<code>$</code>这样的anchor，那又如何呢？</p>
<p>刚学RE时，只要能掌握上面这些基本的meta的大概就可以入门了。<br>一如前述，RE是一种规范化的文字表达式，<br>主要用于某些文字处理工具之间，如：<br>grep， perl， vi，awk，sed，等等，<br>常用于表示一段连续的字符串，查找和替换。</p>
<p>然而每种工具对RE表达式的具体解读或有一些细微差别，<br>不过节本原理还是一致的。<br>只要掌握RE的基本原理，那就一理通百理了，<br>只是在实践时，稍加变通即可。</p>
<p>比方以grep来说，<br>在Linux上，你可以找到grep，egrep，fgrep这些程序，<br>其差异大致如下：</p>
<p>grep： 传统的grep程序，在没有任何选项(options)的情况下，只输出符合RE字串的句子，<br> 其常见的选项如下：</p>
<table>
<thead>
<tr>
<th>选项 (option)</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>-v</td>
<td>反模式，  只输出“不含”RE的字符串的行。</td>
</tr>
<tr>
<td>-r</td>
<td>　递归模式，可同时处理所有层级的子目录里的文件</td>
</tr>
<tr>
<td>-q</td>
<td>静默模式，不输出任何结果(stderr 除外，常用于获取return value，符合为true，否则，为false.</td>
</tr>
<tr>
<td>-i</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>-w</td>
<td>整词匹配，类似 \<re\></re\></td>
</tr>
<tr>
<td>-n</td>
<td>同时输出行号</td>
</tr>
<tr>
<td>-l</td>
<td>输出匹配RE的文件名</td>
</tr>
<tr>
<td>-o</td>
<td>只输出匹配RE的字符串。(gnu新版独有，不见得所有版本支持)</td>
</tr>
<tr>
<td>-E</td>
<td>切换为egrep</td>
</tr>
</tbody>
</table>
<p>egrep：为grep的扩充版本，改良了许多传统grep不能或者不便的操作，</p>
<ul>
<li>grep下不支持<code>?</code>与<code>+</code>这两种meta，但egrep支持；</li>
<li>grep 不支持<code>a|b</code>或（<code>abc|xyz</code>）这类“或一”的匹配，但egrep支持；</li>
<li>grep 在处理<code>{n,m}</code>时，需要\{ 与 \}处理，但egrep不需。</li>
</ul>
<p>等诸如此类的。我个人建议能用egrep就不用grep啦…^_^</p>
<p>fgrep: 不作RE处理，表达式仅作一般的字符串处理，所有的meta均市区功能。</p>
<p>好了，关于RE的入门，我们暂时就介绍到这里。<br>虽然有点乱，且有些观念也不恨精确，<br>不过，姑且算是对大家的一个交差吧…^_^<br>若这两天有时间的话，我在举些范例来分析一下，以帮助大家更好的理解。<br>假如更有可能的话，也顺道为大家介绍一下sed这个工具。</p>
<hr>
<h3 id="Part-III-eval"><a href="#Part-III-eval" class="headerlink" title="Part-III eval"></a>Part-III eval</h3><hr>
<p>讲到command line的重组特性，<br>真的需要我们好好的加以解释的。</p>
<p>如此便能抽丝剥茧的一层层的将整个command line分析的<br>一清二楚，而不至于含糊。</p>
<p>假如这个重组的特性理解了，那我们介绍一个好玩的命令：<code>eval</code>.</p>
<p>我们在变量替换的过程中，常会碰到所谓的复式变量的问题：<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a=1</div><div class="line">A1=abc</div></pre></td></tr></table></figure></p>
<p>我们都知道<code>echo $A1</code>就可以得到abc的结果。<br>然而，我们能否用$A$a来取代$A1，而同一样替换为abc呢？</p>
<p>这个问题我们可用很轻松的用<code>eval</code>来解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eval echo \$A$a</div></pre></td></tr></table></figure></p>
<p>说穿了，<code>eval</code> 只不过是在命令行完成替换重组后，<br>在来一次替换重组罢了…<br>就是这么简单啦～～～ ^_^</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt; [^ ] 跟[! ]差在哪？ (RE: Regular Expression）&lt;br&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Regular-Expression-正则表达式&quot;&gt;&lt;a href=&quot;#Regular-Expression-正则表达式&quot; class=&quot;headerlink&quot; title=&quot;Regular Expression (正则表达式)&quot;&gt;&lt;/a&gt;Regular Expression (正则表达式)&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;接下来的Regular Expression(RE) 可是个大题目，要讲的很多。&lt;br&gt;我这里当然不可能讲得很全。&lt;br&gt;只希望能带给大家一个基本的入门概念，就很足够了…&lt;/p&gt;
&lt;p&gt;先来考一下英文好了：What is expression?&lt;br&gt;简单来说，就是”表达”，也就是人们在沟通的时候所要陈述的内容。&lt;/p&gt;
&lt;p&gt;然而，生活中，表达方要清楚的将意思描述清楚，&lt;br&gt;而让接收方完整无误地领会，可不是件容易的事情。&lt;/p&gt;
&lt;p&gt;因而才会出现那么多的”误会”, 真可叹句”表达不易”啊……&lt;/p&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之十三  [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%8D%81%E4%B8%89/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之十三/</id>
    <published>2017-04-02T12:49:59.000Z</published>
    <updated>2017-04-02T13:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">[^ ] 跟[! ]差在哪？ (wildcard)<br></blockquote>


<p>这个题目说穿了，<br>就是要探讨Wildcard与Regular Expression的差别的。<br>这也是很多初学shell的朋友很容易混淆的地方。</p>
<a id="more"></a>
<p>首先，让我们回到十三问之第2问，<br>再一次将我们提到的command line format 温习一次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">command_name options arguments</div></pre></td></tr></table></figure>
<p>同时，也再来理解一下，我在第5章所提到的变量替换的特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">先替换，再重组 command line!</div></pre></td></tr></table></figure></p>
<p>有了这个两个基础后，再让我们来看Wildcard是什么回事吧。</p>
<h3 id="Part-I-Wildcard-（通配符）"><a href="#Part-I-Wildcard-（通配符）" class="headerlink" title="Part-I Wildcard （通配符）"></a>Part-I Wildcard （通配符）</h3><hr>
<p>首先，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`Wildcard` 也是属于 `command line` 的处理工序，作用于 `arguments` 里的 `path` 之上。</div></pre></td></tr></table></figure></p>
<p>没错，它不用在<code>command_name</code>，也不用在<code>options</code>上。<br>而且，若argument不是path的话，那也与wildcard无关。</p>
<p>换句更为精确的定义来讲，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`wildcard`是一种命令行的路径扩展(path expansion)功能。</div></pre></td></tr></table></figure></p>
<p>提到这个扩展，那就不要忘了 command line的“重组”特性了！</p>
<p>是的，这与<code>变量替换</code>(variable subtitution)及<br><code>命令替换</code>(command substitution)的重组特性是一样的。</p>
<p>也就是在<code>wildcard</code>进行扩展后，<br>命令行会先完成重组，才会交给shell来处理。</p>
<p>了解了<code>wildcard</code>的扩展与重组特性后，<br>接下来，让我们了解一些常见的wildcard吧。 </p>
<table>
<thead>
<tr>
<th>wildcard</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配0个或多个字符</td>
</tr>
<tr>
<td>?</td>
<td>匹配任意单一字符</td>
</tr>
<tr>
<td>[list]</td>
<td>匹配list中任意单一字符</td>
</tr>
<tr>
<td>[!list]</td>
<td>匹配不在list中任意单一字符</td>
</tr>
<tr>
<td>{string1,string2,…}</td>
<td>匹配string1或者stsring2或者(…)中其一字符串</td>
</tr>
</tbody>
</table>
<p>Note:<br>  list 中可以指定单个字符，如abcd,<br> 也可以指定ASCII字符的起止范围，如 a-d。<br>  即[abcd] 与 [a-d] 是等价的，称为一个自定义的字符类。</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a*b     # a 与 b 之间可以有任意个字符（0个或多个），如aabcb, axyzb, a012b,ab等。</div><div class="line">a?b     # a 与 b 之间只能有一个字符，但该字符可以任意字符，如 aab, abb, acb, azb等。</div><div class="line">a[xyz]b # a 与 b 之间只能有一个字符，但这个字符只能是x或者y或者z，如：axb, ayb, azb这三个。</div><div class="line">a[!0-9]b# a 与 b 之间只能有一个字符，但这个字符不能是阿拉伯数字，如aab，ayb，a-b等。</div><div class="line">a&#123;abc,xyz,123&#125;b # a 与 b之间只能是abc或者xyz或者123这三个字串之一，扩展后是aabcb，axyzb，a123b。</div></pre></td></tr></table></figure></p>
<ol>
<li><p><code>[! ]</code> 中的<code>!</code> 只有放在第一位时，才有取反的功效。<br>eg:<br> <code>[!a]*</code> 表示当前目录下不以a开头的路径名称；<br> <code>/tmp/[a\!]*</code>表示/tmp目录下所有以a 或者 ! 开头的路径名称；</p>
<p> 思考：为何!前面要加\呢？提示是十三问之4.</p>
</li>
<li><p><code>[ - ]</code>中<code>-</code>左右两边均有字符时，才表示一个范围，否则,仅作<code>-</code>(减号)字符来处理。<br>举例：<br> <code>/tmp/*[-z]/[a-zA-Z]*</code> 表示/tmp 目录下所有以z或者-结尾的子目录中，<br> 以英文字母(不分大小写)开头的目录名称。</p>
</li>
<li><p>以*或?开头的wildcard不能匹配隐藏文件(即以.开头的文件名)。<br>eg:<br> <code>*.txt</code>并不能匹配<code>.txt</code>但能匹配1.txt这样的路径名。<br> 但1*txt及1?txt均可匹配1.txt这样的路径名。</p>
</li>
</ol>
<p>基本上，要掌握wildcard并不难，<br>只要多加练习，再勤于思考，就能灵活运用了。</p>
<p>再次提醒：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">别忘了wildcard的&quot;扩展&quot; + &quot;重组&quot; 这个重要特性，而且只作用在 argument的path上。</div></pre></td></tr></table></figure></p>
<p>比方说，<br>假如当前目录下有：<br>a.txt b.txt c.txt 1.txt 2.txt 3.txt 这几个文件。</p>
<p>当我们在命令行中执行<code>ls -l [0-9].txt</code>的命令行时，<br>因为wildcard处于argument的位置上，</p>
<p>于是根据匹配的路径，扩展为: 1.txt 2.txt 3.txt，<br>在重组出<code>ls -l 1.txt 2.txt 3.txt</code> 这样的命令行。</p>
<p>因此，你在命令行上敲 <code>ls -l [0-9].txt</code><br>与 <code>ls -l 1.txt 2.txt 3.txt</code> 输出的结果是一样，<br>原因就是在于此。</p>
<h2 id="shell是十三问的总结语"><a href="#shell是十三问的总结语" class="headerlink" title="shell是十三问的总结语"></a>shell是十三问的总结语</h2><hr>
<p>好了，该是到了结束的时候了。<br>婆婆妈妈地跟大家啰嗦了一堆shell的基础概念。</p>
<p>目的不是要告诉大家“答案”，而是要带给大家“启发”…</p>
<p>在日后的关于shell的讨论中，我或许经常用”连接”的方式<br>指引十三问中的内容。</p>
<p>以便我们在进行技术探讨时，彼此能有一些讨论的基础，<br>而不至于各说各话、徒费时力。</p>
<p>但更希望十三问能带给你更多的思考与乐趣，<br>至为重要的是通过实践来加深理解。</p>
<p>是的，我很重视<strong>实践</strong>与<strong>独立思考</strong>这两项学习要素。</p>
<p>若你能够掌握其中的真谛，那请容我说声：<br><strong>恭喜十三问你没白看了</strong> ^_^</p>
<p>p.s.<br>至于补充问题部分，我暂时不写了。<br>而是希望：</p>
<ol>
<li>大家补充题目。</li>
<li>一起来写心得。</li>
</ol>
<p>Good luck and happy studing！</p>
<hr>
<h2 id="shell十三问原作者网中人签名中的bash的fork-bomb"><a href="#shell十三问原作者网中人签名中的bash的fork-bomb" class="headerlink" title="##shell十三问原作者网中人签名中的bash的fork bomb"></a>##shell十三问原作者<strong><code>网中人</code></strong>签名中的bash的fork bomb</h2><p>最后，Markdown整理者补上本书的原作者<strong>网中人</strong>的个性签名：</p>
<blockquote>
<p><strong> 君子博学而日叁省乎己，则知明而行无过矣。</strong></p>
<p>一个能让系统shell崩溃的shell 片段：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:() &#123; :|:&amp; &#125;; :      # &lt;--- 这个别乱跑！好奇会死人的！</div><div class="line">echo &apos;十人|日一|十十o&apos; | sed &apos;s/.../&amp;\n/g&apos;   # &lt;--- 跟你讲就不听，再跑这个就好了...</div></pre></td></tr></table></figure>
<p>原来是一个bash的fork炸弹：ref：<a href="http://en.wikipedia.org/wiki/Fork_bomb" target="_blank" rel="external">http://en.wikipedia.org/wiki/Fork_bomb</a></p>
<p>整理后的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">:() &#123;</div><div class="line">	</div><div class="line">	:|:&amp;</div><div class="line">&#125;</div><div class="line">:</div></pre></td></tr></table></figure></p>
<blockquote>
<p>代码分析：</p>
<p>(即除最后一行外)</p>
<p>定义了一个 shell 函数，函数名是<code>:</code>，</p>
<p>而这个函数体执行一个后台命令<code>:|:</code> </p>
<p>即冒号命令(或函数，下文会解释)的输出<br>通过管道再传给冒号命令做输入</p>
<p>最后一行执行“:”命令</p>
</blockquote>
<p>在各种shell中运行结果分析：</p>
<blockquote>
<p>这个代码只有在 <strong>bash</strong> 中执行才会出现不断创建进程而耗尽系统资源的严重后果;</p>
<p>在 ksh (Korn shell), sh (Bourne shell)中并不会出现，</p>
<p>在 ksh88 和传统 unix Bourne shell 中冒号不能做函数名，</p>
<p>即便是在 unix-center freebsd 系统中的 sh 和 pdksh（ksh93 手边没有，没试）中冒号可以做函数名，但还是不会出现那个效果。</p>
<p>原因是 sh、ksh 中内置命令的优先级高于函数，所以执行“:”，<br>总是执行内置命令“:”而不是刚才定义的那个恐怖函数。</p>
<p>但是在 <strong>bash</strong> 中就不一样，bash 中函数的优先级高于内置命令，<br>所以执行“:”结果会导致不断的递归，而其中有管道操作，<br>这就需要创建两个子进程来实现，这样就会不断的创建进程而导致资源耗尽。</p>
</blockquote>
<p>众所周知，bash是一款极其强大的shell，提供了强大的交互与编程功能。</p>
<p>这样的一款shell中自然不会缺少“函数”这个元素来帮助程序进行模块化的高效开发与管理。<br>于是产生了由于其特殊的特性，bash拥有了fork炸弹。</p>
<p>Jaromil在2002年设计了最为精简的一个fork炸弹的实现。</p>
<blockquote>
<p>所谓fork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环.</p>
<p>fork炸弹并不需要有特别的权限即可对系统造成破坏。</p>
<p>fork炸弹实质是一个简单的递归程序。</p>
<p>由于程序是递归的，如果没有任何限制，</p>
<p>这会导致这个简单的程序迅速耗尽系统里面的所有资源.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;[^ ] 跟[! ]差在哪？ (wildcard)&lt;br&gt;&lt;/blockquote&gt;


&lt;p&gt;这个题目说穿了，&lt;br&gt;就是要探讨Wildcard与Regular Expression的差别的。&lt;br&gt;这也是很多初学shell的朋友很容易混淆的地方。&lt;/p&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之十二  [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%8D%81%E4%BA%8C/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之十二/</id>
    <published>2017-04-02T12:49:55.000Z</published>
    <updated>2017-04-02T13:43:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">for what？ while与until差在哪？<br></blockquote></p>
<hr>
<p>今天要介绍的是shell script设计中常见的<code>循环</code>(<code>loop</code>).<br>所谓的<code>loop</code>就是script中的一段在一定条件下反复执行的代码。</p>
<p>bash shell中常用的<code>loop</code>有如下三种：</p>
<ul>
<li>for</li>
<li>while</li>
<li>until</li>
</ul>
<a id="more"></a>
<p>###1. for loop</p>
<hr>
<p><code>for</code> loop 是从一个清单列表中读进变量的值，<br>并依次的循环执行<code>do</code>到<code>done</code>之间的命令行。<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for var in one two three four five</div><div class="line">do</div><div class="line">    echo -----------------</div><div class="line">	echo &apos;$var is &apos;$var</div><div class="line">	echo</div><div class="line">done</div></pre></td></tr></table></figure></p>
<blockquote>
<p> 上例的执行结果将会是：</p>
<ol>
<li><p>for会定义一个叫var的变量，其值依次是one two three four five。</p>
<ol>
<li><p>因为有5个变量值，因此，<code>do</code>与<code>done</code>之间的命令行会被循环执行5次。</p>
</li>
<li><p>每次循环均用<code>echo</code>产生3个句子。而第二行中不在hard quote之内的$var会被替换。</p>
</li>
<li><p>当最后一个变量值处理完毕，循环结束。</p>
</li>
</ol>
</li>
</ol>
</blockquote>
<p>我们不难看出，在<code>for</code> loop中，变量值的多寡，决定循环的次数。<br>然而，变量在循环中是否使用则不一定，得视设计需求而定。<br>倘若<code>for</code> loop没有使用in这个keyword来制变量清单的话，其值将从<br><code>$@</code>(或<code>$*</code>)中继承：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for var; do</div><div class="line">	......</div><div class="line">done</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Tips:</strong></p>
<p>若你忘记了`positional parameter, 请温习第9章…</p>
</blockquote>
<p><code>for</code> loop用于处理“清单”(list)项目非常方便，<br>其清单除了明确指定或从<code>postional parameter</code>取得之外，<br>也可以从<code>变量替换</code>或者<code>命令替换</code>取得…<br>(再一次提醒：别忘了命令行的“重组”特性)<br>然而，对于一些“累计变化”的项目(整数的加减)，for也能处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for ((i = 1; i &lt;= 10; i++))</div><div class="line">do</div><div class="line">	echo &quot;num is $i&quot;</div><div class="line">done</div></pre></td></tr></table></figure></p>
<h2 id="2-while-loop"><a href="#2-while-loop" class="headerlink" title="###2. while loop"></a>###2. while loop</h2><p>除了<code>for</code> loop, 上面的例子，<br>我们也可改用<code>while</code> loop来做到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">num=1</div><div class="line">while [ &quot;$num&quot; -le 10 ]; do</div><div class="line">	echo &quot;num is $num&quot;</div><div class="line">	num=$(($num + 1))</div><div class="line">done</div></pre></td></tr></table></figure></p>
<p><code>while</code> loop的原理与<code>for</code> loop稍有不同：<br>它不是逐次处理清单中的变量值，<br>而是取决于<code>while</code> 后面的命令行的return value：</p>
<ul>
<li>若为true， 则执行<code>do</code>与<code>done</code>之间的命令，<br>然后重新判断<code>while</code>后的return value。</li>
<li>若为false，则不再执行<code>do</code>与<code>done</code>之间的命令而结束循环。</li>
</ul>
<blockquote>
<p>分析上例：</p>
<ol>
<li><p>在<code>while</code>之前，定义变量num=1.</p>
<ol>
<li>然后测试(<code>test</code>)$num是否小于或等于10.</li>
</ol>
</li>
<li><p>结果为true，于是执行<code>echo</code>并将num的值加1.</p>
</li>
<li><p>再作第二轮测试，此时num的值为1+1=2，依然小于或等于10，因此，为true，循环继续。</p>
</li>
<li><p>直到num为10+1=11时，测试才会失败…于是结束循环。</p>
</li>
</ol>
</blockquote>
<p>我们不难发现：<br><strong>若<code>while</code>的测试结果永远为true的话，那循环将一直永久执行下去</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while:; do</div><div class="line">	echo looping...</div><div class="line">done</div></pre></td></tr></table></figure>
<p>上面的<strong><code>:</code>是bash的null command，不做任何动作，<br>除了返回true的return value</strong>。<br>因此这个循环不会结束，称作死循环。</p>
<p>死循环的产生有可能是故意设计的(如跑daemon)，<br>也可能是设计的错误。</p>
<p>若要结束死循环，可通过signal来终止(如按下ctrl-c).<br>(关于process与signal，等日后有机会再补充，十三问略过。)</p>
<h2 id="3-until-loop"><a href="#3-until-loop" class="headerlink" title="####3.until loop"></a>####3.until loop</h2><p>一旦你能够理解<code>while</code> loop的话，那就能理解<code>until</code> loop:<br>**与<code>while</code>相反， <code>until</code>是在return value 为false时进入循环，否则，结束。<br>因此，前面的例子，我们也可以轻松的用<code>until</code>来写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">num=1</div><div class="line">until [ ! &quot;$num&quot; -le 10 ]; do</div><div class="line">	echo &quot;num is $num&quot;</div><div class="line">	num=$(($num + 1))</div><div class="line">done</div></pre></td></tr></table></figure></p>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">num=1</div><div class="line"></div><div class="line">until [ &quot;$num&quot; -gt 10 ]; do</div><div class="line">	echo &quot;num is $num&quot;</div><div class="line">	num=$(($num + 1))</div><div class="line">done</div></pre></td></tr></table></figure>
<p>okay, 关于bash的三个常用的loop暂时介绍到这里。</p>
<h2 id="4-shell-loop中的break与continue"><a href="#4-shell-loop中的break与continue" class="headerlink" title="###4. shell loop中的break与continue"></a>###4. shell loop中的break与continue</h2><p>在结束本章之前，再跟大家补充两个loop有关的命令：</p>
<ul>
<li><code>break</code></li>
<li><code>continue</code><br>这两个命令常用在复合式循环里，<br>也就是<code>do ... done</code>之间又有更进一层的loop，<br>当然，用在单一循环中也未尝不可啦… ^_^</li>
</ul>
<p><code>break</code>用来中断循环，也就是强迫结束循环。<br>若<code>break</code>后面指定一个数值n的话，则从里向外中断第n个循环，<br>预设值为 <code>break 1</code>，也就是中断当前循环。<br>在使用break时，需要注意的是，它与<code>return</code>及<code>exit</code>是不同的：</p>
<ul>
<li><code>break</code>是结束loop；</li>
<li><code>return</code>是结束function；</li>
<li><code>exit</code>是结束script/shell;</li>
</ul>
<p>而<code>continue</code>则与<code>break</code>相反：强迫进入下一次循环动作.</p>
<p>若你理解不来的话，那你可简单的看成：<br>在<code>continue</code>在<code>done</code>之间的句子略过而返回到循环的顶端…</p>
<p>与<code>break</code>相同的是：<code>continue</code>后面也可以指定一个数值n，<br>以决定继续哪一层(从里往外计算)的循环，<br>预设值为 <code>continue 1</code>,也就是继续当前的循环。</p>
<p>在shell script设计中，若能善用loop，<br>将能大幅度提高script在复杂条件下的处理能力。<br>请多加练习吧…</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;for what？ while与until差在哪？&lt;br&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;今天要介绍的是shell script设计中常见的&lt;code&gt;循环&lt;/code&gt;(&lt;code&gt;loop&lt;/code&gt;).&lt;br&gt;所谓的&lt;code&gt;loop&lt;/code&gt;就是script中的一段在一定条件下反复执行的代码。&lt;/p&gt;
&lt;p&gt;bash shell中常用的&lt;code&gt;loop&lt;/code&gt;有如下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for&lt;/li&gt;
&lt;li&gt;while&lt;/li&gt;
&lt;li&gt;until&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之十一  [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%8D%81%E4%B8%80/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之十一/</id>
    <published>2017-04-02T12:49:51.000Z</published>
    <updated>2017-04-02T13:39:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">你要if还是case呢？<br></blockquote></p>
<hr>
<p>还记得我们在第10章所介绍的<code>return value</code>吗？</p>
<p>是的，接下来的介绍的内容与之有关，<br>若你的记忆也被假期所抵消的话，<br>那建议您还是回去温习温习再回来…</p>
<p>若你记得<code>return value</code>，我想你也应该记得了<br><code>&amp;&amp;</code> 与 <code>||</code> 什么意思吧?<br>用这两个符号再搭配 command group的话，<br>我们可让shell script变得更加聪明哦。<br>比方说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cmd1 &amp;&amp; &#123;</div><div class="line">    cmd2</div><div class="line">	cmd3</div><div class="line">	;</div><div class="line">&#125; || &#123;</div><div class="line">	cmd4</div><div class="line">	cmd5</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>意思是说：<br>若 cmd1的<code>return value</code>为true的话，<br>然后执行cmd2与cmd3，<br>否则执行cmd4与cmd5.</p>
<a id="more"></a>
<p>事实上， 我们在写shell script的时候，<br>经常需要用到这样、那样的条件<br>以作出不同的处理动作。<br>用<code>&amp;&amp;</code>与<code>||</code>的确可以达成条件执行的结果，<br>然而，从“人类语言”上来理解，<br>却不是那么直观。<br>更多时候，我们还是喜欢用<code>if...then...else...</code><br>这样的的keyword来表达条件执行。</p>
<p>在bash shell中，我们可以如此修改上一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if cmd1</div><div class="line">then</div><div class="line">	cmd2</div><div class="line">	cmd3</div><div class="line">else</div><div class="line">	cmd4</div><div class="line">	cmd5</div><div class="line">fi</div></pre></td></tr></table></figure></p>
<p>这也是我们在shell script中最常用的<code>if</code>判断式：<br> 只要<code>if</code>后面的command line返回true的return value<br> (我们常用<code>test</code>命令返回的return value)，<br> 然则就执行<code>then</code>后面的命令，否则，执行<code>else</code>之后的命令，<br> <code>fi</code>则是用来结束判断式的keyword。</p>
<p> 在<code>if</code>的判断式中，<code>else</code>部分可以不用，但<code>then</code>是必需的。<br> (若<code>then</code>后不想跑任何command，可用<code>:</code>这个<code>null command</code>代替)。<br> 当然，then或else后面，也可以再使用更进一层的条件判断式，<br> 这在shell script的设计上很常见。<br> 若有多项条件需要”依序”进行判断的话，<br> 那我们则可使用<code>elif</code>这样的keyword：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if cmd1; then</div><div class="line">    cmd2;</div><div class="line">elif cmd3; then</div><div class="line"> 	cmd4</div><div class="line">else</div><div class="line"> 	cmd5</div><div class="line">fi</div></pre></td></tr></table></figure>
<p> 意思是说：<br>     若cmd1为true，然则执行cmd2；<br>     否则在测试cmd3，若为true则执行cmd4；<br>     倘若cmd1与cmd3均不成立，那就执行cmd5。</p>
<p> <code>if</code>判断式的例子很常见，你可从很多shell script中<br> 看得到，我这里不再举例子了…</p>
<p> 接下来为要为大家介绍的是<code>case</code>判断式。<br> 虽然<code>if</code>判断式已可应付大部分的条件执行了，<br> 然而，在某些场合中，却不够灵活，<br> <strong>尤其是在string式样的判断上</strong>，比方如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">QQ() &#123;</div><div class="line">    echo -n &quot;Do you want to continue? (Yes/No): &quot;</div><div class="line"> 	read YN</div><div class="line"> 	if [ &quot;$YN&quot; = Y -o &quot;$YN&quot; = y -o &quot;$YN&quot; = &quot;Yes&quot; -o &quot;$YN&quot; = &quot;yes&quot; -o &quot;$YN&quot; = YES]</div><div class="line"> 	then</div><div class="line"> 		QQ</div><div class="line"> 	else</div><div class="line"> 		exit 0</div><div class="line"> 	fi	</div><div class="line">&#125;</div><div class="line"></div><div class="line">QQ</div></pre></td></tr></table></figure>
<p>从例中，我们看得出来，<br>最麻烦的部分是在判断YN的值可能有好几种样式。</p>
<p>聪明的你或许会如此修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> QQ() &#123;</div><div class="line"> 	echo -n &quot;Do you want to continue? (Yes/No): &quot;</div><div class="line"> 	read YN</div><div class="line"> 	if echo &quot;$YN&quot; | grep -q &apos;^[Yy]\([Ee][Ss]\)*$&apos;</div><div class="line"> 	then</div><div class="line"> 		QQ</div><div class="line"> 	else</div><div class="line"> 		exit 0</div><div class="line"> 	fi	</div><div class="line">&#125;</div><div class="line"></div><div class="line">QQ</div></pre></td></tr></table></figure></p>
<p>也就是用<code>Regular Expression</code>来简化代码。<br>(我们有机会，再来介绍<code>RE</code>)<br>只是…是否有其他更方便的方法呢？<br>有的，就是用<code>case</code>判断式即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> QQ() &#123;</div><div class="line"> 	echo -n &quot;Do you want to continue? (Yes/No): &quot;</div><div class="line"> 	read YN</div><div class="line"> 	case &quot;$YN&quot; in</div><div class="line"> 		[Yy]|[Yy][Ee][Ss])</div><div class="line"> 			QQ</div><div class="line"> 			;;</div><div class="line"> 		*)</div><div class="line"> 			exit 0</div><div class="line"> 			;;</div><div class="line"> 	esac</div><div class="line">&#125;</div><div class="line"></div><div class="line">QQ</div></pre></td></tr></table></figure></p>
<p>我们常用的<code>case</code>的判断式来判断某一变量<br>在不同的值(通常是string)时，作出不同的处理，<br>比方说， <strong>判断script参数，以执行不同的命令</strong>。</p>
<p>若你有兴趣，且用linux系统的话，<br>不妨挖一挖<code>/etc/init.d/*</code>中的那堆script中的<code>case</code>用法.<br>如下就是一例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">case &quot;$1&quot; in</div><div class="line">	start)</div><div class="line">		start</div><div class="line">		;;</div><div class="line">	stop)</div><div class="line">		stop</div><div class="line">		;;</div><div class="line">	status)</div><div class="line">		rhstatus</div><div class="line">		;;</div><div class="line">	restart|reload)</div><div class="line">		restart</div><div class="line">		;;</div><div class="line">	condrestart)</div><div class="line">		[ -f /var/lock/subsys/syslog ] &amp;&amp; restart || :</div><div class="line">		;;</div><div class="line"></div><div class="line">	*)</div><div class="line">		echo $&quot;Usage: $0 &#123;start|stop|status|restart|condrestart&#125;&quot;</div><div class="line">		exit 1</div><div class="line">esac</div></pre></td></tr></table></figure></p>
<p>(若你对 postional parameter的印象已经模糊了，请重看第9章吧。)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;你要if还是case呢？&lt;br&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;还记得我们在第10章所介绍的&lt;code&gt;return value&lt;/code&gt;吗？&lt;/p&gt;
&lt;p&gt;是的，接下来的介绍的内容与之有关，&lt;br&gt;若你的记忆也被假期所抵消的话，&lt;br&gt;那建议您还是回去温习温习再回来…&lt;/p&gt;
&lt;p&gt;若你记得&lt;code&gt;return value&lt;/code&gt;，我想你也应该记得了&lt;br&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 与 &lt;code&gt;||&lt;/code&gt; 什么意思吧?&lt;br&gt;用这两个符号再搭配 command group的话，&lt;br&gt;我们可让shell script变得更加聪明哦。&lt;br&gt;比方说：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;cmd1 &amp;amp;&amp;amp; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    cmd2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	cmd3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; || &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	cmd4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	cmd5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;意思是说：&lt;br&gt;若 cmd1的&lt;code&gt;return value&lt;/code&gt;为true的话，&lt;br&gt;然后执行cmd2与cmd3，&lt;br&gt;否则执行cmd4与cmd5.&lt;/p&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之十  [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%8D%81/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之十/</id>
    <published>2017-04-02T12:49:48.000Z</published>
    <updated>2017-04-02T14:01:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">&gt;与&lt; 差在哪？<br></blockquote>




<h4 id="1-文件描述符-fd-File-Descriptor"><a href="#1-文件描述符-fd-File-Descriptor" class="headerlink" title="1. 文件描述符(fd, File Descriptor)"></a>1. 文件描述符(fd, File Descriptor)</h4><hr>
<p>谈到<code>I/O redirection</code>,不妨先让我们认识一下<code>File Descriptor</code>(<code>fd</code>，文件描述符)。</p>
<p>进程的运算，在大部分情况下，都是进行数据(data)的处理，<br>这些数据从哪里，读进来？又输出到哪里呢？<br>这就是file descriptor(fd)的功用了。</p>
<p>在shell的进程中，最常使用的<code>fd</code>大概有三个，分别为:</p>
<ul>
<li>0：standard Input (<code>STDIN</code>) </li>
<li>1: standard output(<code>STDOUT</code>)</li>
<li>2: standard Error output （<code>STDERR</code>）</li>
</ul>
<p>在标准情况下，这些fd分别跟如下设备(device)关联：</p>
<ul>
<li><code>stdin</code>(0): keyboard</li>
<li><code>stdout</code>(1): monitor</li>
<li><code>stderr</code>(2): monitor</li>
</ul>
<a id="more"></a>
<blockquote>
<p><strong>Tips:</strong><br>linux中的文件描述符(fd)用整数表示。<br>linux中任何一个进程都默认打开三个文件,<br>这三个文件对应的文件描述符分别是：0, 1, 2;<br>即stdin, stdout, stderr.</p>
</blockquote>
<p>我们可以用如下命令测试一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ mail -s test root</div><div class="line">this is a test mail。</div><div class="line">please skip.</div><div class="line">^d (同时按下ctrl 跟d键)</div></pre></td></tr></table></figure></p>
<p>很明显，<code>mail</code>进程所读进的数据，就是从<br><code>stdin</code> 也就是keyboard读进的。<br>不过，不见得每个进程的<code>stdin</code>都跟<code>mail</code>一样<br>从<code>keyboard</code>读进，因为进程的作者可以从文件参数读进<code>stdin</code>，<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/passwd</div></pre></td></tr></table></figure></p>
<p>但，要是<code>cat</code>之后没有文件参数则如何呢？<br>哦， 请你自己玩玩看…^_^<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Tips:</strong></p>
<p>请留意数据输出到哪里去了，<br>最后别忘了按<code>ctrl+d</code>(<code>^d</code>), 退出stdin输入。</p>
</blockquote>
<p>至于<code>stdout</code>与<code>stderr</code>，嗯…等我有空再续吧…^_^<br>还是，有哪位前辈来玩接龙呢？</p>
<p>相信，经过上一个练习后，<br>你对<code>stdin</code>与<code>stdout</code>应该不难理解了吧？<br>然后，让我们看看<code>stderr</code>好了。</p>
<p>事实上，<code>stderr</code>没什么难理解的：<br>说白了就是“错误信息”要往哪里输出而已…<br>比方说, 若读进的文件参数不存在的，<br>那我们在monitor上就看到了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls no.such.file</div><div class="line">ls: no.such.file: No such file or directory</div></pre></td></tr></table></figure>
<p>若同一个命令，同时成生<code>stdout</code>与<code>stderr</code>呢？<br>那还不简单，都送到monitor来就好了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ touch my.file</div><div class="line">$ ls my.file on.such.file</div><div class="line">ls: no.such.file: No such file or directory</div><div class="line">my.file</div></pre></td></tr></table></figure></p>
<p>okay, 至此，关于fd及其名称、还有相关联的设备，<br>相信你已经没问题了吧？</p>
<hr>
<h4 id="2-I-O-重定向-I-O-Redirection"><a href="#2-I-O-重定向-I-O-Redirection" class="headerlink" title="2. I/O 重定向(I/O Redirection)"></a>2. I/O 重定向(I/O Redirection)</h4><p>那好，接下来让我们看看如何改变这些fd的预设数据通道。</p>
<ul>
<li>用<code>&lt;</code> 来改变读进的数据通道(stdin),使之从指定的文件读进。</li>
<li>用<code>&gt;</code> 来改变输出的数据通道(stdout，stderr),使之输出到指定的文件。</li>
</ul>
<hr>
<h5 id="2-1-输入重定向n-lt-input-redirection"><a href="#2-1-输入重定向n-lt-input-redirection" class="headerlink" title="2.1 输入重定向n&lt;(input redirection)"></a>2.1 输入重定向<code>n&lt;</code>(input redirection)</h5><p>比方说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat &lt; my.file</div></pre></td></tr></table></figure></p>
<p>就是从my.file读入数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mail -s test root &lt; /etc/passwd</div></pre></td></tr></table></figure>
<p>则是从/etc/passwd读入…</p>
<p>这样一来，stdin将不再是从keyboard读入，<br>而是从指定的文件读入了…</p>
<p>严格来说，<strong><code>&lt;</code>符号之前需要指定一个fd的(之前不能有空白)，但因为0是<code>&lt;</code>的预设值，因此，<code>&lt;</code>与<code>0&lt;</code>是一样的*</strong>。</p>
<p>okay，这样好理解了吧？</p>
<p>那要是用两个<code>&lt;</code>，即<code>&lt;&lt;</code>又是啥呢？<br><strong>这是所谓的<code>here document</code>,<br>它可以让我们输入一段文本，<br>直到读到<code>&lt;&lt;</code> 后指定的字符串</strong>。</p>
<p>比方说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ cat &lt;&lt;EOF</div><div class="line">first line here</div><div class="line">second line here</div><div class="line">third line here</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>这样的话, <code>cat</code>会读入3个句子，<br>而无需从keyboard读进数据且要等到(ctrl+d, ^d)结束输入。</p>
<hr>
<h5 id="2-2-重定向输出-gt-n-output-redirection"><a href="#2-2-重定向输出-gt-n-output-redirection" class="headerlink" title="2.2 重定向输出&gt;n(output redirection)"></a>2.2 重定向输出<code>&gt;n</code>(output redirection)</h5><p>当你搞懂了<code>0&lt;</code> 原来就是改变<code>stdin</code>的数据输入通道之后，<br>相信要理解如下两个redirection就不难了：</p>
<ul>
<li><code>1&gt;</code> #改变stdout的输出通道；</li>
<li><code>2&gt;</code> #改变stderr的输出通道；</li>
</ul>
<p>两者都是将原来输出到monitor的数据，<br>重定向输出到指定的文件了。</p>
<p><strong>由于1是<code>&gt;</code>的预设值，<br>因此，<code>1&gt;</code>与<code>&gt;</code>是相同的，都是改变<code>stdout</code></strong>.</p>
<p>用上次的ls的例子说明一下好了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls my.file no.such.file 1&gt;file.out</div><div class="line">ls: no.such.file: No such file or directory</div></pre></td></tr></table></figure></p>
<p>这样monitor的输出就只剩下<code>stderr</code>的输出了，<br>因为<code>stdout</code>重定向输出到文件file.out去了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls my.file no.such.file 2&gt;file.err</div><div class="line">my.file</div></pre></td></tr></table></figure>
<p>这样monitor就只剩下了<code>stdout</code>,<br>因为<code>stderr</code>重定向输出到文件file.err了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ls my.file no.such.file 1&gt;file.out 2&gt;file.err</div></pre></td></tr></table></figure>
<p>这样monitor就啥也没有了，<br>因为<code>stdout</code>与<code>stderr</code>都重定向输出到文件了。</p>
<p>呵呵，看来要理解<code>&gt;</code>一点也不难啦是不？ 没骗你吧？ ^_^<br><strong>不过有些地方还是要注意一下的</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ls my.file no.such.file 1&gt;file.both 2&gt;file.both</div></pre></td></tr></table></figure>
<p>假如<code>stdout</code>(1)与<code>stderr</code>(2)都同时在写入file.both的话，<br>则是采取”覆盖”的方式：后来写入覆盖前面的。</p>
<p>让我们假设一个<code>stdout</code>与<code>stderr</code>同时写入到file.out的情形好了；</p>
<ul>
<li>首先<code>stdout</code>写入10个字符</li>
<li>然后<code>stderr</code>写入6个字符</li>
</ul>
<p>那么，这时原本的<code>stdout</code>输出的10个字符，<br>将被<code>stderr</code>输出的6个字符覆盖掉了。</p>
<p>那如何解决呢？所谓山不转路转，路不转人转嘛，<br>我们可以换一个思维：<br>将<code>stderr</code>导进<code>stdout</code><br>或者将<code>stdout</code>导进到<code>stderr</code>,<br>而不是大家在抢同一份文件，不就行了。<br>bingo就是这样啦：</p>
<ul>
<li>2&gt;&amp;1 #将<code>stderr</code>并进<code>stdout</code>输出</li>
<li>1&gt;&amp;2 或者 &gt;&amp;2 #将<code>stdout</code>并进<code>stderr</code>输出。</li>
</ul>
<p>于是，前面的错误操作可以改写为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls my.file no.such.file 1&gt;file.both 2&gt;&amp;1</div><div class="line">$ ls my.file no.such.file 2&gt;file.both &gt;&amp;2</div></pre></td></tr></table></figure></p>
<p>这样，不就皆大欢喜了吗？ ~~~ ^_^</p>
<p>不过，光解决了同时写入的问题还不够，<br>我们还有其他技巧需要了解的。<br>故事还没有结束，别走开广告后，我们在回来….</p>
<hr>
<h5 id="2-3-I-O重定向与linux中的-dev-null"><a href="#2-3-I-O重定向与linux中的-dev-null" class="headerlink" title="2.3 I/O重定向与linux中的/dev/null"></a>2.3 I/O重定向与linux中的<code>/dev/null</code></h5><p>okay，这次不讲I/O Redirection, 请佛吧…<br>(有没有搞错？<code>网中人</code>是否头壳烧坏了？…)嘻~~~^_^</p>
<p>学佛的最高境界，就是”四大皆空”。<br>至于是空哪四大块，我也不知，因为我还没有到那个境界..<br>这个“空”字,却非常值得反复把玩：<br>—色即是空，空即是色<br>好了，施主要是能够领会”空”的禅意，那离修成正果不远了。</p>
<p> 在linux的文件系统中，有个设备文件: <code>/dev/null</code>.<br> 许多人都问过我，那是什么玩意儿？<br> 我跟你说好了，那就是”空”啦。</p>
<p> 没错空空如也的空就是null了…<br> 请问施主是否忽然有所顿悟了呢？<br> 然则恭喜了。</p>
<p> 这个null在 I/O Redirection中可有用的很呢？</p>
<ul>
<li>将fd <code>1</code>跟fd <code>2</code>重定向到/dev/null去，就可忽略stdout, stderr的输出。</li>
<li>将fd <code>0</code>重定向到/dev/null，那就是读进空(nothing).</li>
</ul>
<p>比方说，我们在执行一个进程时，会同时输出到stdout与stderr，<br>假如你不想看到stderr(也不想存到文件)， 那就可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls my.file no.such.file 2&gt;/dev/null</div><div class="line">my.file</div></pre></td></tr></table></figure></p>
<p>若要相反：只想看到stderr呢？<br>还不简单将stdout，重定向的/dev/null就行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls my.file no.such.file &gt;/dev/null</div><div class="line">ls: no.such.file: No such file or directory</div></pre></td></tr></table></figure></p>
<p>那接下来，假如单纯的只跑进程，而不想看到任何输出呢？<br>哦，这里留了一手，上次没讲的法子,专门赠与有缘人… ^_^<br>除了用 <code>&gt;/dev/null 2&gt;&amp;1</code>之外，你还可以如此：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ls my.file no.such.file &amp;&gt;/dev/null</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Tips:</strong></p>
<p>将&amp;&gt;换成&gt;&amp;也行！</p>
</blockquote>
<hr>
<h5 id="2-4-重定向输出append-gt-gt"><a href="#2-4-重定向输出append-gt-gt" class="headerlink" title="2.4 重定向输出append (&gt;&gt;)"></a>2.4 重定向输出append (<code>&gt;&gt;</code>)</h5><p>okay？ 请完佛，接下来，再让我们看看如下情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;1&quot; &gt; file.out</div><div class="line">$ cat file.out</div><div class="line">1</div><div class="line">$ echo &quot;2&quot; &gt; file.out</div><div class="line">$ cat file.out</div><div class="line">2</div></pre></td></tr></table></figure></p>
<p>看来，我们在重定向stdout或stderr进一个文件时，<br>似乎永远只能获得最后一次的重定向的结果.<br>那之前的内容呢？</p>
<p>呵呵，要解决这个问题，很简单啦，将<code>&gt;</code>换成<code>&gt;&gt;</code> 就好了；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;3&quot; &gt;&gt; file.out</div><div class="line">$ cat file.out</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure></p>
<p>如此一来，被重定向的文件的之前的内容并不会丢失，<br>而新的内容则一直追加在最后面去。so easy?…</p>
<p>但是，只要你再次使用<code>&gt;</code>来重定向输出的话，<br>那么，原来文件的内容被truncated(清洗掉)。<br>这是，你要如何避免呢？<br>—-备份， yes，我听到了，不过，还有更好的吗？<br>既然与施主这么有缘分，老衲就送你一个锦囊妙法吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ set -o noclobber</div><div class="line">$ echo &quot;4&quot; &gt; file.out</div><div class="line">-bash：file: cannot overwrite existing file.</div></pre></td></tr></table></figure></p>
<p>那，要如何取消这个限制呢?<br>哦，将<code>set -o</code>换成 <code>set +o</code>就行了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ set +o noclobber</div><div class="line">$ echo &quot;5&quot; &gt; file.out</div><div class="line">$ cat file.out</div><div class="line">5</div></pre></td></tr></table></figure></p>
<p>再问：那有办法不取消而又“临时”改写目标文件吗？<br>哦，佛曰：不可告也。<br>啊，<del>~开玩笑的，开玩笑啦</del>~^_^，<br>哎，早就料到人心是不足的了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ set -o noclobber</div><div class="line">$ echo &quot;6&quot; &gt;| file.out</div><div class="line">$ cat file.out</div><div class="line">6</div></pre></td></tr></table></figure></p>
<p>留意到没有：<br><strong>在<code>&gt;</code>后面加个<code>|</code>就好，<br>注意： <code>&gt;</code>与<code>|</code>之间不能有空白哦</strong>…</p>
<hr>
<h5 id="2-5-I-O-Redirection的优先级"><a href="#2-5-I-O-Redirection的优先级" class="headerlink" title="2.5 I/O Redirection的优先级"></a>2.5 I/O Redirection的优先级</h5><p>呼….(深呼吸吐纳一下吧)~~~ ^_^<br>再来还有一个难题要你去参透呢:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;some text here&quot; &gt;file</div><div class="line">$ cat &lt; file</div><div class="line">some text here</div><div class="line">$cat &lt; file &gt;file.bak</div><div class="line">$cat &lt; file.bak</div><div class="line">some text here</div><div class="line">$cat &lt; file &gt;file</div></pre></td></tr></table></figure></p>
<p>嗯？注意到没有？<br>—怎么最后那个cat命令看到file是空的呢？<br>why？ why？ why？</p>
<p>前面提到：<code>$cat &lt; file &gt; file</code>之后，<br>原本有内容的文件，结果却被清空了。<br>要理解这个现象其实不难，<br>这只是priority的问题而已：<br><strong> 在IO Redirection中, stdout与stderr的管道先准备好，<br>才会从stdin读入数据。</strong><br>也就是说，在上例中，<code>&gt;file</code>会将file清空，<br>然后才读入 <code>&lt; file</code>。<br>但这时候文件的内容已被清空了，因此就变成了读不进任何数据。</p>
<p>哦，<del>~原来如此</del>~^_^<br>那…如下两例又如何呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cat &lt;&gt; file</div><div class="line">$ cat &lt; file &gt;&gt;file</div></pre></td></tr></table></figure></p>
<p>嗯…同学们，这两个答案就当练习题喽，<br>下课前交作业。</p>
<blockquote>
<p><strong>Tips:</strong><br>我们了解到<code>&gt;file</code>能够快速把文件file清空；<br>或者使用<code>:&gt;file</code>同样可以清空文件，<br><code>:&gt;file</code>与<code>&gt;file</code>的功能：<br>若文件file存在，则将file清空; 否则，创建空文件file (等效于<code>touch file</code>);<br>二者的差别在于<code>&gt;file</code>的方式不一定在所有的shell的都可用。</p>
<p><code>exec 5&lt;&gt;file; echo &quot;abcd&quot; &gt;&amp;5; cat &lt;&amp;5</code><br>将file文件的输入、输出定向到文件描述符5，<br>从而描述符5可以接管file的输入输出；<br>因此，<code>cat &lt;&gt;file</code>等价于<code>cat &lt; file</code>。</p>
<p>而<code>cat &lt; file &gt;&gt;file</code>则使file内容成几何级数增长。</p>
</blockquote>
<p>好了， I/O Redirection也快讲完了，<br>sorry,因为我也只知道这么多而已啦<del>~嘻</del>~^_^<br>不过，还有一样东东是一定要讲的，各位观众(请自行配乐~!#@$%):<br>就是<code>pipe line</code>也。</p>
<hr>
<h5 id="2-6-管道-pipe-line"><a href="#2-6-管道-pipe-line" class="headerlink" title="2.6 管道(pipe line)"></a>2.6 管道(pipe line)</h5><p>谈到<code>pipe line</code>，我相信不少人都不会陌生：<br>我们在很多command line上常看到<code>|</code>符号就是pipe line了。</p>
<p>不过，pipe line究竟是什么东东呢？<br>别急别急…先查一下英文字典，看看pipe是什么意思？<br>没错他就是“水管”的意思…<br>那么，你能想象一下水管是怎样一个根接一根的吗？<br>又， 每根水管之间的input跟output又如何呢？<br>灵光一闪：原来pipe line的I/O跟水管的I/O是一模一样的：<br><strong>上一个命令的stdout接到下一个命令的stdin去了</strong><br>的确如此。不管在command line上使用了多少个pipe line，<br>前后两个command的I/O是彼此连接的<br>(恭喜：你终于开放了 ^_^ )</p>
<p>不过…然而…但是… …stderr呢？<br>好问题不过也容易理解：<br>若水管漏水怎么办？<br>也就是说：在pipe line之间,<br>前一个命令的stderr是不会接进下一个命令的stdin的，<br>其输出，若不用2&gt;file的话，其输出在monitor上来。<br>这点请你在pipe line运用上务必要注意的。</p>
<p>那，或许你有会问:<br><strong>有办法将stderr也喂进下一个命令的stdin吗？</strong><br>(贪得无厌的家伙)，方法当然是有的，而且，你早已学习过了。<br>提示一下就好：**请问你如何将stderr合并进stdout一同输出呢？<br>若你答不出来，下课后再来问我…(如果你脸皮足够厚的话…)</p>
<p>或许，你仍意犹未尽，或许，你曾经碰到过下面的问题：<br>在<code>cmd1 | cmd2 | cmd3 | ...</code><br>这段pipe line中如何将cmd2的输出保存到一个文件呢？</p>
<p>若你写成<code>cmd1 | cmd2 &gt;file | cmd3</code>的话，<br>那你肯定会发现<code>cmd3</code>的stdin是空的，(当然了，你都将<br>水管接到别的水池了)<br>聪明的你或许会如此解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cmd1 | cmd2 &gt;file; cmd3 &lt; file</div></pre></td></tr></table></figure></p>
<p>是的，你可以这样做，但最大的坏处是：<br>file I/O会变双倍，在command执行的整个过程中，<br>file I/O是最常见的最大效能杀手。<br>凡是有经验的shell操作者，都会尽量避免或降低file I/O的频度。</p>
<p>那上面问题还有更好的方法吗？<br>有的，那就是<code>tee</code>命令了。<br><strong>所谓的<code>tee</code>命令是在不影响原本I/O的情况下，<br>将stdout赋值到一个文件中去。</strong><br>因此，上面的命令行，可以如此执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cmd1 | cmd2 | tee file | cmd3</div></pre></td></tr></table></figure></p>
<p>在预设上，<code>tee</code>会改写目标文件，<br>若你要改为追加内容的话，那可用-a参数选项。</p>
<p>基本上，pipe line的应用在shell操作上是非常广泛的。<br>尤其是在text filtering方面，<br>如，cat, more, head, tail, wc, expand, tr,<br>grep, sed, awk…等等文字处理工具。<br>搭配起pipe line 来使用，你会觉得 command line<br>原来活得如此精彩的。<br>常让人有“众里寻他千百度，蓦然回首，那人却在灯火阑珊处”之感…</p>
<p>好了，关于I/O Redirection的介绍就到此告一段落。<br>若日后，有空的话，在为大家介绍其他在shell上好玩的东西。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&amp;gt;与&amp;lt; 差在哪？&lt;br&gt;&lt;/blockquote&gt;




&lt;h4 id=&quot;1-文件描述符-fd-File-Descriptor&quot;&gt;&lt;a href=&quot;#1-文件描述符-fd-File-Descriptor&quot; class=&quot;headerlink&quot; title=&quot;1. 文件描述符(fd, File Descriptor)&quot;&gt;&lt;/a&gt;1. 文件描述符(fd, File Descriptor)&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;谈到&lt;code&gt;I/O redirection&lt;/code&gt;,不妨先让我们认识一下&lt;code&gt;File Descriptor&lt;/code&gt;(&lt;code&gt;fd&lt;/code&gt;，文件描述符)。&lt;/p&gt;
&lt;p&gt;进程的运算，在大部分情况下，都是进行数据(data)的处理，&lt;br&gt;这些数据从哪里，读进来？又输出到哪里呢？&lt;br&gt;这就是file descriptor(fd)的功用了。&lt;/p&gt;
&lt;p&gt;在shell的进程中，最常使用的&lt;code&gt;fd&lt;/code&gt;大概有三个，分别为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0：standard Input (&lt;code&gt;STDIN&lt;/code&gt;) &lt;/li&gt;
&lt;li&gt;1: standard output(&lt;code&gt;STDOUT&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;2: standard Error output （&lt;code&gt;STDERR&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在标准情况下，这些fd分别跟如下设备(device)关联：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stdin&lt;/code&gt;(0): keyboard&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stdout&lt;/code&gt;(1): monitor&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stderr&lt;/code&gt;(2): monitor&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之九  [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E4%B9%9D/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之九/</id>
    <published>2017-04-02T12:49:45.000Z</published>
    <updated>2017-04-02T13:30:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">&amp;&amp; 与 || 差在哪？<br></blockquote></p>
<hr>
<p>一路走来，很辛苦吧？也很快乐吧？ ^_^</p>
<p>在解答本章题目之前，先让我们了解一个概念：<br>return value。</p>
<p>我们在shell下跑的每一个command或function，<br>在结束的时候都会传回父进程一个值，称为 <code>return value</code>。</p>
<p>在shell command line中可用<code>$?</code>，<br>这个变量得到最”新”的一个<code>return value</code>，<br>也就是刚刚结束的那个进程传回的值。</p>
<p><code>Return Value</code>(RV)的取值为0-255之间，<br>由进程或者script的作者自行定义：</p>
<ul>
<li><p>若在script里，用exit RV 来指定其值;<br>若没有指定, 在结束时，以最后一个命令的RV，为script的RV值。</p>
</li>
<li><p>若在function里，则用return RV 来代替exit RV即可。</p>
</li>
</ul>
<a id="more"></a>
<p><strong><code>Return Value</code>的作用：用来判断进程的退出状态(exit status)</strong>.<br>进程的退出状态有两种：</p>
<ul>
<li>0值为”真”(true)</li>
<li>非0值为”假”(false)</li>
</ul>
<p>举个例子来说明好了：<br>假设当前目录内有一个my.file的文件， 而no.file是不存在的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ touch my.file</div><div class="line">$ ls my.file</div><div class="line">$ echo $? #first echo</div><div class="line">0</div><div class="line">$ ls no.file</div><div class="line">ls: no.file: No such file or directory</div><div class="line">$ echo $?     #second echo</div><div class="line">1</div><div class="line">$ echo $?     #third echo</div><div class="line">0</div></pre></td></tr></table></figure></p>
<p>上例的：</p>
<ul>
<li>第一个echo是关于<code>ls my.file</code>的RV，可得到0的值，因此为true。</li>
<li>第二个echo是关于<code>ls no.file</code>的RV，得到非0的值，因此为false。</li>
<li>第三个echo是关于<code>echo $?</code>的RV，得到0值， 因此为true。</li>
</ul>
<p>请记住：<br>每一个command在结束时，都会返回<code>return value</code>，不管你跑什么命令…<br>然而，有一个命令却是“专门”用来测试某一条而返回<code>return value</code>，<br>以供true或false的判断， 它就是<code>test</code>命令。</p>
<p>若你用的是bash， 请在command line下，<br>打<code>man test</code>，或者 <code>man bash</code> 来了解这个<code>test</code>的用法。<br>这是你可用作参考的最精准的文件了，要是听别人说的，仅作参考就好…</p>
<p>下面，我只简单作一些辅助说明，其余的一律以 <code>man</code>为准：<br>首先，<code>test</code>的表达式，我们称为expression，其命令格式有两种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">test expression</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ expression ]</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Note:</strong></p>
<p>请务必注意 <code>[]</code> 之间的空白键!</p>
</blockquote>
<p>用哪一种格式无所谓，都是一样的效果。<br>(我个人比较喜欢后者…)</p>
<p>其次，bash的<code>test</code>目前支持的测试对象只有三种：</p>
<ul>
<li>string：字符串，也就是纯文字。</li>
<li>integer：整数(0或正整数、不含负数或小数)</li>
<li>file: 文件</li>
</ul>
<p>请初学者，一定要搞清楚这三者的差异，<br>因为<code>test</code>所使用的expression是不一样的。</p>
<p>以A=123这个变量为例：</p>
<ul>
<li><p><code>[ &quot;$A&quot; = 123 ]</code> #是字符串测试，测试$A是不是1、2、3这三个字符。</p>
</li>
<li><p><code>[ &quot;$A&quot; -eq 123 ]</code> #是整数测试，以测试$A是否等于123.</p>
</li>
<li><p><code>[-e &quot;$A&quot; ]</code> #文件测试，测试123这份文件是否存在.</p>
</li>
</ul>
<p>第三，<br>当expression测试为“真”时， <code>test</code>就返回0(true)的<code>return value</code>;<br>否则，返回非0(false).</p>
<p>若在 expression 之前加一个<code>!</code>(感叹号)，则在expression为假时，return value为0,<br>否则, return value 为非0值。</p>
<p>同时，<code>test</code>也允许多重复合测试：</p>
<ul>
<li>expression1 -a expression2 #当两个expression都为true，返回0，否则，返回非0；</li>
<li>expression1 -o expression2 #当两个expression均为false时，返回非0，否则，返回0；</li>
</ul>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ -d &quot;$file&quot;  -a  -x &quot;$file&quot; ]</div></pre></td></tr></table></figure></p>
<p>表示当$file是一个目录，且同时具有x权限时，test才会为true。</p>
<p>第四，在command line中使用<code>test</code>时，请别忘记命令行的“重组”特性，<br>也就是在碰到meta时，会先处理meta，在重新组建命令行。<br>(这个概念在第2章和第4章进行了反复强调)</p>
<p>比方说， 若<code>test</code>碰到变量或者命令替换时，<br>若不能满足 expression的格式时，将会得到语法错误的结果。</p>
<p>举例来说好了：</p>
<p>关于<code>[ string1 = string2 ]</code>这个test格式，<br>在等号两边必须要有字符串，其中包括空串(null串,可用soft quote或者hard quote取得)。</p>
<p>假如$A目前没有定义，或被定义为空字符串的话，<br>那如下的用法将会失败：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ unset A</div><div class="line">$ [ $A = abc ]</div><div class="line">[: =: unary oprator expected</div></pre></td></tr></table></figure></p>
<p>这是因为命令行碰到$这个meta时，会替换$A的值，<br>然后，再重组命令行，那就变成了：<br><code>[ = abc ]</code>,<br>如此一来，=的左边就没有字符串存在了，<br>因此，造成test的语法错误。<br>但是，下面这个写法则是成立的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ [ &quot;$A&quot; = abc ]</div><div class="line">$ echo $?</div><div class="line">1</div></pre></td></tr></table></figure>
<p>这是因为命令行重组后的结果为：<br><code>[ &quot;&quot; = abc ]</code>,<br>由于等号的左边我们用soft quote得到一个空串，<br>而让test的语法得以通过…</p>
<p>读者诸君，请务必留意这些细节哦，<br>因为稍一不慎，将会导致<code>test</code>的结果变了个样。<br>若您对<code>test</code>还不是很有经验的话，<br>那在使用test时，不妨先采用如下这一个”法则”:</p>
<p><strong> 若在<code>test</code>中碰到变量替换，用soft quote是最保险的*</strong>。</p>
<p>若你对quoting不熟的话，请重新温习第四章的内容吧…^_^</p>
<p>okay, 关于更多的<code>test</code>的用法，老话一句：请看其man page (<code>man test</code>)吧！^_^</p>
<p>虽然洋洋洒洒读了一大堆，或许你还在嘀咕…那…那个<code>return value</code>有啥用？</p>
<p>问得好:<br>告诉你：return value的作用可大了，<br>若你想要你的shell变”聪明”的话，就全靠它了：<br>有了return value， 我们可以让shell根据不同的状态做不同的事情…</p>
<p>这时候，才让我来揭晓本章的答案吧~~~~^_^</p>
<p><code>&amp;&amp;</code> 与 <code>||</code> 都是用来”组建” 多个command line用的；</p>
<ul>
<li><code>command1 &amp;&amp; command2</code> # command2只有在command1的RV为0(true)的条件下执行。</li>
<li><code>command1 || command2</code> # command2 只有在command1的RV为非0(false)的条件下执行。</li>
</ul>
<p>以例子来说好了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ A=123</div><div class="line">$ [ -n &quot;$A&quot; ] &amp;&amp; echo &quot;yes! it&apos;s true.&quot;</div><div class="line">yes! it&apos;s true.</div><div class="line">$ unset A</div><div class="line">$ [ -n &quot;$A&quot; ] &amp;&amp; echo &quot;yes! it&apos;s true.&quot;</div><div class="line">$ [ -n &quot;$A&quot; ] || echo &quot;no, it&apos;s Not true.&quot;</div><div class="line">no, it&apos;s Not true</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Note:</strong></p>
<p><code>[ -n string ]</code>是测试string长度大于0, 则为true。</p>
</blockquote>
<p>上例中，第一个<code>&amp;&amp;</code>命令之所以会执行其右边的<code>echo</code>命令，<br>是因为上一个<code>test</code>返回了0的RV值；<br>但第二个，就不会执行，因为<code>test</code>返回了非0的结果…<br>同理，<code>||</code>右边的<code>echo</code>会被执行，却正是因为左边的<code>test</code>返回非0所引起的。</p>
<p>事实上，我们在同一个命令行中，可用多个<code>&amp;&amp;</code> 或 <code>||</code> 来组建呢。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ A=123</div><div class="line">$ [ -n &quot;$A&quot; ] &amp;&amp; echo &quot;yes! it&apos;s true.&quot; || echo &quot;no, it&apos;s Not ture.&quot;</div><div class="line">yes! it&apos;s true.</div><div class="line">$ unset A</div><div class="line">$ [ -n &quot;$A&quot; ] &amp;&amp; echo &quot;yes! it&apos;s true.&quot; || echo &quot;no, it&apos;s Not ture.&quot;</div><div class="line">no, it&apos;s Not true</div></pre></td></tr></table></figure></p>
<p>怎样，从这一刻开始，你是否觉得我们的shell是“很聪明”的呢？ ^_^</p>
<p>好了，最后布置一道练习题给大家做做看：<br>下面的判断是：当$A被赋值时，在看看其是否小于100，否则输出too big！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ A=123</div><div class="line">$ [ -n &quot;$A&quot; ] &amp;&amp; [ &quot;$A&quot; -lt 100 ] || echo &apos;too big!&apos;</div><div class="line">$ too big!</div></pre></td></tr></table></figure></p>
<p>若我取消A，照理说，应该不会输出文字啊，(因为第一个条件不成立)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ unset A</div><div class="line">$ [ -n &quot;$A&quot; ] &amp;&amp; [ &quot;$A&quot; -lt 100 ] || echo &apos;too big!&apos;</div><div class="line">$ too big!</div></pre></td></tr></table></figure></p>
<p>为何上面的结果也可得到呢？<br>又如何解决呢？</p>
<blockquote>
<p><strong>Tips:</strong></p>
<p>修改的方法有很多种，<br>其中一种方法可以利用第7章中介绍过 <code>command group</code>…</p>
</blockquote>
<p>快告诉我答案，其余免谈….</p>
<p>解决方法1：<code>sub-shell</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ unset A</div><div class="line">$ [ -n &quot;$A&quot; ] &amp;&amp; ( [ &quot;$A&quot; -lt 100 ] || echo &apos;too big!&apos; )</div></pre></td></tr></table></figure></p>
<p>解决方法二：<code>command group</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ unset A</div><div class="line">$ [ -n &quot;$A&quot; ] &amp;&amp; &#123; [ &quot;$A&quot; -lt 100 ] || echo &apos;too big!&apos;&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&amp;amp;&amp;amp; 与 || 差在哪？&lt;br&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一路走来，很辛苦吧？也很快乐吧？ ^_^&lt;/p&gt;
&lt;p&gt;在解答本章题目之前，先让我们了解一个概念：&lt;br&gt;return value。&lt;/p&gt;
&lt;p&gt;我们在shell下跑的每一个command或function，&lt;br&gt;在结束的时候都会传回父进程一个值，称为 &lt;code&gt;return value&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在shell command line中可用&lt;code&gt;$?&lt;/code&gt;，&lt;br&gt;这个变量得到最”新”的一个&lt;code&gt;return value&lt;/code&gt;，&lt;br&gt;也就是刚刚结束的那个进程传回的值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Return Value&lt;/code&gt;(RV)的取值为0-255之间，&lt;br&gt;由进程或者script的作者自行定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;若在script里，用exit RV 来指定其值;&lt;br&gt;若没有指定, 在结束时，以最后一个命令的RV，为script的RV值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;若在function里，则用return RV 来代替exit RV即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之八  [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%85%AB/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之八/</id>
    <published>2017-04-02T12:49:41.000Z</published>
    <updated>2017-04-02T13:28:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">$@与$*差在哪？<br></blockquote></p>
<hr>
<p>要说$@与$*之前，<br>需得先从shell script的positional parameter谈起…</p>
<p>我们都已经知道变量(variable)是如何定义和替换的，<br>这个不再多讲了。</p>
<a id="more"></a>
<h4 id="1-shell-script的positional-parameter"><a href="#1-shell-script的positional-parameter" class="headerlink" title="1. shell script的positional parameter"></a>1. shell script的positional parameter</h4><hr>
<p>但是，我们还需要知道有些变量是shell内定的，<br>且其名称是我们不能随意修改的。<br>其中，就有positional parameter在内。</p>
<p>在shell script中，我们可用$0, $1, $2, $3 …<br>这样的变量分别提取命令行中的如下部分:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">script_name parameter1 parameter2 parameter3 ...</div></pre></td></tr></table></figure></p>
<p>我们很容易就能猜出, <code>$0</code>就是代表 shell script名称(路径)本身，<br>而<code>$1</code>就是其后的第一个参数，如此类推…</p>
<p>须得留意的是<code>IFS</code>的作用, 也就是<code>IFS</code>被quoting处理后，<br>那么positional parameter也会改变。</p>
<p>如下例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my.sh p1 &quot;p2 p3&quot; p4</div></pre></td></tr></table></figure></p>
<p>由于p2与p3之间的空白键被soft quoting所关闭了，<br>因此，my.sh的中$2是”p2 p3”,而$3则是p4…</p>
<p>还记得前两章，我们提到function时，<br>我们不是说过，它是script中的script吗？^_^</p>
<p>是的，function一样可以读取自己的(有别于script的)<br>positional parameter, 唯一例外的是$0而已。</p>
<p>举例而言：<br>假设my.sh里有一个函数(function)叫my_fun,<br>若在script中跑<code>my_fun fp1 fp2 fp3</code>,<br>那么，function内的$0就是my.sh，而$1是fp1而不是p1了…</p>
<p>不如写个简单的my.sh script 看看吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">my_fun() &#123;</div><div class="line">    echo &apos;$0 inside function is &apos;$0</div><div class="line">	echo &apos;$1 inside function is &apos;$1</div><div class="line">	echo &apos;$2 inside function is &apos;$2</div><div class="line">&#125;</div><div class="line"></div><div class="line">echo &apos;$0 outside function is &apos;$0</div><div class="line">echo &apos;$1 outside function is &apos;$1</div><div class="line">echo &apos;$2 outside function is &apos;$2</div><div class="line"></div><div class="line">my_fun fp1 &quot;fp2 fp3&quot;</div></pre></td></tr></table></figure></p>
<p>然后在command line中跑一下 script就知道了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">chmod 755 my.sh</div><div class="line"></div><div class="line">./my.sh p1 &quot;p2 p3&quot;</div><div class="line">$0 outside function is ./my.sh</div><div class="line">$1 outside function is p1</div><div class="line">$2 outside function is p2 p3</div><div class="line">$0 inside function is ./my.sh</div><div class="line">$1 inside function is fp1</div><div class="line">$2 inside function is fp2 fp3</div></pre></td></tr></table></figure></p>
<p>然而，在使用positional parameter的时候，<br>我们要注意一些陷阱哦：</p>
<p><strong>$10不是替换第10个参数，<br>而是替换第一个参数，然后在补一个0于其后;</strong></p>
<p>也就是说， <code>my.sh one two three four five six seven eight nine ten</code><br>这样的command line, my.sh里的$10不是ten而是one0 哦…小心小心<br>要抓到ten的话，有两种方法：</p>
<ul>
<li><p>方法一：使用我们上一章介绍的${}, 也就是用${10}即可。</p>
</li>
<li><p>方法二：就是shift了。</p>
</li>
</ul>
<p>用通俗的说法来说，<br><strong>所谓的shift就是取消positional parameter中最左边的参数($0不受影响)</strong>。<br>其预设值为1，也就是shift 或shift 1 都是取消$1,<br>而原本的$2则变成$1, $3则变成$2…<br>那亲爱的读者，你说要shift掉多少个参数，<br>才可用$1取得到${10} 呢？ ^_^</p>
<p>okay，当我们对positional parameter有了基本的概念之后，<br>那再让我们看看其他相关变量吧。</p>
<h4 id="2-shell-script的positional-parameter的number"><a href="#2-shell-script的positional-parameter的number" class="headerlink" title="2. shell script的positional parameter的number"></a>2. shell script的positional parameter的number</h4><hr>
<p>先是$#, 它可抓出positional parameter的数量。<br>以前面的<code>my.sh p1 &quot;p2 p3&quot;</code>为例：<br>由于”p2 p3”之间的<code>IFS</code>是在soft quote中，<br>因此，$#就可得到的值是2.<br>但如果p2与p3没有置于quoting中话，<br>那$#就可得到3的值了。<br>同样的规则，在function中也是一样。</p>
<p>因此，我们常在shell script里用如下方法，<br>测试script是否有读进参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ $# = 0 ]</div></pre></td></tr></table></figure></p>
<p>假如为0, 那就表示script没有参数，否则就是带有参数…</p>
<h4 id="3-shell-script中的-与"><a href="#3-shell-script中的-与" class="headerlink" title="3. shell script中的$@与$*"></a>3. shell script中的$@与$*</h4><hr>
<p>接下来就是<strong>$@与$*:<br>精确来讲，两者只有在soft quote中才有差异，<br>否则，都表示“全部参数” ($0除外)</strong>。</p>
<p>若在comamnd line上， 跑<code>my.sh p1 &quot;p2 p3&quot; p4</code>的话，<br>不管$@还是$*, 都可得到 p1 p2 p3 p4就是了。</p>
<p>但是，<strong>如果置于soft quote中的话：</strong></p>
<ul>
<li><strong>“$@”则可得到 “p1” “p2 p3” “p4” 这三个不同字段(word);</strong></li>
<li><strong>“$*”则可得到 “p1 p2 p3 p4” 这一整个单一的字段。</strong></li>
</ul>
<p>我们修改一下前面的my.sh，使之内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">my_fun() &#123;</div><div class="line">	echo &quot;$#&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">echo &apos;the number of parameter in &quot;$@&quot; is &apos; $(my_fun &quot;$@&quot;)</div><div class="line">echo &apos;the number of parameter in &quot;$*&quot; is &apos; $(my_fun &quot;$*&quot;)</div></pre></td></tr></table></figure></p>
<p>然后再执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./my.sh p1 &quot;p2 p3&quot; p4</div></pre></td></tr></table></figure></p>
<p>就知道，$@与$*差在哪了… ^_^</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;$@与$*差在哪？&lt;br&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;要说$@与$*之前，&lt;br&gt;需得先从shell script的positional parameter谈起…&lt;/p&gt;
&lt;p&gt;我们都已经知道变量(variable)是如何定义和替换的，&lt;br&gt;这个不再多讲了。&lt;/p&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之七  [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E4%B8%83/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之七/</id>
    <published>2017-04-02T12:49:39.000Z</published>
    <updated>2017-04-02T13:17:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">()与{}差在哪？<br></blockquote></p>
<hr>
<p>嗯，这次轻松一下，不讲太多… ^_^</p>
<p>先说一下，为何要用()或者{}好了。</p>
<p>许多时候，我们在shell操作上，需要在<br>一定的条件下执行多个命令，也就是说，<br>要么不执行，要么就全执行，而不是每次<br>依序的判断是否要执行下一个命令。</p>
<p>或者，要从一些命令执行的先后次序中得到结果，<br>如算术运算的2*(3+4)那样…</p>
<p>这时候，我们就可以引入”<code>命令群组</code>“(<code>command group</code>)<br>的概念：将许多命令集中处理。</p>
<a id="more"></a>
<p>在shell <code>command line</code>中，一般人或许不太计较<code>()</code>与<br><code>{}</code>这两对符号的差异，虽然两者都可以将多个命令当作群组处理，<br>但若从技术细节上，却是很不一样的：</p>
<ul>
<li><code>()</code> 将<code>command group</code>置于<code>sub-shell</code>(<code>子shell</code>)中去执行，也称 <code>nested sub-shell</code>。</li>
<li><code>{}</code> 则是在同一个<code>shell</code>内完成，也称<code>non-named command group</code>。</li>
</ul>
<p>若你对上一章的fork与source的概念还记得的话，<br>那就不难理解两者的差异了。</p>
<p>要是在 <code>command group</code>中扯上变量及其他环境的修改，<br>我们可以根据不同的需求来使用<code>()</code>或<code>{}</code>。<br>通常而言, 若所作的修改是临时的，且不想影响原有或以后的设定，<br>那我们就使用<code>nested sub-shell</code>, 即<code>()</code>;<br>反之，则用<code>non-named command group</code>, 即<code>{}</code>。</p>
<p>是的，光从<code>command line</code>来看，<code>()</code> 与 <code>{}</code>差别就讲完了，够轻松吧~~~, ^_^</p>
<p>然而，这两个<code>meta</code>用在其他<code>command meta</code>或领域中(如Regular Expression)，<br>还是有很多差别的。<br>只是，我不打算再去说明了，留给读者慢慢发掘好了…</p>
<p>我这里只想补充一个概念，就是<code>function</code>。<br>所谓<code>function</code>，就是用一个名字去命名一个<code>command group</code>,<br>然后再调用这个名字去执行<code>command group</code>。</p>
<p>从<code>non-named command group</code>来推断，<br>大概你也可以推测到我要说的是<code>{}</code>了吧？(yes! 你真聪明 ^_^)</p>
<p>在bash中，function的定义方式有两种：</p>
<ul>
<li><p>方式一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function function_name &#123;</div><div class="line">    command1</div><div class="line">	command2</div><div class="line">	command3</div><div class="line">	.....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方式二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function_name () &#123;</div><div class="line">	command1</div><div class="line">	command2</div><div class="line">	command3</div><div class="line">	......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>用哪一种方式无所谓，<br>只是碰到所定义的名称与现有的命令或者别名冲突的话，<br>方式二或许会失败。<br>但方式二起码可以少打个<code>function</code>这一串英文字符，<br>对懒人来说(如我)，有何乐而不为呢？…^_^</p>
<p><code>function</code> 在一定程度上来说，也可以称为”函数”，<br>但请不要与传统编程所使用的”函数”(library)搞混了，<br>毕竟两者差异很大。<br>唯一相同的是，我们都可以随时用”已定义的名称”来调用它们…</p>
<p>若我们在shell操作中，需要不断地重复某些命令，<br>我们首先想到的，或许是将命令写成shell脚本(shell script)。<br>不过，我们也可以写成function,<br>然后在command line中打上function_name就可当一般的shell script使用了。</p>
<p>若只是你在shell中定义的<code>function</code>,<br>除了用<code>unset</code> function_name取消外，<br>一旦你退出shell， function也跟着消失。<br>然而，在script中使用function却有许多好处，<br>除了提高整体script的执行性能外(因为已经载入)，<br>还可以节省许多重复的代码……</p>
<p>简单而言，若你会将多个命令写成script以供调用的话，<br>那你可以将function看成script中script。… ^_^</p>
<p>而且通过上一章节介绍的<code>source</code>命令，<br>我们可以自行定义许许多多好用的function，<br>在集中写在特定文件中，<br>然后，在其他的script中用<code>source</code>将它们载入，并反复执行。</p>
<p>若你是<code>RedHat Linux</code>的使用者，<br>或许，已经猜出 <code>/etc/rc.d/init.d/functions</code>这个文件时啥作用了~~~ ^_^</p>
<p>okay，说要轻松点的嘛，那这次就暂时写到这吧。<br>祝大家学习愉快，^_^</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;()与{}差在哪？&lt;br&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;嗯，这次轻松一下，不讲太多… ^_^&lt;/p&gt;
&lt;p&gt;先说一下，为何要用()或者{}好了。&lt;/p&gt;
&lt;p&gt;许多时候，我们在shell操作上，需要在&lt;br&gt;一定的条件下执行多个命令，也就是说，&lt;br&gt;要么不执行，要么就全执行，而不是每次&lt;br&gt;依序的判断是否要执行下一个命令。&lt;/p&gt;
&lt;p&gt;或者，要从一些命令执行的先后次序中得到结果，&lt;br&gt;如算术运算的2*(3+4)那样…&lt;/p&gt;
&lt;p&gt;这时候，我们就可以引入”&lt;code&gt;命令群组&lt;/code&gt;“(&lt;code&gt;command group&lt;/code&gt;)&lt;br&gt;的概念：将许多命令集中处理。&lt;/p&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之六   [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%85%AD/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之六/</id>
    <published>2017-04-02T12:49:36.000Z</published>
    <updated>2017-04-02T13:15:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">exec跟source差在哪？<br></blockquote></p>
<hr>
<p>这次让我们从CU  shell版的一个实例帖子来谈起吧：</p>
<p>例中的提问原文如下：</p>
<blockquote>
<p><strong>帖子提问:</strong></p>
<p>cd /etc/aa/bb/cc可以执行<br>但是把这条命令放入shell脚本后，shell脚本不执行！<br>这是什么原因？</p>
</blockquote>
<p>意思是：运行shell脚本，并没有移动到/etc/aa/bb/cc目录。</p>
<a id="more"></a>
<p>我当时如何回答暂时别去深究，先让我们了解一下进程<br>(process)的概念好了。</p>
<p>首先，我们所执行的任何程序，都是父进程(parent process)产生的一个<br>子进程(child process),子进程在结束后，将返回到父进程去。<br>此现象在Linux中被称为<code>fork</code>。</p>
<p>(为何要称为fork呢？ 嗯，画一下图或许比较好理解…^_^)</p>
<p>当子进程被产生的时候，将会从父进程那里获得一定的资源分配、及<br>(更重要的是)继承父进程的环境。</p>
<p>让我们回到上一章所谈到的”环境变量”吧：<br><strong>所谓环境变量其实就是那些会传给子进程的变量</strong>。<br>简单而言, “遗传性”就是区分本地变量与环境变量的决定性指标。<br>然而，从遗传的角度来看，我们不难发现环境变量的另一个重要特征：<br><strong>环境变量只能从父进程到子进程单向传递。<br>换句话说：在子进程中环境如何变更，均不会影响父进程的环境。</strong></p>
<p>接下来，在让我们了解一下shell脚本(shell script)的概念.<br>所谓shell script 讲起来很简单，就是将你平时在shell prompt输入的多行<br><code>command line</code>, 依序输入到一个文件文件而已。</p>
<p>再结合以上两个概念(process + script)，那应该不难理解如下的这句话的意思了：<br>正常来说，当我们执行一个shell script时，其实是先产生一个sub-shell的子进程，<br>然后sub-shell再去产生命令行的子进程。<br>然则，那让我们回到本章开始时，所提到的例子在重新思考：</p>
<blockquote>
<p><strong>帖子提问:</strong></p>
<p>cd /etc/aa/bb/cc可以执行<br>但是把这条命令放入shell脚本后，shell脚本不执行！<br>这是什么原因？</p>
</blockquote>
<p>意思是：运行shell脚本，并没有移动到/etc/aa/bb/cc目录。</p>
<p>我当时的答案是这样的：</p>
<blockquote>
<p>因为，我们一般跑的shell script是用sub-shell去执行的。<br>从process的概念来看，是 parent process产生一个child process去执行，<br>当child结束后，返回parent, 但parent的环境是不会因child的改变而改变的。<br>所谓的环境变量元数很多，如effective id(euid)，variable, working dir等等…<br>其中的working dir($PWD) 正是楼主的疑问所在：<br>当用sub-shell来跑script的话，sub-shell的$pwd会因为cd而变更，<br>但返回primary shell时，$PWD是不会变更的。</p>
</blockquote>
<p>能够了解问题的原因及其原理是很好的，但是？<br>如何解决问题，恐怕是我们更应该感兴趣的是吧？</p>
<p>那好，接下来，再让我们了解一下<code>source</code>命令好了。<br>当你有了<code>fork</code>的概念之后，要理解<code>soruce</code>就不难：</p>
<p>所谓<code>source</code>，就是让script在当前shell内执行、<br>而不是产生一个sub-shell来执行。<br>由于所有执行结果均在当前shell内执行、而不是产生一个sub-shell来执行。</p>
<p>因此, 只要我们原本单独输入的script命令行，变成<code>source</code>命令的参数，<br>就可轻而易举地解决前面提到的问题了。</p>
<p>比方说，原本我们是如此执行script的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./my_script.sh</div></pre></td></tr></table></figure></p>
<p>现在改成这样既可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ source ./my_script.sh</div></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ . ./my_script.sh</div></pre></td></tr></table></figure></p>
<p>说到这里，我想，各位有兴趣看看<code>/etc</code>底下的众多设定的文件，<br>应该不难理解它们被定义后，如何让其他script读取并继承了吧？</p>
<p>若然，日后，你有机会写自己的script，<br>应也不难专门指定一个设定的文件以供不同的script一起”共用”了… ^_^</p>
<p>okay,到这里，若你搞懂<code>fork</code>与<code>source</code>的不同，<br>那接下来再接受一个挑战：</p>
<blockquote>
<p>那<code>exec</code>又与<code>source</code>/<code>fork</code>有何不同呢？</p>
</blockquote>
<p>哦…要了解<code>exec</code>或许较为复杂，尤其是扯上<code>File Decscriptor</code>的话…<br>不过，简单来说：</p>
<blockquote>
<p><code>exec</code> 也是让script在同一个进程上执行，但是原有进程则被结束了。<br>简言之，原有进程能否终止，就是<code>exec</code>与<code>source</code>/<code>fork</code>的最大差异了。</p>
</blockquote>
<p>嗯，光是从理论去理解，或许没那么好消化，<br>不如动手”实践+思考”来得印象深刻哦。</p>
<p>下面让我们为两个简单的script，分别命名为1.sh以及2.sh</p>
<p>1.sh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash </div><div class="line"></div><div class="line">A=B </div><div class="line">echo &quot;PID for 1.sh before exec/source/fork:$$&quot;</div><div class="line"></div><div class="line">export A</div><div class="line">echo &quot;1.sh: \$A is $A&quot;</div><div class="line"></div><div class="line">case $1 in</div><div class="line">        exec)</div><div class="line">                echo &quot;using exec...&quot;</div><div class="line">                exec ./2.sh ;;</div><div class="line">        source)</div><div class="line">                echo &quot;using source...&quot;</div><div class="line">                . ./2.sh ;;</div><div class="line">        *)</div><div class="line">                echo &quot;using fork by default...&quot;</div><div class="line">                ./2.sh ;;</div><div class="line">esac</div><div class="line"></div><div class="line">echo &quot;PID for 1.sh after exec/source/fork:$$&quot;</div><div class="line">echo &quot;1.sh: \$A is $A&quot;</div></pre></td></tr></table></figure>
<p>2.sh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">echo &quot;PID for 2.sh: $$&quot;</div><div class="line">echo &quot;2.sh get \$A=$A from 1.sh&quot;</div><div class="line"></div><div class="line">A=C</div><div class="line">export A</div><div class="line">echo &quot;2.sh: \$A is $A&quot;</div></pre></td></tr></table></figure>
<p>然后分别跑如下参数来观察结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ./1.sh fork</div><div class="line">$ ./1.sh source</div><div class="line">$ ./1.sh exec</div></pre></td></tr></table></figure></p>
<p>好了，别忘了仔细比较输出结果的不同及背后的原因哦…<br>若有疑问，欢迎提出来一起讨论讨论~~~~</p>
<p>happy scripting！ ^_^</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;exec跟source差在哪？&lt;br&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这次让我们从CU  shell版的一个实例帖子来谈起吧：&lt;/p&gt;
&lt;p&gt;例中的提问原文如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;帖子提问:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;cd /etc/aa/bb/cc可以执行&lt;br&gt;但是把这条命令放入shell脚本后，shell脚本不执行！&lt;br&gt;这是什么原因？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;意思是：运行shell脚本，并没有移动到/etc/aa/bb/cc目录。&lt;/p&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之五 [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E4%BA%94/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之五/</id>
    <published>2017-04-02T12:49:33.000Z</published>
    <updated>2017-04-02T13:12:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">问var=value 在export前后的差在哪?<br></blockquote>

<hr>
<p>这次让我们暂时丢开<code>command line</code>,<br>先了解一下bash变量(variable)吧…</p>
<p>所谓的变量，就是利用一个固定的”名称”(name),<br>来存取一段可以变化的”值”(value)。</p>
<a id="more"></a>
<h3 id="1-变量设定-set"><a href="#1-变量设定-set" class="headerlink" title="1. 变量设定(set)"></a>1. 变量设定(set)</h3><p>在bash中， 你可以用”=”来设定或者重新定义变量的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name=value</div></pre></td></tr></table></figure></p>
<p>在设定变量的时候，得遵守如下规则：</p>
<ul>
<li>等号左右两边不能使用分隔符号(IFS),也应避免使用shell的保留元字符(meta charactor); </li>
<li>变量的名称(name)不能使用$符号;</li>
<li>变量的名称(name)的首字符不能是数字(number)。</li>
<li>变量的名称(name)的长度不可超过256个字符。</li>
<li>变量的名称(name)及变量的值的大小写是有区别的、敏感的(case sensitive，) </li>
</ul>
<p>如下是一些变量设定时常见的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A= B #=号前后不能有IFS</div><div class="line">1A=B #变量名称不能以数字开头</div><div class="line">$A=B #变量的名称里有$</div><div class="line">a=B  #这跟a=b是不同的,(这不是错误，提醒windows用户)</div></pre></td></tr></table></figure></p>
<p>如下则是可以接受的设定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A=&quot; B&quot; #IFS被关闭，参考前面的quoting章节</div><div class="line">A1=B   #并非以数字开头</div><div class="line">A=$B   #$可用在变量的值内</div><div class="line">This_Is_A_Long_Name=b #可用_连接较长的名称或值，且有大小区别；</div></pre></td></tr></table></figure></p>
<h3 id="2-变量替换-substitution"><a href="#2-变量替换-substitution" class="headerlink" title="2. 变量替换(substitution)"></a>2. 变量替换(substitution)</h3><p>shell 之所以强大，其中的一个因素是它可以在命令行中对变量作<br>替换(substitution)处理。<br>在命令行中使用者可以使用$符号加上变量名称(除了用=定义变量名称之外)，<br>将变量值给替换出来，然后再重新组建命令行。</p>
<p>比方:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ A=ls</div><div class="line">$ B=la</div><div class="line">$ C=/tmp</div><div class="line">$ $A -$B $C</div></pre></td></tr></table></figure></p>
<p>以上命令行的第一个<code>$</code>是<code>shell prompt</code>, 并不在命令行之内。<br>必须强调的是，我们所提的变量替换，只发生在<code>command line</code>上面。<br>(是的，请让我们再次回到命令行吧！) 仔细分析,最后那行<br><code>command line</code>,不难发现在被执行前(在输入<code>CR</code>字符之前)，<br><code>$</code>符号对每一个变量作替换处理(将变量的值替换出来再重组命令行),<br>最后会得出如下命令行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -la /tmp</div></pre></td></tr></table></figure></p>
<p>还记得第二章，我请大家”务必理解”的那两句吗？<br>若你忘了，我这里重贴一遍：</p>
<blockquote>
<p><strong>Note:</strong></p>
<p>若从技术的细节来看，<code>shell</code>会依据<code>IFS</code>(Internal Field Seperator)<br>将<code>command line</code>所输入的文字拆解为”字段”(word/field)。<br>然后再针对特殊字符(meta)先作处理，最后重组整行<code>command line</code>。</p>
</blockquote>
<p>这里的<code>$</code>就是<code>command line</code>中最经典的meta之一了，<br>就是作变量替换的。在日常的shell操作中，<br>我们常会使用<code>echo</code>命令来查看特定的变量的值，<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo $A -$B $C</div></pre></td></tr></table></figure></p>
<p>我们已学过，<code>echo</code>命令只单纯将其argument送至”标准输出”(stdout, 通常是我们的屏幕)。<br>所以上面的命令会在屏幕上得到如下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -al /tmp</div></pre></td></tr></table></figure></p>
<p>这是由于<code>echo</code>命令在执行时，会先将<code>$A</code> (ls)、<code>$B</code> (la)跟<code>$C</code> (/tmp)给替换出来；<br>利用shell对变量的替换处理能力，我们在设定变量时就更为灵活了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A=B</div><div class="line">B=$A</div></pre></td></tr></table></figure></p>
<p>这样，B的变量值就可继承A变量”当时”的变量值了。<br>不过，不要以”数学逻辑”来套用变量的设定，比方说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A=B</div><div class="line">B=C</div></pre></td></tr></table></figure></p>
<p>这样，并不会让A的变量值变成C。再如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A=B</div><div class="line">B=$A</div><div class="line">A=C</div></pre></td></tr></table></figure></p>
<p>同样也不会让B的值变成C。</p>
<p>上面是单纯定义了两个不同名称的变量：<br>A 与 B, 它们的取值分别是C与B。</p>
<p>若变量被重复定义的话，则原有值为新值所取代。(这不正是”可变的量”吗？^_^)<br>当我们在设定变量的时候，请记住这点：<strong>用一个名称存储一个数值</strong>， 仅此而已。</p>
<p>此外， 我们也可以利用命令行的变量替换能力来”扩充”(append)变量的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A=B:C:D</div><div class="line">A=$A:E</div></pre></td></tr></table></figure></p>
<p>这样， 第一行我们设定A的值为”B:C:D”,<br>然后,第二行再将值扩充为”B:C:D:E”。</p>
<p>上面的扩充的范例，我们使用分隔符号(:)来达到扩充的目的，<br>要是没有分隔符的话，如下是有问题的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A=BCD</div><div class="line">B=$AE</div></pre></td></tr></table></figure></p>
<p>因为第二次是将A的值继承$AE的替换结果，而非$A再加E。<br>要解决此问题，我们可用更严谨的替换处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A=BCD</div><div class="line">A=$&#123;A&#125;E</div></pre></td></tr></table></figure></p>
<p>上例中，我们使用{}将变量名称范围给明确定义出来，<br>如此一来， 我们就可以将A的变量值从BCD给扩充为BCDE。</p>
<blockquote>
<p><strong>Tips:</strong><br>关于${name}事实上还可以做到更多的变量处理能力，<br>这些均属于比较进阶阶段的变量处理，现阶段暂不介绍了，<br>请大家自行参考资料。</p>
</blockquote>
<h3 id="3-export-变量"><a href="#3-export-变量" class="headerlink" title="3. export 变量"></a>3. export 变量</h3><p>严格来说，我们在当前shell中所定义的变量，均属于<br>“本地变量”(local variable), 只有经过<code>export</code>命令的<br>“输出”处理，才能成为”环境变量”(environment variable)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ A=B</div><div class="line">$ export A</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ export A=B</div></pre></td></tr></table></figure></p>
<p>经过<code>export</code>输出处理之后，变量A就能成为一个环境变量<br>供其后的命令使用。在使用<code>export</code>的时候，请别忘记<br>shell在命令行对变量的”替换”(substitution)处理。<br>比方说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ A=B</div><div class="line">$ B=C</div><div class="line">$ export $A</div></pre></td></tr></table></figure></p>
<p>上面的命令并未将A输出为”环境变量”，而是将B导出<br>这是因为在这个命令行中，$A会首先被替换为B,然后在”塞回”<br>作<code>export</code>的参数。</p>
<p>要理解这个<code>export</code>，事实上需要从process(进程)的角度来理解才能透彻。<br>我们将于下一章为大家说明process(进程)的概念，敬请留意。</p>
<h4 id="4-取消变量-unset"><a href="#4-取消变量-unset" class="headerlink" title="4. 取消变量(unset)"></a>4. 取消变量(unset)</h4><p>要取消一个变量，在bash中可使用<code>unset</code>命令来处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unset A</div></pre></td></tr></table></figure></p>
<p>与<code>export</code>一样，<code>unset</code>命令行，也同样会作<br>变量替换(这其实是shell的功能之一)，<br>因此:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ A=B</div><div class="line">$ B=C</div><div class="line">$ unset $A</div></pre></td></tr></table></figure></p>
<p>事实上，所取消的是变量B而不是A。</p>
<p>此外，变量一旦经过unset取消之后，<br>其结果是将整个变量拿掉，而不是取消变量的值。</p>
<p>如下两行其实是很不一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ A=</div><div class="line">$ unset A</div></pre></td></tr></table></figure></p>
<p>第一行只是将变量A设定为”空值”(null value),<br>但第二行则是让变量A不存在。<br>虽然用眼睛来看，<br>这两种变量的状态在如下的命令结果中都是一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ A=</div><div class="line">$ echo $A</div><div class="line"></div><div class="line">$ unset A</div><div class="line">$ echo $A</div></pre></td></tr></table></figure></p>
<p>请学员务必能识别null value 与 unset的本质区别，<br>这在一些进阶的变量处理上是很严格的。</p>
<p>比方说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ str=    #设为null</div><div class="line">$ var=$&#123;str=expr&#125; #定义var</div><div class="line">$ echo $var</div><div class="line"></div><div class="line">$ echo $str</div><div class="line"></div><div class="line">$ unset str #取消str</div><div class="line">$ var=$&#123;str=expr&#125; #定义var</div><div class="line">$ echo $var</div><div class="line">expr</div><div class="line">$ echo $str</div><div class="line">expr</div></pre></td></tr></table></figure></p>
<p>聪明的读者(yes, you!)，稍加思考的话，<br>应该不难发现为何同样的var=${str=expr}<br>在str为null与unset之下的不同吧？<br>若你看不出来，那可能是如下原因之一：</p>
<ul>
<li>你太笨了</li>
<li>不了解 var=${str=expr} 这个进阶处理</li>
<li>对本篇说明还没有来得及消化吸收</li>
<li>我讲得不好</li>
</ul>
<p>不知，您选哪个呢？…… ^_^.</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;问var=value 在export前后的差在哪?&lt;br&gt;&lt;/blockquote&gt;

&lt;hr&gt;
&lt;p&gt;这次让我们暂时丢开&lt;code&gt;command line&lt;/code&gt;,&lt;br&gt;先了解一下bash变量(variable)吧…&lt;/p&gt;
&lt;p&gt;所谓的变量，就是利用一个固定的”名称”(name),&lt;br&gt;来存取一段可以变化的”值”(value)。&lt;/p&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之四 [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%9B%9B/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之四/</id>
    <published>2017-04-02T12:49:30.000Z</published>
    <updated>2017-04-02T13:10:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">“”(双引号)与’’(单引号)差在哪？<br></blockquote></p>
<hr>
<p>还是回到我们的<code>command line</code>来吧…</p>
<p>经过前面两章的学习，应该很清楚当你在<code>shell prompt</code>后面敲打键盘,<br>直到按下<code>Enter</code>键的时候，你输入的文字就是<code>command line</code>了，<br>然后<code>shell</code>才会以进程的方式执行你所交给它的命令。<br>但是，你又可知道：你在<code>command line</code>中输入的每一个文字，<br>对<code>shell</code>来说，是有类别之分的呢？</p>
<p>简单而言，(我不敢说精确的定义，注1),<br><code>command line</code>的每一个<code>charactor</code>, 分为如下两种：</p>
<ul>
<li>literal：也就是普通的纯文字，对<code>shell</code>来说没特殊功能；</li>
<li>meta: 对<code>shell</code>来说，具有特定功能的特殊保留元字符。</li>
</ul>
<a id="more"></a>
<blockquote>
<p><strong>Note:</strong></p>
<p>对于<code>bash shell</code>在处理<code>comamnd line</code>的顺序说明，<br>请参考O’Reilly出版社的<strong>Learning the Bash Shell，2nd Edition</strong>，<br>第177-180页的说明，尤其是178页的流程图：Figure 7-1 …</p>
</blockquote>
<p><code>literal</code>没什么好谈的，<br>像abcd、123456这些”文字”都是literal…(so easy? ^_^)<br>但meta却常使我们困惑…(confused?)<br>事实上，前两章，我们在<code>command line</code>中已碰到两个<br>似乎每次都会碰到的meta：</p>
<ul>
<li><code>IFS</code>：有<code>space</code>或者<code>tab</code>或者<code>Enter</code>三者之一组成(我们常用space)</li>
<li><code>CR</code>: 由<code>Enter</code>产生；</li>
</ul>
<p><code>IFS</code>是用来拆解<code>command line</code>中每一个词(word)用的，<br>因为<code>shell command line</code>是按词来处理的。<br>而<code>CR</code>则是用来结束<code>command line</code>用的，这也是为何我们敲<code>Enter</code>键，<br>命令就会跑的原因。</p>
<p>除了常用的<code>IFS</code>与<code>CR</code>, 常用的meta还有：</p>
<table>
<thead>
<tr>
<th>meta字符</th>
<th>meta字符作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>设定变量</td>
</tr>
<tr>
<td>$</td>
<td>作变量或运算替换(请不要与<code>shell prompt</code>混淆)</td>
<td>命令</td>
</tr>
<tr>
<td>&gt;</td>
<td>输出重定向(重定向stdout)</td>
</tr>
<tr>
<td>&lt;</td>
<td>输入重定向(重定向stdin)</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>命令管道</td>
</tr>
<tr>
<td>&amp;</td>
<td>重定向file descriptor或将命令至于后台(bg)运行</td>
</tr>
<tr>
<td>()</td>
<td>将其内部的命令置于nested subshell执行，或用于运算或变量替换</td>
</tr>
<tr>
<td>{}</td>
<td>将期内的命令置于non-named function中执行，或用在变量替换的界定范围</td>
</tr>
<tr>
<td>;</td>
<td>在前一个命令执行结束时，而忽略其返回值，继续执行下一个命令</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>在前一个命令执行结束时，若返回值为true，继续执行下一个命令</td>
</tr>
<tr>
<td>\</td>
<td>\</td>
<td></td>
<td>在前一个命令执行结束时，若返回值为false，继续执行下一个命令</td>
</tr>
<tr>
<td>!</td>
<td>执行histroy列表中的命令</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>假如我们需要在<code>command line</code>中将这些保留元字符的功能关闭的话，<br>就需要quoting处理了。</p>
<p>在<code>bash</code>中，常用的quoting有以下三种方法：</p>
<ul>
<li>hard quote：’’(单引号)，凡在hard quote中的所有meta均被关闭；</li>
<li>soft quote：””(双引号)，凡在soft quote中大部分meta都会被关闭，但某些会保留(如$);</li>
<li>escape: \ (反斜杠)，只有在紧接在escape(跳脱字符)之后的单一meta才被关闭；</li>
</ul>
<blockquote>
<p><strong>Note:</strong></p>
<p> 在soft quote中被豁免的具体meta清单，我不完全知道，<br> 有待大家补充，或通过实践来发现并理解。</p>
</blockquote>
<p>下面的例子将有助于我们对quoting的了解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ A=B C #空白符未被关闭，作为IFS处理</div><div class="line">$ C：command not found.</div><div class="line">$ echo $A</div><div class="line"></div><div class="line">$ A=&quot;B C&quot; #空白符已被关掉，仅作为空白符</div><div class="line">$ echo $A</div><div class="line">B C</div></pre></td></tr></table></figure></p>
<p>在第一个给A变量赋值时，由于空白符没有被关闭，<br><code>command line</code> 将被解释为：<br><code>A=B 然后碰到&lt;IFS&gt;，接着执行C命令</code><br>在第二次给A变量赋值时，由于空白符被置于soft quote中，<br>因此被关闭，不在作为<code>IFS</code>；<br><code>A=B&lt;space&gt;C</code><br>事实上，空白符无论在soft quote还是在hard quote中，<br>均被关闭。Enter键字符亦然：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ A=`B</div><div class="line">&gt; C</div><div class="line">&gt; &apos;</div><div class="line">$ echo &quot;$A&quot;</div><div class="line">B</div><div class="line">C</div></pre></td></tr></table></figure>
<p>在上例中，由于<code>enter</code>被置于hard quote当中，因此不再作为<code>CR</code>字符来处理。<br>这里的<code>enter</code>单纯只是一个断行符号(new-line)而已，<br>由于<code>command line</code>并没得到<code>CR</code>字符，<br>因此进入第二个<code>shell prompt</code>(<code>PS2</code>, 以&gt;符号表示)，<br><code>command line</code>并不会结束，直到第三行，<br>我们输入的<code>enter</code>并不在hard quote里面，<br>因此没有被关闭，<br>此时，<code>command line</code>碰到<code>CR</code>字符，于是结束，交给shell来处理。</p>
<p>上例的<code>Enter</code>要是被置于soft quote中的话，<code>CR</code>字符也会同样被关闭：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ A=&quot;B</div><div class="line">&gt; C</div><div class="line">&gt; &quot;</div><div class="line">$ echo $A</div><div class="line">B C</div></pre></td></tr></table></figure>
<p>然而，由于 <code>echo $A</code>时的变量没有置于soft quote中，<br>因此，当变量替换完成后，并作命令行重组时，<code>enter</code>被解释为<code>IFS</code>，<br>而不是new-line字符。</p>
<p>同样的，用escape亦可关闭CR字符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ A=B\</div><div class="line">&gt; C\</div><div class="line">&gt;</div><div class="line">$ echo $A</div><div class="line">BC</div></pre></td></tr></table></figure></p>
<p>上例中的，第一个<code>enter</code>跟第二个<code>enter</code>均被escape字符关闭了，<br>因此也不作为<code>CR</code>来处理，但第三个<code>enter</code>由于没有被escape，<br>因此，作为<code>CR</code>结束<code>command line</code>。<br>但由于<code>enter</code>键本身在shell meta中特殊性，在 \ escape字符后面<br>仅仅取消其<code>CR</code>功能， 而不保留其IFS功能。</p>
<p>你或许发现光是一个<code>enter</code>键所产生的字符，就有可能是如下这些可能：</p>
<ul>
<li>CR</li>
<li>IFS</li>
<li>NL(New Line)</li>
<li>FF(Form Feed)</li>
<li>NULL</li>
<li>…</li>
</ul>
<p>至于，什么时候解释为什么字符，这个我就没法去挖掘了，<br>或者留给读者君自行慢慢摸索了…^-^</p>
<p>至于soft quote跟hard quote的不同，主要是对于某些meta的关闭与否，以$来做说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ A=B\ C</div><div class="line">$ echo &quot;$A&quot;</div><div class="line">B C</div><div class="line">$ echo &apos;$A&apos;</div><div class="line">$A</div></pre></td></tr></table></figure></p>
<p>在第一个<code>echo</code>命令行中，$被置于soft quote中，将不被关闭，<br>因此继续处理变量替换，<br>因此，<code>echo</code>将A的变量值输出到屏幕，也就是”B C”的结果。</p>
<p>在第二个<code>echo</code>命令行中，$被置于hard quote中，则被关闭，<br>因此，$只是一个$符号，并不会用来做变量替换处理，<br>因此结果是$符号后面接一个A字母：$A.</p>
<blockquote>
<p> <strong>练习与思考:</strong> 如下结果为何不同？</p>
<p> tips: 单引号和双引号，在quoting中均被关闭了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ A=B\ C</div><div class="line">$ echo &apos;&quot;$A&quot;&apos;  #最外面的是单引号</div><div class="line">&quot;$A&quot;</div><div class="line">$ echo &quot;&apos;$A&apos;&quot;  #最外面的是双引号</div><div class="line">&apos;B C&apos;</div></pre></td></tr></table></figure>
<hr>
<p>在CU的shell版里，我发现很多初学者的问题，<br>都与quoting的理解有关。<br>比方说，若我们在awk或sed的命令参数中，<br>调用之前设定的一些变量时，常会问及为何不能的问题。</p>
<p>要解决这些问题，关键点就是：<strong>区分出 shell meta 与 command meta</strong></p>
<p>前面我们提到的那些meta，都是在command line中有特殊用途的，<br>比方说{}就是将一系列的command line置于不具名的函数中执行(可简单视为command block)，<br>但是，awk却需要用{}来区分出awk的命令区段(BEGIN,MAIN,END).<br>若你在command line中如此输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk &#123;print $0&#125; 1.txt</div></pre></td></tr></table></figure></p>
<p>由于{}在shell中并没有关闭，那shell就将{print $0}视为command block，<br>但同时没有<code>;</code>符号作命令分隔，因此，就出现awk语法错误结果。</p>
<p>要解决之，可用hard quote:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk &apos;&#123;print $0&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>上面的hard quote应好理解，就是将原来的<br>{、<space>、$、}这几个shell meta关闭，<br>避免掉在shell中遭到处理，而完整的成为awk的参数中command meta。</space></p>
<blockquote>
<p><strong>Note:</strong></p>
<p>awk中使用的$0 是awk中内建的field nubmer，而非awk的变量，<br>awk自身的变量无需使用$.</p>
</blockquote>
<p>要是理解了hard quote的功能，在来理解soft quote与escape就不难：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">awk &quot;&#123;print \$0&#125;&quot; 1.txt</div><div class="line">awk \&#123;print \$0\&#125; 1.txt</div></pre></td></tr></table></figure></p>
<p>然而，若要你改变awk的$0的0值是从另一个shell变量中读进呢？<br>比方说：已有变量$A的值是0， 那如何在<code>command line</code>中解决<br>awk的$$A呢？<br>你可以很直接否定掉hard quote的方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;&#123;print $$A&#125;&apos; 1.txt</div></pre></td></tr></table></figure></p>
<p>那是因为$A的$在hard quote中是不能替换变量的。</p>
<p>聪明的读者(如你！)，经过本章的学习，我想，你应该可以理解为<br>为何我们可以使用如下操作了吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A=0</div><div class="line">awk &quot;&#123;print \$$A&#125;&quot; 1.txt</div><div class="line">awk  \&#123;print\ \$$A\&#125; 1.txt</div><div class="line">awk &apos;&#123;print $&apos;$A&apos;&#125;&apos; 1.txt</div><div class="line">awk &apos;&#123;print $&apos;&quot;$A&quot;&apos;&#125;&apos; 1.txt</div></pre></td></tr></table></figure></p>
<p>或许，你能给出更多方案… ^_^</p>
<p>更多练习：</p>
<ul>
<li><a href="http://bbs.chinaunix.net/forum/viewtopic.php?t=207178" target="_blank" rel="external">http://bbs.chinaunix.net/forum/viewtopic.php?t=207178</a><br>一个关于read命令的小问题：<br>很早以前觉得很奇怪：执行read命令，然后读取用户输入给变量赋值，<br>但如果输入是以空格键开始的话，这空格会被忽略，比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">read a  #输入：    abc</div><div class="line">echo &quot;$a&quot; #只输出abc</div></pre></td></tr></table></figure>
</li>
</ul>
<p>原因:<br>    变量a的值，从终端输入的值是以IFS开头，而这些IFS将被shell解释器忽略(trim)。<br>    应该与shell解释器分词的规则有关；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">read a  #输入：\ \ \ abc</div><div class="line">echo &quot;$a&quot; #只输出abc</div></pre></td></tr></table></figure>
<p>需要将空格字符转义</p>
<blockquote>
<p><strong>Note:</strong> </p>
<p> IFS   Internal field separators, normally  space,  tab,  and newline (see Blank Interpretation section).<br> ……<br> Blank Interpretation<br>  After parameter and command  substitution,  the  results  of substitution<br>  are scanned for internal field separator characters (those found in IFS)<br>  and split  into  distinct  arguments  where  such characters are found.<br>  Explicit null arguments (“” or  ‘’)  are  retained.<br>  Implicit  null  arguments(those  resulting  from  parameters that have no values)<br>  are removed.<br>  (refre to: man sh)</p>
</blockquote>
<p>解决思路：</p>
<ol>
<li>shell command line 主要是将整行line给分解(break down)为每一个单词(word);</li>
<li>而词与词之间的分隔符就是IFS (Internal Field Seperator)。</li>
<li>shell会对command line作处理(如替换，quoting等), 然后再按词重组。(注：别忘了这个重组特性)</li>
<li>当你用IFS来事开头一个变量值，那shell会先整理出这个词，然后在重组command line。<br>5.然而，你将IFS换成其他，那shell将视你哪些space/tab为“词”，而不是IFS。那在重组时，可以得到这些词。</li>
</ol>
<p>若你还是不理解，那来验证一下下面这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ A=&quot;  abc&quot; </div><div class="line">$ echo $A</div><div class="line">abc</div><div class="line">$ echo &quot;$A&quot; #note1</div><div class="line">   abc</div><div class="line">$ old_IFS=$IFS</div><div class="line">$ IFS=;</div><div class="line">$ echo $A</div><div class="line">   abc</div><div class="line">$ IFS=$old_IFS</div><div class="line">$ echo $A</div><div class="line">abc</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Note:</strong></p>
<ol>
<li><p>这里是用 soft quoting 将里面的 space 关闭，使之不是 meta(IFS)，<br>而是一个literal(white space);</p>
</li>
<li><p>IFS=; 意义是将IFS设置为空字符，因为;是shell的元字符(meta);</p>
</li>
</ol>
</blockquote>
<p>问题二：为什么多做了几个分号，我想知道为什么会出现空格呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ a=&quot;;;;test&quot;                              </div><div class="line">$ IFS=&quot;;&quot;                                  </div><div class="line">$ echo $a                                  </div><div class="line">   test                                                                         </div><div class="line">$ a=&quot;   test&quot;                              </div><div class="line">$ echo $a                                  </div><div class="line">   test                                                                         </div><div class="line">$ IFS=&quot; &quot;                                  </div><div class="line">$ echo $a                                  </div><div class="line">test</div></pre></td></tr></table></figure></p>
<p>解答：</p>
<p>这个问题，出在<code>IFS=;</code>上。<br>因为这个<code>;</code>在问题一中的command line上是一个meta,<br>并非<code>&quot;;&quot;</code>符号本身。<br>因此，<code>IFS=;</code>是将IFS设置为 null charactor<br>(不是space、tab、newline)。</p>
<p>要不是试试下面这个代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ old_IFS=$IFS</div><div class="line">$ read A</div><div class="line">;a;b;c</div><div class="line">$ echo $A</div><div class="line">;a;b;c</div><div class="line">$ IFS=&quot;;&quot;  #Note2</div><div class="line">$ echo $A</div><div class="line">a b c</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Note:</strong></p>
<p>要关闭<code>;</code>可用<code>&quot;;&quot;</code>或者<code>&#39;;&#39;</code>或者<code>\;</code>。</p>
</blockquote>
<ul>
<li><a href="http://bbs.chinaunix.net/forum/viewtopic.php?t=216729" target="_blank" rel="external">http://bbs.chinaunix.net/forum/viewtopic.php?t=216729</a></li>
</ul>
<p>思考问题二：文本处理：读文件时，如何保证原汁原味。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cat file | while read i</div><div class="line">do</div><div class="line">   echo $i</div><div class="line">done</div></pre></td></tr></table></figure></p>
<p>文件file的行中包含若干空，经过read只保留不重复的空格。<br>如何才能所见即所得。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cat file | while read i</div><div class="line">do</div><div class="line">   echo &quot;X$&#123;i&#125;X&quot;</div><div class="line">done</div></pre></td></tr></table></figure>
<p>从上面的输出，可以看出read，读入是按整行读入的;<br>不能原汁原味的原因：</p>
<ol>
<li>如果行的起始部分有IFS之类的字符，将被忽略;</li>
<li><code>echo $i</code>的解析过程中，首先将$i替换为字符串，<br>然后对echo 字符串中字符串分词，然后命令重组，输出结果;<br>在分词，与命令重组时，可能导致多个相邻的IFS转化为一个;</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cat file | while read i</div><div class="line">do</div><div class="line">  echo &quot;$i&quot;</div><div class="line">done</div></pre></td></tr></table></figure>
<p>以上代码可以解决原因2中的，command line的分词和重组导致meta字符丢失；<br>但仍然解决不了原因1中，read读取行时，忽略行起始的IFS meta字符。</p>
<p>回过头来看上面这个问题：为何要原汁原味呢？<br>cat命令就是原汁原味的，只是shell的read、echo导致了某些shell的meta字符丢失;</p>
<p>如果只是IFS meta的丢失，可以采用如下方式：<br>将IFS设置为null，即<code>IFS=;</code>,<br>在此再次重申此处<code>;</code>是shell的meta字符,而不是literal字符;<br>因此要使用literal的    <code>;</code>应该是<code>\;</code><br>或者关闭meta 的(soft/hard) quoting的<code>&quot;;&quot;</code>或者<code>&#39;;&#39;</code>。</p>
<p>因此上述的解决方案是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">old_IFS=$IFS</div><div class="line">IFS=; #将IFS设置为null</div><div class="line">cat file | while read i</div><div class="line">do</div><div class="line">  echo &quot;$i&quot;</div><div class="line">done</div><div class="line">IFS=old_IFS #恢复IFS的原始值</div></pre></td></tr></table></figure></p>
<p>现在，回过头来看这个问题，为什么会有这个问题呢；<br>其本源的问题应该是没有找到解决原始问题的最合适的方法，<br>而是采取了一个迂回的方式来解决了问题；</p>
<p>因此，我们应该回到问题的本源，重新审视一下，问题的本质。<br>如果要精准的获取文件的内容，应该使用od或者hexdump会更好些。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;“”(双引号)与’’(单引号)差在哪？&lt;br&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;还是回到我们的&lt;code&gt;command line&lt;/code&gt;来吧…&lt;/p&gt;
&lt;p&gt;经过前面两章的学习，应该很清楚当你在&lt;code&gt;shell prompt&lt;/code&gt;后面敲打键盘,&lt;br&gt;直到按下&lt;code&gt;Enter&lt;/code&gt;键的时候，你输入的文字就是&lt;code&gt;command line&lt;/code&gt;了，&lt;br&gt;然后&lt;code&gt;shell&lt;/code&gt;才会以进程的方式执行你所交给它的命令。&lt;br&gt;但是，你又可知道：你在&lt;code&gt;command line&lt;/code&gt;中输入的每一个文字，&lt;br&gt;对&lt;code&gt;shell&lt;/code&gt;来说，是有类别之分的呢？&lt;/p&gt;
&lt;p&gt;简单而言，(我不敢说精确的定义，注1),&lt;br&gt;&lt;code&gt;command line&lt;/code&gt;的每一个&lt;code&gt;charactor&lt;/code&gt;, 分为如下两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;literal：也就是普通的纯文字，对&lt;code&gt;shell&lt;/code&gt;来说没特殊功能；&lt;/li&gt;
&lt;li&gt;meta: 对&lt;code&gt;shell&lt;/code&gt;来说，具有特定功能的特殊保留元字符。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之三  [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E4%B8%89/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之三/</id>
    <published>2017-04-02T12:49:27.000Z</published>
    <updated>2017-04-02T13:08:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">别人echo、你也echo，是问echo知多少？<br></blockquote></p>
<hr>
<p>承接上一章介绍的<code>command line</code>, 这里我们用<code>echo</code>这个命令加以进一步说明。</p>
<blockquote>
<p> <strong>温习</strong><br> 标准的<code>command line</code>三个组成部分：<code>command_name option argument</code></p>
</blockquote>
<p><code>echo</code>是一个非常简单、直接的Linux命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> argument</div></pre></td></tr></table></figure>
<p><code>echo</code>将argument送出到<code>标准输出</code>(<code>stdout</code>),通常是在监视器(monitor)上输出。</p>
<a id="more"></a>
<p><strong>Note：</strong></p>
<blockquote>
<p>在linux系统中任何一个进程默认打开三个文件：stdin、stdout、stderr.</p>
<p>stdin  标准输入</p>
<p>stdout 标准输出</p>
<p>stderr 标准错误输出</p>
</blockquote>
<p>为了更好理解，不如先让我们先跑一下<code>echo</code>命令好了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$echo</div><div class="line"></div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>你会发现只有一个空白行，然后又回到了<code>shell prompt</code>上了。<br>这是因为<code>echo</code>在预设上，在显示完argument之后，还会送出以一个换行符号<br>(<code>new-line charactor</code>).<br>但是上面的command <code>echo</code>并没有任何argument，那结果就只剩一个换行符号。<br>若你要取消这个换行符号， 可以利用<code>echo</code>的<code>-n</code> 选项:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$echo -n</div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>不妨让我们回到<code>command line</code>的概念上来讨论上例的echo命令好了：<br><code>command line</code>只有command_name(<code>echo</code>)及option(<code>-n</code>),并没有显示任何<code>argument</code>。</p>
<p>要想看看<code>echo</code>的<code>argument</code>，那还不简单接下来，你可以试试如下的输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$echo first line</div><div class="line">first line</div><div class="line">$echo -n first line</div><div class="line">first line $</div></pre></td></tr></table></figure></p>
<p>以上两个<code>echo</code>命令中，你会发现<code>argument</code>的部分显示在你的屏幕，<br>而换行符则视 <code>-n</code> 选项的有无而别。<br>很明显的，第二个<code>echo</code>由于换行符被取消了，<br>接下来的<code>shell prompt</code>就接在输出结果的同一行了… ^_^。</p>
<p>事实上，<code>echo</code>除了<code>-n</code> 选项之外，常用选项有：</p>
<ul>
<li>-e: 启用反斜杠控制字符的转换(参考下表)</li>
<li>-E: 关闭反斜杠控制字符的转换(预设如此)</li>
<li>-n: 取消行末的换行符号(与-e选项下的\c字符同意)</li>
</ul>
<p>关于<code>echo</code>命令所支持的反斜杠控制字符如下表：</p>
<table>
<thead>
<tr>
<th></th>
<th>转义字符</th>
<th>字符的意义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>\a</td>
<td>ALERT / BELL(从系统的喇叭送出铃声)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\b</td>
<td>BACKSPACE, 也就是向左退格键</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\c</td>
<td>取消行末之换行符号</td>
</tr>
<tr>
<td></td>
<td>\E</td>
<td>ESCAPE, 脱字符键</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\f</td>
<td>FORMFEED, 换页字符</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\n</td>
<td>NEWLINE,  换行字符</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\r</td>
<td>RETURN,  回车键</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\t</td>
<td>TAB, 表格跳位键</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\v</td>
<td>VERTICAL TAB, 垂直表格跳位键</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\n</td>
<td>ASCII 八进制编码(以x开头的为十六进制)，此处的n为数字</td>
</tr>
<tr>
<td></td>
<td>\</td>
<td>反斜杠本身</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Note：</strong><br>上述表格的资料来自O’Reilly出版社的<strong>Learning the Bash Shell, 2nd Ed</strong>.</p>
</blockquote>
<p>或许，我们可以通过实例来了解<code>echo</code>的选项及控制字符：</p>
<p>例一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ echo -e &quot;a\tb\tc\n\d\te\tf&quot;</div><div class="line">a    b	c</div><div class="line">d	e	f</div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>上例中，用\t来分割abc还有def，及用\n将def换至下一行。</p>
<p>例二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$echo -e &quot;\141\011\142\011\143\012\144\011\145\011\146&quot;</div><div class="line">a	b	c</div><div class="line">d	e	f</div></pre></td></tr></table></figure></p>
<p>与例一中结果一样，只是使用ASCII八进制编码。</p>
<p>例三：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$echo -e &quot;\x61\x09\x62\x09\x63\x0a\x64\x09\x65\x09\x66&quot;</div><div class="line">a	b	c</div><div class="line">d	e	f</div></pre></td></tr></table></figure></p>
<p>与例二差不多，只是这次换用ASCII的十六进制编码。</p>
<p>例四：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$echo -ne &quot;a\tb\tc\nd\te\bf\a&quot;</div><div class="line">a       b       c</div><div class="line">d       f $</div></pre></td></tr></table></figure></p>
<p>因为e字母后面是退格键(\b)，因此输出结果就没有e了。<br>在结束的时听到一声铃响，是\a的杰作。<br>由于同时使用了-n选项，因此<code>shell prompt</code>紧接在第二行之后。<br>若你不用-n的话，那你在\a后再加个\c，也是同样的效果。</p>
<p>事实上，在日后的<code>shell</code>操作及<code>shell script</code>设计上，<br><code>echo</code>命令是最常被使用的命令之一。<br>比方说，使用<code>echo</code>来检查变量值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ A=B</div><div class="line">$ echo $A</div><div class="line">B</div><div class="line">$ echo $?</div><div class="line">0</div></pre></td></tr></table></figure></p>
<blockquote>
<p> <strong>Note:</strong><br> 关于变量的概念，我们留到以下的两章跟大家说明。</p>
</blockquote>
<p>好了，更多的关于<code>command line</code>的格式， 以及<code>echo</code>命令的选项，<br>请您自行多加练习、运用了…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;别人echo、你也echo，是问echo知多少？&lt;br&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;承接上一章介绍的&lt;code&gt;command line&lt;/code&gt;, 这里我们用&lt;code&gt;echo&lt;/code&gt;这个命令加以进一步说明。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; &lt;strong&gt;温习&lt;/strong&gt;&lt;br&gt; 标准的&lt;code&gt;command line&lt;/code&gt;三个组成部分：&lt;code&gt;command_name option argument&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;echo&lt;/code&gt;是一个非常简单、直接的Linux命令：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; argument&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;echo&lt;/code&gt;将argument送出到&lt;code&gt;标准输出&lt;/code&gt;(&lt;code&gt;stdout&lt;/code&gt;),通常是在监视器(monitor)上输出。&lt;/p&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之二  [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E4%BA%8C/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之二/</id>
    <published>2017-04-02T12:49:24.000Z</published>
    <updated>2017-04-02T13:00:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">shell prompt(PS1)与Carriage Return(CR)关系<br></blockquote>


<hr>
<p>当你成功登陆一个shell终端的文字界面之后，大部分的情形下，<br>你会在屏幕上看到一个不断闪烁的方块或者底线(视不同的版本而别)，<br>我们称之为<code>游标</code>(<code>cursor</code>).<br><code>cursor</code>作用就是告诉你接下来你从键盘输入的按键所插入的位置，<br>且每输入一个键，<code>cursor</code>便向右移动一个格子，<br>如果连续输入太多的话，则自动接在下一行输入。</p>
<p>假如你刚完成登陆，还没有输入任何按键之前，<br>你所看到的<code>cursor</code>所在的位置的同一行的左边部分，我们称之为<code>提示符</code>(<code>prompt</code>)。</p>
<a id="more"></a>
<p><code>提示符</code>的格式或因不同的版本而各有不同，<br>在Linux上，只需留意最接近<code>游标</code>的一个提示符号，通常是如下两者之一：</p>
<ul>
<li>$: 给一般用户账号使用;</li>
<li>#: 给root(管理员)账号使用;</li>
</ul>
<p>事实上，shell prompt的意思很简单：<br>告诉shell使用者，您现在可以输入命令行了。</p>
<p>我们可以说，使用者只有在得到shell prompt才能打命令行，<br>而<code>cursor</code>是指示键盘在命令行的输入位置，使用者每输入一个键，<br><code>cursor</code>就往后移动一个格，直到碰到命令行读进<code>CR</code>(<code>Carriage Return</code>, 由<code>Enter</code>键产生)字符为止。<br> <code>CR</code>的意思也很简单：<br>使用者告诉shell：老兄，你可以执行的我命令行了。<br>严格来说：<br>所谓的命令行， 就是在<code>shell prompt</code>与<code>CR</code>之间所输入的文字。</p>
<p>(<strong>question：为何我们这里坚持使用<code>CR</code>字符而不说<code>Enter</code>按键呢？<br>答案在后面的学习中给出</strong>)。</p>
<p>不同的命令可以接受的命令的格式各有不同，<br>一般情况下，一个标准的命令行格式为如下所列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">command-name options argument</div></pre></td></tr></table></figure></p>
<p>若从技术的细节上来看，<br>shell会依据<code>IFS</code>(<code>Internal Field Seperator</code>) 将 command line<br>所输入的文字给拆解为<code>字段</code>(<code>word</code>).<br>然后在针对特殊的字符(meta)先做处理，最后在重组整行command line。</p>
<p>(<strong>注意：请务必理解以上两句的意思，我们日后的学习中常回到这里思考</strong>。)</p>
<p>其中<code>IFS</code>是shell预设使用的字段位分隔符号，可以由一个及多个如下按键组成：</p>
<ul>
<li>空白键(White Space)</li>
<li>表格键(Tab)</li>
<li>回车键(Enter)</li>
</ul>
<p>系统可以接受的命令的名称(command-name)可以从如下途径获得：</p>
<ul>
<li>确定的路径所指定的外部命令</li>
<li>命令的别名(alias)</li>
<li>shell内建命令(built-in)</li>
<li>$PATH之下的外部命令</li>
</ul>
<p>每一个命令行均必须包含命令的名称，这是不能缺少的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;shell prompt(PS1)与Carriage Return(CR)关系&lt;br&gt;&lt;/blockquote&gt;


&lt;hr&gt;
&lt;p&gt;当你成功登陆一个shell终端的文字界面之后，大部分的情形下，&lt;br&gt;你会在屏幕上看到一个不断闪烁的方块或者底线(视不同的版本而别)，&lt;br&gt;我们称之为&lt;code&gt;游标&lt;/code&gt;(&lt;code&gt;cursor&lt;/code&gt;).&lt;br&gt;&lt;code&gt;cursor&lt;/code&gt;作用就是告诉你接下来你从键盘输入的按键所插入的位置，&lt;br&gt;且每输入一个键，&lt;code&gt;cursor&lt;/code&gt;便向右移动一个格子，&lt;br&gt;如果连续输入太多的话，则自动接在下一行输入。&lt;/p&gt;
&lt;p&gt;假如你刚完成登陆，还没有输入任何按键之前，&lt;br&gt;你所看到的&lt;code&gt;cursor&lt;/code&gt;所在的位置的同一行的左边部分，我们称之为&lt;code&gt;提示符&lt;/code&gt;(&lt;code&gt;prompt&lt;/code&gt;)。&lt;/p&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之一  [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E4%B8%80/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之一/</id>
    <published>2017-04-02T12:49:19.000Z</published>
    <updated>2017-04-02T12:58:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">何为shell？<br></blockquote></p>
<hr>
<p> <code>shell</code>是什么东西之前，不妨让我们重新审视<code>使用者</code>和<code>计算机系统</code>的关系：<br>（此处为使用者和计算机系统的关系图）</p>
<p>我们知道计算机的运作不能离开硬件，但使用者却无法直接操作硬件，<br>硬件的驱动只能通过一种称为“<code>操作系统</code>(<code>OS</code>，<code>Opertating System</code>)”的软件来管控。<br>事实上，我们每天所谈的“<code>linux</code>”，严格来说只是一个<code>操作系统</code>(<code>OS</code>),<br>我们称之为“<code>内核</code>(<code>kernel</code>)”。</p>
<p>然而，从使用者的角度来说，使用者没有办法直接操作一个<code>kernel</code>，<br>而是通过<code>kernel</code>的“外壳”程序，也就是所谓的<code>shell</code>，来与<code>kernel</code>沟通。<br>这也正是<code>kernel</code>跟<code>shell</code>的形象命名的的关系。如图：<br> （此处为kernel–&gt;shell关系图；)</p>
<a id="more"></a>
<p>从技术的角度来说，<code>shell</code>是一个使用者与系统的<code>交互界面(interface)</code>,<br>只能让使用者通过<code>命令行</code>(<code>command line</code>)来使用系统来完成工作。<br>因此，<code>shell</code>最简单的定义就是—-<code>命令解释器</code>( <code>Command Interpreter</code>):</p>
<ul>
<li>将使用者的命令翻译给kernel来处理；</li>
<li>同时，将kernel的处理结果翻译给使用者。</li>
</ul>
<p>每次当我们完成<code>系统登入</code>(<code>login</code>), 我们就取得一个交互模式的shell，<br>也称之为<code>login shell</code> 或者 <code>primary shell</code>。</p>
<p>若从<code>进程</code>(<code>process</code>)的角度来说，我们在shell所下达的命令，均是shell所产生的<code>子进程</code>。<br>这种现象，我暂可称之为<code>fork</code>。</p>
<p>如果是执行<code>shell脚本</code>(<code>shell script</code>)的话，脚本中命令则是由另一个非交互模式的<br><code>子shell</code>(<code>sub shell</code>)来执行的。 也就是primary shell产生sub shell的进程，而该sub shell<br>进程再产生script中所有命令的进程。<br> (关于进程，我们日后有机会在补充)</p>
<p>这里， 我们必须知道：<code>kernel</code> 与 <code>shell</code> 是不同的两套软件，而且都是可以被替换的：</p>
<ul>
<li>不同的<code>OS</code>使用不同的<code>kernel</code>;</li>
<li>同一个kernel之上，也可以使用不同的<code>shell</code>;</li>
</ul>
<p>在<code>Linux</code>的预设系统中，通常可以找到好几种不同的<code>shell</code>,<br>且通常会被记录在如下文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/shells</div></pre></td></tr></table></figure></p>
<p>不同的<code>shell</code>有着不同的功能，且彼此各异，或者说“大同小异”。<br>常见的<code>shell</code>主要分为两大主流：</p>
<ol>
<li>sh：<ul>
<li>burne shell (sh)</li>
<li>burne again shell (bash)</li>
</ul>
</li>
<li>csh：<ul>
<li>c shell (csh)</li>
<li>tc shell (tcsh)</li>
<li>korn shell (ksh)<br>(FIXME)</li>
</ul>
</li>
</ol>
<p>大部分的Linux操作系统的预设shell都是<code>bash</code>，其原因大致如下两种：</p>
<ul>
<li>自由软件</li>
<li>功能强大<br>bash是gnu project最成功的产品之一，自推出以来深受广大<code>Unix</code>用户的喜爱，<br>且也逐渐成为不少组织的系统标准。</li>
</ul>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=79938&auto=0&height=66"></iframe>



<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
<!--author：maxie（马驰原）-->
<!--QQ：17045930-->
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;何为shell？&lt;br&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt; &lt;code&gt;shell&lt;/code&gt;是什么东西之前，不妨让我们重新审视&lt;code&gt;使用者&lt;/code&gt;和&lt;code&gt;计算机系统&lt;/code&gt;的关系：&lt;br&gt;（此处为使用者和计算机系统的关系图）&lt;/p&gt;
&lt;p&gt;我们知道计算机的运作不能离开硬件，但使用者却无法直接操作硬件，&lt;br&gt;硬件的驱动只能通过一种称为“&lt;code&gt;操作系统&lt;/code&gt;(&lt;code&gt;OS&lt;/code&gt;，&lt;code&gt;Opertating System&lt;/code&gt;)”的软件来管控。&lt;br&gt;事实上，我们每天所谈的“&lt;code&gt;linux&lt;/code&gt;”，严格来说只是一个&lt;code&gt;操作系统&lt;/code&gt;(&lt;code&gt;OS&lt;/code&gt;),&lt;br&gt;我们称之为“&lt;code&gt;内核&lt;/code&gt;(&lt;code&gt;kernel&lt;/code&gt;)”。&lt;/p&gt;
&lt;p&gt;然而，从使用者的角度来说，使用者没有办法直接操作一个&lt;code&gt;kernel&lt;/code&gt;，&lt;br&gt;而是通过&lt;code&gt;kernel&lt;/code&gt;的“外壳”程序，也就是所谓的&lt;code&gt;shell&lt;/code&gt;，来与&lt;code&gt;kernel&lt;/code&gt;沟通。&lt;br&gt;这也正是&lt;code&gt;kernel&lt;/code&gt;跟&lt;code&gt;shell&lt;/code&gt;的形象命名的的关系。如图：&lt;br&gt; （此处为kernel–&amp;gt;shell关系图；)&lt;/p&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>开源堡垒机JumpServer的安装</title>
    <link href="http://yoursite.com/2017/04/02/%E5%BC%80%E6%BA%90%E5%A0%A1%E5%9E%92%E6%9C%BAJumpServer%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2017/04/02/开源堡垒机JumpServer的安装/</id>
    <published>2017-04-02T10:09:53.000Z</published>
    <updated>2017-04-02T12:24:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">完全开源、极致省力、界面美观、功能完整<br><br>    –JumpServer的特性<br></blockquote>

<p>Jumpserver Jumpserver 是一款由python编写开源的跳板机(堡垒机)系统，实现了跳板机应有的功能。基于ssh协议来管理，客户端无需安装agent。</p>
<!-- 标签 方式，要求版本在0.4.5或以上 -->
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jumpserver.jpg" class="full-image" alt="jumpserver"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<a id="more"></a>
<p><strong>支持常见系统:</strong></p>
<ol>
<li>CentOS, RedHat, Fedora, Amazon Linux</li>
<li>Debian</li>
<li>SUSE, Ubuntu</li>
<li>FreeBSD</li>
<li>其他ssh协议硬件设备</li>
</ol>
<h3 id="安装JumpServer"><a href="#安装JumpServer" class="headerlink" title="安装JumpServer"></a>安装JumpServer</h3><div class="note primary"><p>安装的环境为CentOS7</p>
</div>
<p> 此次具体安装过程如下：</p>
<h4 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1.安装依赖"></a>1.安装依赖</h4><p><code>yum install -y git</code></p>
<p><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fe8k1n4x18j313i08q0u5.jpg" alt=""></p>
<h4 id="2-下载JumpSerer"><a href="#2-下载JumpSerer" class="headerlink" title="2.下载JumpSerer"></a>2.下载JumpSerer</h4><p>注意安装时当前所在的工作目录，不要在/root目录下安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /opt</div><div class="line">git <span class="built_in">clone</span> https://github.com/jumpserver/jumpserver.git</div></pre></td></tr></table></figure>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fe8kadz13vj313i05w40f.jpg" alt=""></p>
<h4 id="3-开始安装JumpServer"><a href="#3-开始安装JumpServer" class="headerlink" title="3.开始安装JumpServer"></a>3.开始安装JumpServer</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> jumpserver/install/</div><div class="line">./install.py</div></pre></td></tr></table></figure>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fe8kd37km2j313k0eiad1.jpg" alt=""><br><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fe8kew6owij313i07cju1.jpg" alt=""><br>这里如果之前安装过MySQL就无需再安装了。<br>jumpserver自动配置的数据库，用户名是：jumpserver；密码是5Lov@wife<br><img src="https://ww2.sinaimg.cn/large/006tNbRwly1fe8khw9eadj313k06c75y.jpg" alt=""><br>这里是为之后管理员创建普通用户，在创建时直接给用户的邮箱发送账号和密码。<br><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fe8knu8cxhj313i04s0t9.jpg" alt=""><br><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fe8kpsafusj313i05ct93.jpg" alt=""><br>这里为管理员设置密码，接下来就是登陆ip看看我们的jumpserver是否运行正常！<br><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fe8kr4o3b0j313i07owfx.jpg" alt=""></p>
<h3 id="验证JumpServer"><a href="#验证JumpServer" class="headerlink" title="验证JumpServer"></a>验证JumpServer</h3><p>浏览器输入 123.56.100.148:8000<br>就可以查看我们搭建的jumpserver是否成功了！</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fe8kyg57apj31hc0uuq4i.jpg" alt=""></p>
<p><strong>果真搭起来了，让我们输入密码进入吧</strong></p>
<p><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fe8kyzcmyfj31hc0uun31.jpg" alt=""></p>
<p><strong>这里的主机是我搭起来之后添加的。。 :)</strong></p>
<p><em>至此，Centos7搭建JumpServer开源堡垒机的教程就完啦！</em></p>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=79938&auto=0&height=66"></iframe>


<p>本文出自<a href="http://maxiecloud.com" target="_blank" rel="external">Maxie’s Notes</a>博客，转载请务必保留此出处。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
<!--author：maxie（马驰原）-->
<!--QQ：17045930-->
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;完全开源、极致省力、界面美观、功能完整&lt;br&gt;&lt;br&gt;    –JumpServer的特性&lt;br&gt;&lt;/blockquote&gt;

&lt;p&gt;Jumpserver Jumpserver 是一款由python编写开源的跳板机(堡垒机)系统，实现了跳板机应有的功能。基于ssh协议来管理，客户端无需安装agent。&lt;/p&gt;
&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;
&lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;/images/jumpserver.jpg&quot; class=&quot;full-image&quot; alt=&quot;jumpserver&quot; /&gt;&lt;meta itemprop=&quot;width&quot; content=&quot;auto&quot;&gt;&lt;meta itemprop=&quot;height&quot; content=&quot;auto&quot;&gt;&lt;/span&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="堡垒机" scheme="http://yoursite.com/tags/%E5%A0%A1%E5%9E%92%E6%9C%BA/"/>
    
      <category term="开源" scheme="http://yoursite.com/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="jumpserver" scheme="http://yoursite.com/tags/jumpserver/"/>
    
  </entry>
  
  <entry>
    <title>Linux用户和用户组管理</title>
    <link href="http://yoursite.com/2017/03/30/Linux%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2017/03/30/Linux用户和用户组管理/</id>
    <published>2017-03-30T11:02:48.000Z</published>
    <updated>2017-03-31T12:39:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">共产主义是一种伪科学, 演变成一种伪宗教, 最终表现为僵化的集权式的邪恶政治集团!<br><br>Richard Pipes (《共产主义实录》作者)</blockquote>


<blockquote>
<p>Linux系统是一个多用户、多任务的操作系统<br>任何一个要想使用系统内部资源的用户，必须首先向Linux系统管理员申请一个账号，然后以这个用户的身份登录到系统中。这个账号一方面可以帮助系统管理员对使用系统的用户进行管理，并限制他们对系统资源的访问；另一方面也可以为用户提供安全性保护。每个用户账号都拥有一个惟一的用户名和各自的口令。用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。 </p>
</blockquote>
<h4 id="Linux下用户的角色分类"><a href="#Linux下用户的角色分类" class="headerlink" title="Linux下用户的角色分类"></a>Linux下用户的角色分类</h4><p>Linux下用户是根据角色定义的，具体分为三种角色：</p>
<ol>
<li>管理员：默认为<strong>root</strong>用户（<strong>UID=0</strong>），拥有对操作系统最高管理权限（甚至可以kill itself）</li>
<li>普通用户：只能对自己目录下的文件进行访问和修改，具有登陆系统的权限。</li>
<li>系统用户（<strong>伪用户</strong>）：这类用户的特点是不能登录操作系统，他们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</li>
</ol>
<h4 id="用户和组的关系"><a href="#用户和组的关系" class="headerlink" title="用户和组的关系"></a>用户和组的关系</h4><p>用户和用户组的<strong>对应关系</strong>有：一对一、一对多、多对一和多对多。<br>下图展示了这种关系：</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fe53jbpg39j30br066q3o.jpg" alt=""></p>
<a id="more"></a>
<p>  <strong>一对一</strong>：即一个用户可以存在一个组中，也可以是组中的唯一成员。<br>  <strong>一对多</strong>：即一个用户可以存在多个用户组中。那么此用户具有多个组的共同权限。<br>  <strong>多对一</strong>：多个用户可以存在一个组中，这些用户具有和组相同的权限。<br>  <strong>多对多</strong>：多个用户可以存在多个组中。其实就是上面三个对应关系的扩展。</p>
<hr>
<h4 id="用户组的概念"><a href="#用户组的概念" class="headerlink" title="用户组的概念"></a>用户组的概念</h4><p><strong>用户组</strong>是具有相同特征用户的逻辑集合，有时我们需要让很多个用户具有相同的权限，比如查看、修改、删除一个目录下的文件。一种方法是分别对每个用户进行权限的授权，如果用户数特别多的话，这样显然不符合我们省事的宗旨；另一种方法就是建立一个小组，把这些需要拥有权限的用户们加到这个组中，然后让这个组具有对这个目录下的文件，查看、修改、删除的权限，这样组内用户都具有了和组一样的权限。</p>
<p>这就是用户组，将用户分组是Linux系统中对用户进行管理及控制访问权限。</p>
<hr>
<h4 id="安全上下文的概念"><a href="#安全上下文的概念" class="headerlink" title="安全上下文的概念"></a>安全上下文的概念</h4><p>我们都知道<strong>程序=指令+数据</strong></p>
<p>在Linux运行中的程序是以<strong>进程</strong>（process）的方式存在的。</p>
<p>进程是应用的实际载体，是系统资源分配和调度的基本单位。</p>
<p>Linux中每个进程都会由发起者，而这个进程能够做的事情，取决去发起进程的发起者的权限。</p>
<hr>
<h4 id="用户和用户组的主要配置文件"><a href="#用户和用户组的主要配置文件" class="headerlink" title="用户和用户组的主要配置文件"></a>用户和用户组的主要配置文件</h4><table>
<thead>
<tr>
<th>配置文件位置</th>
<th>存储的信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>/etc/passwd</td>
<td>用户及其属性信息</td>
</tr>
<tr>
<td>/etc/group</td>
<td>用户组及其属性信息</td>
</tr>
<tr>
<td>/etc/shadow</td>
<td>用户和其对应的密码及其相关属性</td>
</tr>
<tr>
<td>/etc/gshadow</td>
<td>用户组密码及其相关属性</td>
</tr>
</tbody>
</table>
<h5 id="系统用户配置文件-etc-passwd"><a href="#系统用户配置文件-etc-passwd" class="headerlink" title="系统用户配置文件(/etc/passwd)"></a>系统用户配置文件(/etc/passwd)</h5><p>此文件是Linux用户管理中最重要的一个文件。这个文件记录了Linux系统中每个用户的一些基本属性，并且对所有用户可读。</p>
<p>文件内每一行记录对应一个用户，其格式和具体含义具体如下：</p>
<blockquote>
<p>用户名:密码占位符:UID:GID:注释信息:用户家目录:用户默认shell</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># head /etc/passwd</span></div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">bin:x:1:1:bin:/bin:/sbin/nologin</div><div class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</div><div class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</div><div class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</div></pre></td></tr></table></figure>
<p><strong>passwd文件每个字段的详细含义</strong></p>
<p><strong>用户名</strong>：用户账号的字符串。</p>
<p><strong>密码占位符</strong>：这个位置在之前是存放着用户的密码，但是由于考虑每个用户都能访问，这样对于系统的安全性是不安全的。所以现在许多Linux版本都使用了shadow技术，把真正加密后的用户口令存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如用“x”或者“*”来表示。 </p>
<p><strong>用户标识号</strong>：用户的UID，每个用户都有一个UID，并且是唯一的，通常UID号的取值范围是0～65535，<strong>0是超级用户root的标识号</strong>。而在Linux系统中，普通用户UID默认从<strong>500</strong>开始，<strong>**开始是从</strong>1000**开始。UID是Linux下确认用户权限的标志，用户的角色和权限都是通过UID来实现的，因此多个用户公用一个UID是非常危险的，会造成系统权限和管理的混乱，例如将普通用户的UID设置为0后，这个普通用户就具有了root用户的权限，这是极度危险的操作。因此要尽量保持用户UID的唯一性。</p>
<p><strong>组标识号</strong>：组的GID，与用户的UID类似，这个字段记录了用户所属的用户组。它对应着/etc/group文件中的一条记录。</p>
<p><strong>注释性描述</strong>：字段是对用户的描述信息，比如用户的email，住址。</p>
<p><strong>家目录</strong>：也就是用户登录到系统之后默认所处的目录，也可以叫做用户的主目录、家目录、根目录等等。</p>
<p><strong>默认shell</strong>：就是用户登录系统后默认使用的命令解释器，shell是用户和linux内核之间的接口，用户所作的任何操作，都是通过shell传递给系统内核的。linux下常用的shell有sh、bash、csh、zsh等，管理员可以根据用户的习惯，为每个用户设置不同的shell。</p>
<hr>
<h5 id="用户影子文件-etc-shadow"><a href="#用户影子文件-etc-shadow" class="headerlink" title="用户影子文件(/etc/shadow)"></a>用户影子文件(/etc/shadow)</h5><p>用户影子文件，由于/etc/passwd文件是所有用户都可读的，这样会导致用户的密码容易泄露。因此Linux将密码信息从/etc/passwd中分离出来。单独的放到了一个文件中，这个文件就是/etc/shadow，该文件只有root用户拥有读权限，从而保证了用户密码的安全性。</p>
<p><strong>/etc/shadow文件内容的格式：</strong></p>
<blockquote>
<p>用户名:加密口令:最近一次修改密码的时间:密码最短使用期限:密码最长使用时间:警告时间:密码过期时间:保留字段</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># head /etc/shadow</span></div><div class="line">root:<span class="variable">$6</span><span class="variable">$VmyBrA3R5Q</span>.fFp/:17246:0:99999:7:::</div><div class="line">bin:*:16659:0:99999:7:::</div></pre></td></tr></table></figure>
<hr>
<h5 id="用户组配置文件-etc-group"><a href="#用户组配置文件-etc-group" class="headerlink" title="用户组配置文件(/etc/group)"></a>用户组配置文件(/etc/group)</h5><p>用户组配置文件，用户组的所有信息都存放在此文件中</p>
<p><strong>/etc/group文件内容的格式：</strong></p>
<blockquote>
<p>组名:口令:组标识号:组内用户列表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># head /etc/group</span></div><div class="line">root:x:0:</div><div class="line">bin:x:1:</div></pre></td></tr></table></figure>
<h5 id="创建用户时默认配置文件（-etc-login-defs"><a href="#创建用户时默认配置文件（-etc-login-defs" class="headerlink" title="创建用户时默认配置文件（/etc/login.defs)"></a>创建用户时默认配置文件（/etc/login.defs)</h5><p>下面是Centos的/etc/login.defs文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">CentOS版本信息：</div><div class="line"></div><div class="line">LSB Version:    :core-4.1-amd64:core-4.1-noarch</div><div class="line">Distributor ID: CentOS</div><div class="line">Description:    CentOS Linux release 7.2.1511 (Core)</div><div class="line">Release:        7.2.1511</div><div class="line">Codename:       Core</div><div class="line"></div><div class="line">配置文件：</div><div class="line"></div><div class="line">MAIL_DIR        /var/spool/mail  <span class="comment">#当创建用户时，同时在/var/spool/mail中创建一个用户mail文件</span></div><div class="line">PASS_MAX_DAYS   99999 <span class="comment">#指定密码保持有效最大天数</span></div><div class="line">PASS_MIN_DAYS   0   <span class="comment">#表示自从上次修改密码以来多少天后用户才被允许修改密码 </span></div><div class="line">PASS_MIN_LEN    5   <span class="comment">#指定密码最小长度</span></div><div class="line">PASS_WARN_AGE   7   <span class="comment">#密码到期前多少天系统警告用户密码即将到期</span></div><div class="line"></div><div class="line">UID_MIN                  1000   <span class="comment">#UID最小为1000</span></div><div class="line">UID_MAX                 60000   <span class="comment">#最大UID为60000</span></div><div class="line"></div><div class="line">SYS_UID_MIN               201   <span class="comment">#系统用户UID最小为201</span></div><div class="line">SYS_UID_MAX               999   <span class="comment">#系统用户UID最大为999</span></div><div class="line"></div><div class="line">CREATE_HOME     yes     <span class="comment">#是否创建用户主目录</span></div><div class="line"></div><div class="line">UMASK           077     <span class="comment">#系统的UMASK码</span></div><div class="line"></div><div class="line">USERGROUPS_ENAB yes     <span class="comment">#是否为用户创建与之同名的用户组</span></div><div class="line"></div><div class="line">ENCRYPT_METHOD SHA512   <span class="comment">#系统加密算法</span></div></pre></td></tr></table></figure>
<h5 id="主目录配置文件-etc-skel目录下）"><a href="#主目录配置文件-etc-skel目录下）" class="headerlink" title="主目录配置文件(/etc/skel目录下）"></a>主目录配置文件(/etc/skel目录下）</h5><p>在创建一个新用户后，会在新用户的主目录下看到类似.bash_profile, .bashrc, .bash_logout等文件，这些文件是怎么来的呢，如果我想让新建立的用户在主目录下默认拥有自己指定的配置文件，该如何设置呢？<br>/etc/skel目录就是解决这个问题的，/etc/skel目录定义了新建用户在主目录下默认的配置文件，更改/etc/skel目录下的内容就可以改变新建用户默认主目录的配置文件信息。</p>
<hr>
<h4 id="用户和组管理命令"><a href="#用户和组管理命令" class="headerlink" title="用户和组管理命令"></a>用户和组管理命令</h4><h5 id="用户管理命令："><a href="#用户管理命令：" class="headerlink" title="用户管理命令："></a>用户管理命令：</h5><p><strong>添加新的账号使用useradd命令</strong></p>
<p>其语法如下：</p>
<blockquote>
<p>  useradd [OPTIONS] LOGIN<br>  useradd    选项   用户名</p>
</blockquote>
<p>其中各选项以及含义如下：</p>
<pre><code>-u UID：指定用户的UID
-o：不检查UID的唯一性
-g GID：指定GID，也可以使用组名来指定
-c COMMENT：指定用户的注释信息
-d HOME_DIR：以指定的路径为用户的家目录，默认在/home下创建
-s SHELL：指明用户使用的shell
-G GROUP1[,GROUP2,…]：为用户指明附加组，组需实现存在
-r：创建系统用户
-M：不创建用户的家目录
-m：默认选项，创建用户的家目录
</code></pre><p>实例1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># useradd -d /usr/maxie -s /bin/csh maxie</div></pre></td></tr></table></figure>
<p>此命令创建了一个用户<code>maxie</code>，其中<code>-d</code>选项为用户指定其家目录位置，<code>-s</code>选项指定用户使用的默认shell为csh。</p>
<p>实例2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># useradd -u 1006 -g insieme -G root,maxie cloud</div></pre></td></tr></table></figure>
<p>此命令创建了一个用户<code>cloud</code>，其中<code>-u</code>选项是指定用户的UID，<code>-g</code>选项指定用户的主组为insime，<code>-G</code>选项为用户指明其附加组</p>
<p><strong>修改用户属性使用usermod命令</strong></p>
<p>使用usermod命令可以修改账号的相关属性，比如：用户UID、家目录、用户主组、登录shell登录shell等等。</p>
<p>其语法如下：</p>
<blockquote>
<p>usermod [OPTIONS] LOGIN<br>usermod  选项     用户名</p>
</blockquote>
<p>其中各选项以及含义如下：</p>
<pre><code>-c&lt;备注&gt;：修改用户帐号的备注文字； 
-d&lt;登入目录&gt;：修改用户的家目录； 
-e&lt;有效期限&gt;：修改帐号的有效期限； 
-f&lt;缓冲天数&gt;：修改在密码过期后多少天即关闭该帐号； 
-g&lt;群组&gt;：修改用户所属的群组； 
-G&lt;群组&gt;：修改用户所属的附加群组； 
-l&lt;帐号名称&gt;：修改用户帐号名称； 
-L：锁定用户密码，使密码无效；直接修改/etc/shaodw文件，在密码前加!号即可
-s：修改用户登入后所使用的shell； 
-u：修改用户ID； 
-U：解除密码锁定。
</code></pre><p>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># usermod -s /bin/zsh -l maxiecloud -g cloud maxie</div></pre></td></tr></table></figure>
<p>此命令将用户<code>maxie</code>的登录shell改为zsh，用户名改为maxiecloud，主组改为cloud组。</p>
<p><strong>删除用户使用userdel命令</strong></p>
<p>如果一个账号不再使用，可以从系统中删除，必要时还要删除用户的家目录。</p>
<p>其语法格式如下：</p>
<blockquote>
<p>userdel [OPTIONS] LOGIN<br>userdel 选项      用户名</p>
</blockquote>
<p>常用选项：</p>
<p>-r：删除用户的同时，删除用户的家目录</p>
<p>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># userdel -r maxiecloud</div></pre></td></tr></table></figure>
<p>此命令删除了<code>maxiecloud</code>用户以及其家目录。</p>
<p><strong>修改用户密码使用passwd命令</strong></p>
<p>用户账号刚创建时没有密码，但是被系统锁定，无法使用，必须为其制定密码后才能登陆系统。</p>
<p>其语法格式如下：</p>
<blockquote>
<p>passwd [OPTIONS] LOGIN<br>passwd 选项       用户名</p>
</blockquote>
<p>其中各选项以及含义如下：</p>
<pre><code>--stdin：从标准输入接收用户密码
-l:锁定指定用户
-u:解锁指定用户
-e:强制用户下次登录修改密码
-n mindays: 指定最短使用期限
-x maxdays： 最大使用期限
-w warndays： 提前多少天开始警告
-i inactivedays： 非活动期限
-d：使账户无口令（密码）
</code></pre><p>实例1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># passwd cloud</div><div class="line">New password:******* </div><div class="line">Re-enter new password:*******</div></pre></td></tr></table></figure>
<p>此命令为<code>cloud</code>用户修改密码。</p>
<p>密码设定策略：</p>
<pre><code>1. 使用数字、大写字母、字符、数字、特殊符号组合
2. 足够长（大于8位）
3. 使用随机密码
4. 定期更换（生产环境：平均2个月修改一次）
</code></pre><p>实例2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># passwd -d cloud</div></pre></td></tr></table></figure>
<p>此命令为<code>cloud</code>用户指定空口令，下次cloud用户登录时，系统不再询问口令。</p>
<h5 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h5><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<p><strong>增加一个新的用户组使用groupadd命令</strong></p>
<p>其语法如下：</p>
<blockquote>
<p>groupadd [OPTIONS] GROUP<br>groupadd 选项       用户组</p>
</blockquote>
<p>其中各选项以及含义如下：</p>
<pre><code>-g GID 指定新用户组的组标识号（GID）。
-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。
</code></pre><p>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># groupadd maxie</div></pre></td></tr></table></figure>
<p>此命令向系统添加了一个新组maxie，新组的GID是在当前已有的最大GID号的基础上加1</p>
<p><strong>删除一个已有的用户组使用groupdel命令</strong></p>
<p>其语法如下：</p>
<blockquote>
<p>groupdel [OPTIONS] GROUP<br>groupdel 选项       用户组</p>
</blockquote>
<p>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># groupdel maxie</div></pre></td></tr></table></figure>
<p>此命令从系统中删除组<code>maxie</code></p>
<p><strong>修改用户组的属性使用groupmod命令</strong></p>
<p>其语法如下：</p>
<blockquote>
<p>groupmod [OPTIONS] GROUP<br>groupmod 选项       用户组</p>
</blockquote>
<p>其中各选项以及含义如下：</p>
<pre><code>-g GID 为用户组指定新的组标识号。
-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。
-n新用户组 将用户组的名字改为新名字
</code></pre><p>实例1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># groupmod -g 102 maxie</div></pre></td></tr></table></figure>
<p>此命令将组<code>maxie</code>的GID改为102</p>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=37653063&auto=0&height=66"></iframe>

<p>本文出自<a href="http://maxiecloud.com" target="_blank" rel="external">Maxie’s Notes</a>博客，转载请务必保留此出处。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
<!--author：maxie（马驰原）-->
<!--QQ：17045930-->
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;共产主义是一种伪科学, 演变成一种伪宗教, 最终表现为僵化的集权式的邪恶政治集团!&lt;br&gt;&lt;br&gt;Richard Pipes (《共产主义实录》作者)&lt;/blockquote&gt;


&lt;blockquote&gt;
&lt;p&gt;Linux系统是一个多用户、多任务的操作系统&lt;br&gt;任何一个要想使用系统内部资源的用户，必须首先向Linux系统管理员申请一个账号，然后以这个用户的身份登录到系统中。这个账号一方面可以帮助系统管理员对使用系统的用户进行管理，并限制他们对系统资源的访问；另一方面也可以为用户提供安全性保护。每个用户账号都拥有一个惟一的用户名和各自的口令。用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;Linux下用户的角色分类&quot;&gt;&lt;a href=&quot;#Linux下用户的角色分类&quot; class=&quot;headerlink&quot; title=&quot;Linux下用户的角色分类&quot;&gt;&lt;/a&gt;Linux下用户的角色分类&lt;/h4&gt;&lt;p&gt;Linux下用户是根据角色定义的，具体分为三种角色：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;管理员：默认为&lt;strong&gt;root&lt;/strong&gt;用户（&lt;strong&gt;UID=0&lt;/strong&gt;），拥有对操作系统最高管理权限（甚至可以kill itself）&lt;/li&gt;
&lt;li&gt;普通用户：只能对自己目录下的文件进行访问和修改，具有登陆系统的权限。&lt;/li&gt;
&lt;li&gt;系统用户（&lt;strong&gt;伪用户&lt;/strong&gt;）：这类用户的特点是不能登录操作系统，他们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;用户和组的关系&quot;&gt;&lt;a href=&quot;#用户和组的关系&quot; class=&quot;headerlink&quot; title=&quot;用户和组的关系&quot;&gt;&lt;/a&gt;用户和组的关系&lt;/h4&gt;&lt;p&gt;用户和用户组的&lt;strong&gt;对应关系&lt;/strong&gt;有：一对一、一对多、多对一和多对多。&lt;br&gt;下图展示了这种关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/006tNbRwly1fe53jbpg39j30br066q3o.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux基础知识" scheme="http://yoursite.com/categories/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="user" scheme="http://yoursite.com/tags/user/"/>
    
      <category term="command" scheme="http://yoursite.com/tags/command/"/>
    
  </entry>
  
</feed>
