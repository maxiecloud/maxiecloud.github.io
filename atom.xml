<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Maxie&#39;s Notes</title>
  <subtitle>Stay hungry , Stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-04-12T13:49:39.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>阿蓝</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux各概念图解</title>
    <link href="http://yoursite.com/2020/04/09/mind-mapping/"/>
    <id>http://yoursite.com/2020/04/09/mind-mapping/</id>
    <published>2020-04-09T09:47:17.000Z</published>
    <updated>2017-04-12T13:49:39.000Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="https://ww3.sinaimg.cn/large/006tNbRwly1feglz4cq9nj31kw16ou10.jpg" alt=""></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fegm48jil8j31kw0zknpd.jpg" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fegm4a9911j31kw0zkhdt.jpg" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fegm4c6wqzj31kw0zk1ky.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="图片" scheme="http://yoursite.com/categories/%E5%9B%BE%E7%89%87/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="picture" scheme="http://yoursite.com/tags/picture/"/>
    
  </entry>
  
  <entry>
    <title>DNS 和 Bind 配置指南</title>
    <link href="http://yoursite.com/2017/05/23/dns-and-bind/"/>
    <id>http://yoursite.com/2017/05/23/dns-and-bind/</id>
    <published>2017-05-23T11:30:02.000Z</published>
    <updated>2017-05-26T12:17:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">网域名称系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。<br>它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。<br>DNS使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。<br></blockquote>

<p>DNS最早于1983年由保罗·莫卡派乔斯（Paul Mockapetris）发明；原始的技术规范在882号因特网标准草案（RFC 882）中发布。1987年发布的第1034和1035号草案修正了DNS技术规范，并废除了之前的第882和883号草案。在此之后对因特网标准草案的修改基本上没有涉及到DNS技术规范部分的改动。</p>
<p>早期的域名必须以英文句号“.”结尾，当用户访问<code>www.maxiecloud.com</code>的HTTP服务时必须在地址栏中输入：<code>http://www.maxiecloud.com.</code>，这样DNS才能够进行域名解析。如今DNS服务器已经可以自动补上结尾的句号。</p>
<p><img src="http://www.neustar.biz/blog/dns-cloud.jpg" alt=""></p>
<a id="more"></a>
<div class="note primary"><h3 id="DNS基础知识"><a href="#DNS基础知识" class="headerlink" title="DNS基础知识"></a>DNS基础知识</h3></div>
<h4 id="DNS-Domain-Name-Service-域名解析服务"><a href="#DNS-Domain-Name-Service-域名解析服务" class="headerlink" title="DNS:Domain Name Service 域名解析服务"></a>DNS:Domain Name Service 域名解析服务</h4><p>DNS服务是一个基于C/S架构的协议，在传输层的TCP和UDP协议的53号端口上运行。</p>
<p><strong>TCP协议：</strong> Transmission Control Protocol<br>    TCP是面向连接的协议：双方通信之前需要事先建立虚拟连接；</p>
<p><strong>UDP协议：</strong> User Datagram Protocol<br>    UDP是无连接的协议：双方通信之前无需建立虚拟连接；</p>
<p><strong>简单的来说：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DNS就像是一个通讯录，Maxie的电话是11503496****，有了通讯录，我们只需通过输入Maxie这个名字就能够自动拨打其电话。</div><div class="line">DNS主要是用来定义IP地址和域名的关系。</div></pre></td></tr></table></figure>
<hr>
<h4 id="域名空间"><a href="#域名空间" class="headerlink" title="域名空间"></a>域名空间</h4><p>域名系统作为一个层次结构和分布式数据库，包含各种类型的数据，包括主机名和域名。DNS数据库中的名称形成一个分层树状结构称为域命名空间。域名包含单个标签分隔点，例如：blog.maxiecloud.com</p>
<p>对于Internet来说，域名层次结构的顶级由ICANN（互联网名称与数字地址分配机构）负责管理。目前，已经有超过250个顶级域名，每个顶级域名可以进一步划为一些子域（二级域名），这些子域可被再次划分（三级域名），依此类推。所有这些域名可以组织成一棵树，如下图所示：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1ffwayyiokhj31e00l8jsb.jpg" alt=""></p>
<hr>
<h4 id="域名资源记录"><a href="#域名资源记录" class="headerlink" title="域名资源记录"></a>域名资源记录</h4><p>DNS设计之初是用来建立域名到IP地址的映射，理论上对于每一个域名我们只需要在域名服务器上保存一条记录即可。这里的记录一般叫作域名资源记录，它是一个五元组，可以用以下格式表示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Domain_name Time_to_live Class Type Value </div><div class="line"></div><div class="line">Domain_name     指出这条记录对应的域名</div><div class="line">Time_to_live    表明记录的生存周期，即缓存时长</div><div class="line">Class           一般总是IN</div><div class="line">Type            记录的类型</div><div class="line">Value           记录值，如果是A记录，则value是一个IPv4地址</div></pre></td></tr></table></figure>
<p>其中，常见的记录类型TYPE包括：</p>
<table>
<thead>
<tr>
<th>记录类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>SOA：（StartOf Authority,起始授权记录）</td>
<td>一个区域解析库有且只能有一个SOA记录，而且必须放在第一条</td>
</tr>
<tr>
<td>A记录（Address，主机记录）</td>
<td>用于名称解析的重要记录，将特定的主机名映射到对应主机的IP地址上</td>
</tr>
<tr>
<td>CNAME记录（Canonical Name，别名记录）</td>
<td>用于 返回另一个域名，即当前查询的域名是另一个域名的跳转，主要用于域名的内部跳转，为服务器配置提供灵活性</td>
</tr>
<tr>
<td>NS记录（Name Service，域名服务器记录）</td>
<td>用于返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址</td>
</tr>
<tr>
<td>PTR记录（Pointer，指针记录）</td>
<td>PTR记录是A记录的逆向记录，又称做IP反查记录或指针记录，负责将IP反向解析为域名</td>
</tr>
<tr>
<td>MX（Mall eXchanger，邮件记录）</td>
<td>用于返回接收电子邮件的服务器地址</td>
</tr>
<tr>
<td>IPv6主机记录（AAAA记录）</td>
<td>与A记录对应，用于将特定的主机名映射到一个主机的IPv6地址。</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h4><p>域名服务器用于响应DNS查询，由不同层级的域名服务器协同完成。下面讲解下如何将所有的域名资源记录存储到不同的域名服务器上。前面说过域名空间可以组织为一棵树，这里我们可以进一步将其划分为不重叠的区域（DNS zone），针对上图的域名空间，一种可能的域名划分如下图：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1ffweybz1snj31cu0lg0ug.jpg" alt=""></p>
<p>然后将每个区域的域名服务器（当然每个DNS zone内应该是由集群组成，包括master，和slave服务器用来提供数据备份、加快解析速度、保证服务可用性）关联起来，称这些域名服务器为该区域的<strong>权威域名服务器(Authoritative Name Servers )</strong>，它保存两类域名资源记录：</p>
<ol>
<li>该区域内所有域名的域名资源记录。</li>
<li>父区域和子区域的域名服务器对应的域名资源记录（主要是NS记录）。</li>
</ol>
<p>这样，所有的域名资源记录都保存在多个域名服务器中，并且所有的域名服务器也组成了一个层次的索引结构，便于域名解析。下面以一个简化的域名空间为例子，说明域名资源记录是如何保存在域名服务器中的，如下图：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1ffwf0iskulj30r80iqdh8.jpg" alt=""></p>
<p>图中域名空间划分为A, B, C, D, E, F, G七个DNS区域，每个DNS区域都有多个权威域名服务器（作为一个集群），这些域名服务器里面保存了许多域名解析记录。对于上图的DNS区域E来说，它的权威域名服务器里面保存的记录如图中表格所示。</p>
<p>仔细观察上图会发现区域A、B并没有父区域，他们之间并没有一条路径连在一起。这将导致一个很麻烦的问题，那就是区域A的权威域名服务器可能根本不知道区域B的存在。认识到这一点后，可能会想到的一个很自然的解决方案，就是在A中记录B域名服务器的地址，同时在B中记录A的，这样它们两个就联系起来了。但是考虑到有超过250个顶级域名，这样做并不是很恰当。</p>
<p>域名系统则采用了一种更加聪明的方法，那就是引入根域名服务器，它保存了所有顶级区域的权威域名服务器记录。现在通过根域名服务器，我们可以找到所有的顶级区域的权威域名服务器，然后就可以往下一级一级找下去了。根域名服务器（root   name  server）是DNS中最高级别的域名服务器，负责返回顶级域名的权威域名服务器的地址，全球13组根域名服务器以英文字母A到M依序命名，网域名称格式为“字母.root-servers.net”。其中有11个是以任播技术在全球多个地点设立镜像站。。更多关于根域名服务器的内容，可以参考：<a href="https://zh.wikipedia.org/wiki/%E6%A0%B9%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8B%99%E5%99%A8" target="_blank" rel="external">根域名服务器-维基百科</a></p>
<p>现在为止，域名服务器和根域名服务器其实组成了一个树，树根为根域名服务器，下面每个节点都是一个区域的权威域名服务器，对于上图中各个DNS区域的权威域名服务器，它们组成了下面这棵树（事实上，一个权威域名服务器可能保存有多个DNS区域的记录，因此权威域名服务器之间的联系并不构成一棵树。为了容易理解，将其简化为一棵树）：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1ffwf456xoxj30d60g3dg6.jpg" alt=""></p>
<hr>
<h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><p>Local DNS（本地域名服务器）：本地由网络服务提供商（ISP）分配的DNS（一般为两个），或自行设置的公共DNS。</p>
<p>当需要查询一个域名对应的IP地址时，在检查完本地hosts文件、操作系统DNS缓存后，会向本地域名服务器(LDNS)发起请求，如果该域名恰好在Local  DNS所辖属的域名区域（DNS zone）内，那么可以直接返回记录。</p>
<p>如果LDNS没有发现该域名的资源记录，就需要在整个域名空间搜索该域名。而整个域名空间的资源记录存储在一个分层的、树状联系的一系列域名服务器上，所以本地域名服务器首先要从根域名服务器开始往下搜索。这里有一个问题就是本地域名服务器如何找到根域名服务器在哪里呢？其实域名服务器启动的时候，就会加载一个配置文件，里面保存了根域名服务器的NS记录（因为根域名服务器地址一般非常稳定，不会轻易改变，并且数量很少，所以这样配置文件会很小）。找到根域名服务器之后，就可以一级一级地往下查找。</p>
<p><strong>假设访问www.google.com ，则请求过程大致如下：</strong></p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1ffwf5z5eykj30n20csab6.jpg" alt=""></p>
<ol>
<li><p>在浏览器中输入www.google.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</p>
</li>
<li><p>如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p>
</li>
<li><p>如果hosts与本地操作系统缓存都没有相应的网址映射关系，则向本地设置的Local DNS服务器发起域名解析请求。LDNS收到查询后，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p>
</li>
<li><p>如果要查询的域名，不由Local DNS服务器区域解析，但该服务器已缓存了此网址映射关系，且缓存未过期，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</p>
</li>
<li><p>如果该域名不在Local DNS所辖属的域名区域（DNS zone）内，且没有有效缓存，则根据Local   DNS的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的NS地址及其对应IP。本地DNS服务器收到IP信息后，将会请求.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，便将.com域的下一级DNS服务器地址(qq.com)给的NS地址及其IP响应给Local   DNS。当Local DNS收到这个地址后，再向qq.com域服务器，重复上面查询，直至找到www.qq.com主机对应的记录。</p>
</li>
<li><p>如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，则请求根DNS或把转请求转至上上级，以此循环。不管是Local   DNS用的是转发，还是向根DNS请求，最终都能获得查询结果，然后再返回给最初查询的客户端。</p>
</li>
</ol>
<hr>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>由于绝大部分的DNS请求都集中在少部分的域名。因此可以将已经访问过域名的解析结果缓存在本地，下次访问的时候可以直接读取结果，不用再次重复DNS查询过程，客户端和域名服务器都节省了麻烦。</p>
<p>当然，这样做的一个前提是要缓存的解析结果不能频繁更改。绝大多数的域名解析确实是这样基本固定不变的。但是难免有一些“善变”的域名，他们可能会频繁更改自己的解析结果。为了使缓存机制适应这两类情况，在域名资源记录里面添加一个Time_to_live字段，表明这条记录最多可以缓存多久。对于那些解析基本不变的域名，给一个比较大的值，而那些需要经常变动解析的域名，则可以给定一个小的值。</p>
<p>同样，域名服务器会将那些查询过的域名资源记录缓存下来，再次收到来自客户端的请求时，只要缓存不过期，就可以直接返回缓存结果，不用再次向上查询。</p>
<hr>
<h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p> DNS协议使用udp/tcp的53端口提供服务，客户端向DNS服务发起请求时，使用udp的53端口；DNS服务器间（包括主从之间）进行区域传送的时候使用TCP的53端口。</p>
<hr>
<h4 id="DNS服务器类型"><a href="#DNS服务器类型" class="headerlink" title="DNS服务器类型"></a>DNS服务器类型</h4><ol>
<li><p>主DNS服务器：为客户端提供域名解析的主要区域，主DNS服务器宕机，会启用从DNS服务器提供服务。</p>
</li>
<li><p>从DNS服务器：主服务器DNS长期无应答，从服务器也会停止提供服务。主从区域之间的同步采用周期性检查+通知的机制，从服务器周期性的检查主服务器上的记录情况，一旦发现修改就会同步，另外主服务器上如果有数据被修改了，会立即通知从服务器更新记录。</p>
</li>
<li><p>缓存服务器：服务器本身不提供解析区域，只提供非权威应答。</p>
</li>
<li>转发服务器：当DNS服务器的解析区域（包括缓存）中无法为当前的请求提供权威应答时，将请求转发至其它的DNS服务器，此时本地DNS服务器就是转发服务器。</li>
</ol>
<hr>
<div class="note success"><h3 id="DNS进阶原理"><a href="#DNS进阶原理" class="headerlink" title="DNS进阶原理"></a>DNS进阶原理</h3></div>
<h4 id="区域数据库-记录类型详解"><a href="#区域数据库-记录类型详解" class="headerlink" title="区域数据库 记录类型详解"></a>区域数据库 记录类型详解</h4><p>资源记录的定义格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name [TTL] IN RR_TYPE  value</div></pre></td></tr></table></figure>
<h5 id="SOA：一个区域的第一条资源记录："><a href="#SOA：一个区域的第一条资源记录：" class="headerlink" title="SOA：一个区域的第一条资源记录："></a>SOA：一个区域的第一条资源记录：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">name: 当前区域的名字；例如”maxiecloud.com.”，或者“2.3.4.in-addr.arpa.”</div><div class="line">value：有多部分组成</div><div class="line">		(1) 当前区域的区域名称（也可以使用主DNS服务器名称）；</div><div class="line">		(2) 当前区域管理员的邮箱地址；但地址中不能使用@符号，一般使用点号来替代；</div><div class="line">		(3) (主从服务协调属性的定义以及否定答案的TTL)</div></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">maxiecloud.com. 	86400 	IN 	SOA	maxiecloud.com. 	admin.maxiecloudcom.  (</div><div class="line">			2017010801; serial</div><div class="line">			2H ; refresh</div><div class="line">			10M ; retry</div><div class="line">			1W	; expire</div><div class="line">			1D	; negative answer ttl )</div></pre></td></tr></table></figure>
<h5 id="NS：域名服务记录，一个区域解析库可以有多个NS记录"><a href="#NS：域名服务记录，一个区域解析库可以有多个NS记录" class="headerlink" title="NS：域名服务记录，一个区域解析库可以有多个NS记录"></a>NS：域名服务记录，一个区域解析库可以有多个NS记录</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name: 当前区域的区域名称</div><div class="line">value：当前区域的某DNS服务器的名字，例如dns.maxiecloud.com.</div></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">name: 当前区域的区域名称</div><div class="line">value：当前区域某邮件交换器的主机名；</div><div class="line"></div><div class="line">注意：MX记录可以有多个；但每个记录的value之前应该有一个数字表示其优先级；</div></pre></td></tr></table></figure>
<h5 id="A：地址记录，FQDN-–-gt-IPv4"><a href="#A：地址记录，FQDN-–-gt-IPv4" class="headerlink" title="A：地址记录，FQDN –&gt; IPv4"></a>A：地址记录，FQDN –&gt; IPv4</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name：某FQDN，例如www.maxiecloud.com.</div><div class="line">value：某个IPv4地址，例如1.2.3.4</div></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">www.maxiecloud.com.		IN 	A  1.1.1.1</div><div class="line">www.maxiecloud.com.		IN 	A  1.1.1.2</div><div class="line">bbs.maxiecloud.com.		IN 	A  1.1.1.1</div></pre></td></tr></table></figure>
<h5 id="AAAA：IPv6地址记录，FQDN-–-gt-IPv6"><a href="#AAAA：IPv6地址记录，FQDN-–-gt-IPv6" class="headerlink" title="AAAA：IPv6地址记录，FQDN –&gt; IPv6"></a>AAAA：IPv6地址记录，FQDN –&gt; IPv6</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name：FQDN</div><div class="line">value：IPv6</div></pre></td></tr></table></figure>
<h5 id="PTR：指针记录，反向解析，IP-–-gt-FQDN"><a href="#PTR：指针记录，反向解析，IP-–-gt-FQDN" class="headerlink" title="PTR：指针记录，反向解析，IP –&gt; FQDN"></a>PTR：指针记录，反向解析，IP –&gt; FQDN</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name：IP地址，有特定格式，IP反过来写，而且加特定后缀；例如1.2.3.4的记录应该写为4.3.2.1.in-addr.arpa.</div><div class="line">value：FQDN</div></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4.3.2.1.in-addr.arpa.  	IN  PTR  www.maxiecloud.com.</div></pre></td></tr></table></figure>
<h5 id="CNAME：别名记录"><a href="#CNAME：别名记录" class="headerlink" title="CNAME：别名记录"></a>CNAME：别名记录</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name：FQDN格式的别名；</div><div class="line">value：FQDN格式的正式名字；</div></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">web.maxiecloud.com.  	IN  	CNAME  www.maxiecloud.com.</div></pre></td></tr></table></figure>
<p><strong>注意：</strong><br>(1) TTL可以从全局继承<br>(2) @可以表示当前区域的名称 –&gt; maxiecloud.com<br>(3) 相邻的两条记录其name相同时，后面的可省略<br>(4) 对于正向区域来说，各MX，NS等类型的记录的value为FQDN，此FQDN应该有一个A记录</p>
<hr>
<div class="note info"><h3 id="Bind的安装和基础配置"><a href="#Bind的安装和基础配置" class="headerlink" title="Bind的安装和基础配置"></a>Bind的安装和基础配置</h3></div>
<p>前面我们介绍了DNS的一些基础概念和进阶的知识，但是<code>DNS</code>是一种模型，需要使用软件去实现。</p>
<p>Bind(Berkeley Internet Name Domain)就是伴随<code>DNS</code>出生的软件。</p>
<h4 id="Bind程序包"><a href="#Bind程序包" class="headerlink" title="Bind程序包"></a>Bind程序包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bind.x86_64             Bind程序的主程序包，提供的dns server程序、以及几个常用的测试程序</div><div class="line"><span class="built_in">bind</span>-libs.x86_64        被<span class="built_in">bind</span>和<span class="built_in">bind</span>-utils包中的程序共同用到的库文件</div><div class="line"><span class="built_in">bind</span>-utils.x86_64       <span class="built_in">bind</span>客户端程序集，例如dig，host，nslookup</div><div class="line"><span class="built_in">bind</span>-chroot.x86_64      选装，让named运行于jail模式下（<span class="string">'更安全'</span>）</div></pre></td></tr></table></figure>
<h4 id="Bind配置文件"><a href="#Bind配置文件" class="headerlink" title="Bind配置文件"></a>Bind配置文件</h4><p>主配置文件： <code>/etc/named.conf</code></p>
<p>其他配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/etc/named.iscdlv.key </div><div class="line">/etc/named.rfc1912.zones <span class="comment">#定义区域的文件</span></div><div class="line">/etc/named.root.key</div></pre></td></tr></table></figure></p>
<p>解析库文件：<code>/var/named/</code>目录下；一般名字为：<code>ZONE_NAME.zone</code></p>
<p><strong>注意：</strong><br>(1) 一台DNS服务器可同时为多个区域提供解析；<br>(2) 必须要有根区域解析库文件：named.ca<br>(3) 还应该有两个区域解析库文件：localhost和127.0.0.1的正反向解析库</p>
<h4 id="配置一个正向解析区域"><a href="#配置一个正向解析区域" class="headerlink" title="配置一个正向解析区域"></a>配置一个正向解析区域</h4><h5 id="修改主配置文件-etc-named-conf"><a href="#修改主配置文件-etc-named-conf" class="headerlink" title="修改主配置文件 /etc/named.conf"></a>修改主配置文件 /etc/named.conf</h5><p>把主配置文件中 <code>options</code> 中的监听端口和dnssec功能修改了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">options &#123;</div><div class="line">        listen-on port 53 &#123; 127.0.0.1;172.16.1.51; &#125;;</div><div class="line">        directory       <span class="string">"/var/named"</span>;</div><div class="line">        dump-file       <span class="string">"/var/named/data/cache_dump.db"</span>;</div><div class="line">        statistics-file <span class="string">"/var/named/data/named_stats.txt"</span>;</div><div class="line">        memstatistics-file <span class="string">"/var/named/data/named_mem_stats.txt"</span>;</div><div class="line">        allow-query     &#123; any; &#125;;</div><div class="line">    </div><div class="line">        recursion yes;</div><div class="line">        </div><div class="line">        dnssec-enable no;</div><div class="line">        dnssec-validation no;</div></pre></td></tr></table></figure>
<p>主要修改的是：</p>
<ol>
<li>listen-on port 53 { 127.0.0.1;172.16.1.51; };  在127.0.0.1后添加一条监听本机网卡IP地址的信息</li>
<li>allow-query     { any; };   把这里的允许查询的范围改为<code>any</code></li>
<li>dnssec-enable no;   dnssec-validation no;  这两个防火墙功能设置为 <code>no</code>，也就是关闭其功能</li>
</ol>
<h5 id="定义一个zone"><a href="#定义一个zone" class="headerlink" title="定义一个zone"></a>定义一个zone</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">~]# vim /etc/named.rfs1912.conf     #在此文件的最后一行添加如下信息</div><div class="line">	zone &quot;maxiecloud.com&quot; IN &#123;</div><div class="line">		type master;</div><div class="line">		file &quot;maxiecloud.zone&quot;;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h5 id="创建区域解析库文件"><a href="#创建区域解析库文件" class="headerlink" title="创建区域解析库文件"></a>创建区域解析库文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[root@localhost named]# cat named.maxie</div><div class="line">$TTL 600M</div><div class="line">maxiecloud.com. IN	SOA	maxiecloud.com	nsadim.maxiecloud.com. (</div><div class="line">				2017052301	; serial</div><div class="line">					1H	; refresh</div><div class="line">					5M	; retry</div><div class="line">					1W	; expire</div><div class="line">					6H )	; minimum</div><div class="line">        IN	NS	dns1.maxie.com.</div><div class="line">        IN	NS	dns2.maxie.com.</div><div class="line">dns1.maxiecloud.com. IN	A	172.16.1.51</div><div class="line">dns2.maxiecloud.com. IN	A	172.16.1.52</div><div class="line">www.maxiecloud.com.  IN A       172.16.1.12</div><div class="line">web	IN	CNAME	www</div><div class="line">[root@localhost named]# chgrp named /var/named/maxiecloud.zone</div><div class="line">[root@localhost named]# chmod o= /var/named/maxiecloud.zone</div></pre></td></tr></table></figure>
<h5 id="检查、启动并测试DNS服务"><a href="#检查、启动并测试DNS服务" class="headerlink" title="检查、启动并测试DNS服务"></a>检查、启动并测试DNS服务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@localhost named]# named-checkcon          #检查主配置文件语法</div><div class="line">[root@localhost named]# named-checkzone &quot;maxiecloud.com&quot; /var/named/maxiecloud.zone         #检查maxiecloud.com zone所对应的解析库文件</div></pre></td></tr></table></figure>
<h5 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# host -t A www.maxiecloud.com  172.16.1.51</div><div class="line">Using domain server:</div><div class="line">Name: 172.16.1.51</div><div class="line">Address: 172.16.1.51#53</div><div class="line">Aliases:</div><div class="line"></div><div class="line">www.maxiecloud.com has address 172.16.1.12</div><div class="line"></div><div class="line">[root@localhost ~]# host -t NS maxiecloud.com  172.16.1.51</div><div class="line">Using domain server:</div><div class="line">Name: 172.16.1.51</div><div class="line">Address: 172.16.1.51#53</div><div class="line">Aliases:</div><div class="line"></div><div class="line">maxiecloud.com name server dns1.maxiecloud.com.</div><div class="line">maxiecloud.com name server dns2.maxiecloud.com.</div></pre></td></tr></table></figure>
<h4 id="配置一个反向解析区域"><a href="#配置一个反向解析区域" class="headerlink" title="配置一个反向解析区域"></a>配置一个反向解析区域</h4><h5 id="定义一个zone-1"><a href="#定义一个zone-1" class="headerlink" title="定义一个zone"></a>定义一个zone</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# vim /etc/named.rfs1912.zones </div><div class="line">zone &quot;16.172.in-addr.arpa&quot; IN &#123;</div><div class="line">	type master</div><div class="line">	file &quot;172.16.zone&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="创建区域反向解析库文件"><a href="#创建区域反向解析库文件" class="headerlink" title="创建区域反向解析库文件"></a>创建区域反向解析库文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# cd /var/named </div><div class="line">[root@localhost ~]# vim 172.16.zone   #这个文件中的@：表示/etc/named.rfs1912.zones中 zone的名字，也就是&quot;16.172.in-addr.arpa&quot;这个名字</div><div class="line">$TTL 9527</div><div class="line">$ORIGIN 16.172.in-addr.arpa.	       #这一步，在出现transfer failed的时候可以尝试设置，这可能是因为同一个网内出现了两个一样的反向解析服务器</div><div class="line">@	IN	SOA	maxiecloud.com.	nsadmin.maxiecloud.com. (</div><div class="line">		2017052301</div><div class="line">		3H</div><div class="line">		20M</div><div class="line">		1W</div><div class="line">		1D )</div><div class="line">	IN	NS	dns1.maxiecloud.com.</div><div class="line">	IN	NS	dns2.maxiecloud.com.</div><div class="line">51.1	IN	PTR	dns1.maxiecloud.com.</div><div class="line">52.1	IN	PTR	dns2.maxiecloud.com.</div><div class="line">12.1	IN	PTR	www.maxiecloud.com.</div><div class="line"></div><div class="line">这里如果后面自己补上了全部的地址，就必须在最后加上&quot;.&quot;</div><div class="line">如果不补全，则无需加&quot;.&quot;</div></pre></td></tr></table></figure>
<h5 id="检查、启动并测试DNS服务-1"><a href="#检查、启动并测试DNS服务-1" class="headerlink" title="检查、启动并测试DNS服务"></a>检查、启动并测试DNS服务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@localhost named]# named-checkcon          #检查主配置文件语法</div><div class="line">[root@localhost named]# named-checkzone &quot;16.172.in-addr.arpa&quot; /var/named/maxiecloud.zone         #检查maxiecloud.com zone所对应的解析库文件</div></pre></td></tr></table></figure>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">[root@localhost named]# rndc reload </div><div class="line">server reload successful</div><div class="line"></div><div class="line">[root@localhost named]# dig -t axfr 16.172.in-addr.arpa @172.16.1.51</div><div class="line"></div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-29.el7 &lt;&lt;&gt;&gt; -t axfr 16.172.in-addr.arpa @172.16.1.51</div><div class="line">;; global options: +cmd</div><div class="line">16.172.in-addr.arpa.	9527	IN	SOA	maxiecloud.com. nsadmin.maxiecloud.com. 2017052301 10800 1200 604800 86400</div><div class="line">16.172.in-addr.arpa.	9527	IN	NS	dns1.maxiecloud.com.</div><div class="line">16.172.in-addr.arpa.	9527	IN	NS	dns2.maxiecloud.com.</div><div class="line">12.1.16.172.in-addr.arpa. 9527	IN	PTR	www.maxiecloud.com.</div><div class="line">51.1.16.172.in-addr.arpa. 9527	IN	PTR	dns1.maxiecloud.com.</div><div class="line">52.1.16.172.in-addr.arpa. 9527	IN	PTR	dns2.maxiecloud.com.</div><div class="line">16.172.in-addr.arpa.	9527	IN	SOA	maxiecloud.com. nsadmin.maxiecloud.com. 2017052301 10800 1200 604800 86400</div><div class="line">;; Query time: 0 msec</div><div class="line">;; SERVER: 172.16.1.51#53(172.16.1.51)</div><div class="line">;; WHEN: 三 5月 24 05:42:04 CST 2017</div><div class="line">;; XFR size: 7 records (messages 1, bytes 226)</div><div class="line"></div><div class="line"></div><div class="line">[root@localhost named]# dig -x 172.16.1.12 @172.16.1.51</div><div class="line"></div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-29.el7 &lt;&lt;&gt;&gt; -x 172.16.1.12 @172.16.1.51</div><div class="line">;; global options: +cmd</div><div class="line">;; Got answer:</div><div class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 59255</div><div class="line">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 2, ADDITIONAL: 3</div><div class="line"></div><div class="line">;; OPT PSEUDOSECTION:</div><div class="line">; EDNS: version: 0, flags:; udp: 4096</div><div class="line">;; QUESTION SECTION:</div><div class="line">;12.1.16.172.in-addr.arpa.	IN	PTR</div><div class="line"></div><div class="line">;; ANSWER SECTION:</div><div class="line">12.1.16.172.in-addr.arpa. 9527	IN	PTR	www.maxiecloud.com.</div><div class="line"></div><div class="line">;; AUTHORITY SECTION:</div><div class="line">16.172.in-addr.arpa.	9527	IN	NS	dns2.maxiecloud.com.</div><div class="line">16.172.in-addr.arpa.	9527	IN	NS	dns1.maxiecloud.com.</div><div class="line"></div><div class="line">;; ADDITIONAL SECTION:</div><div class="line">dns1.maxiecloud.com.	600	IN	A	172.16.1.51</div><div class="line">dns2.maxiecloud.com.	600	IN	A	172.16.1.52</div><div class="line"></div><div class="line">;; Query time: 0 msec</div><div class="line">;; SERVER: 172.16.1.51#53(172.16.1.51)</div><div class="line">;; WHEN: 三 5月 24 05:42:33 CST 2017</div><div class="line">;; MSG SIZE  rcvd: 155</div></pre></td></tr></table></figure>
<hr>
<div class="note warning"><h3 id="主从配置和子域授权"><a href="#主从配置和子域授权" class="headerlink" title="主从配置和子域授权"></a>主从配置和子域授权</h3></div>
<h4 id="主从配置"><a href="#主从配置" class="headerlink" title="主从配置"></a>主从配置</h4><p>在两台或多台Linux主机上进行实验或操作时，最先要做的是时间同步</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ntpdate NTP_SERVER</div></pre></td></tr></table></figure>
<p>如果时间不同步，后面出现的问题就不是几分钟能解决的了。</p>
<p>在上面的实验中，我们已经配置好了一台具有DNS解析功能的服务器了，我们就把那一台当做主服务器，下面我们开始配置从服务器：</p>
<h5 id="从节点的配置：安装bind以及修改配置文件"><a href="#从节点的配置：安装bind以及修改配置文件" class="headerlink" title="从节点的配置：安装bind以及修改配置文件"></a>从节点的配置：安装bind以及修改配置文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ yum install -y <span class="built_in">bind</span></div><div class="line">$ vim /etc/named.conf</div><div class="line">options &#123;</div><div class="line">	//listen-on port 53 &#123; 127.0.0.1; &#125;     <span class="comment">#注释掉这段信息或者添加本地IP地址也可以</span></div><div class="line">	directory 	<span class="string">"/var/named"</span>;</div><div class="line">	dump-file 	<span class="string">"/var/named/data/cache_dump.db"</span>;</div><div class="line">	statistics-file <span class="string">"/var/named/data/named_stats.txt"</span>;</div><div class="line">	memstatistics-file <span class="string">"/var/named/data/named_mem_stats.txt"</span>;</div><div class="line">	allow-query     &#123; any; &#125;;	     <span class="comment">#修改为any</span></div><div class="line"></div><div class="line">	dnssec-enable no;	             <span class="comment">#设置为no</span></div><div class="line">	dnssec-validation no;                <span class="comment">#设置为no</span></div></pre></td></tr></table></figure>
<h5 id="定义一个从区域"><a href="#定义一个从区域" class="headerlink" title="定义一个从区域"></a>定义一个从区域</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# vim /etc/named.rfc1912.zones</div><div class="line">zone &quot;maxiecloud.com&quot; IN &#123;</div><div class="line">        type slave;</div><div class="line">        file &quot;slaves/maxiecloud.zone&quot;;</div><div class="line">        masters &#123; 172.16.1.51; &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">zone &quot;16.172.in-addr.arpa&quot; IN &#123;</div><div class="line">        type slave;</div><div class="line">        file &quot;slaves/172.16.zone&quot;;</div><div class="line">        masters &#123; 172.16.1.51; &#125;;</div><div class="line">&#125;;</div><div class="line">[root@localhost ~]# named-checkconf</div></pre></td></tr></table></figure>
<h5 id="开启服务并测试"><a href="#开启服务并测试" class="headerlink" title="开启服务并测试"></a>开启服务并测试</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# systemctl start named.service</div><div class="line">[root@localhost ~]# dig -t A www.maxiecloud.com @172.16.1.52</div><div class="line"></div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-29.el7 &lt;&lt;&gt;&gt; -t A www.maxiecloud.com @172.16.1.52</div><div class="line">;; global options: +cmd</div><div class="line">;; Got answer:</div><div class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 50052</div><div class="line">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 2, ADDITIONAL: 3</div><div class="line"></div><div class="line">;; OPT PSEUDOSECTION:</div><div class="line">; EDNS: version: 0, flags:; udp: 4096</div><div class="line">;; QUESTION SECTION:</div><div class="line">;www.maxiecloud.com.		IN	A</div><div class="line"></div><div class="line">;; ANSWER SECTION:</div><div class="line">www.maxiecloud.com.	600	IN	A	172.16.1.12</div><div class="line"></div><div class="line">;; AUTHORITY SECTION:</div><div class="line">maxiecloud.com.		600	IN	NS	dns1.maxiecloud.com.</div><div class="line">maxiecloud.com.		600	IN	NS	dns2.maxiecloud.com.</div><div class="line"></div><div class="line">;; ADDITIONAL SECTION:</div><div class="line">dns1.maxiecloud.com.	600	IN	A	172.16.1.51</div><div class="line">dns2.maxiecloud.com.	600	IN	A	172.16.1.52</div><div class="line"></div><div class="line">;; Query time: 0 msec</div><div class="line">;; SERVER: 172.16.1.52#53(172.16.1.52)</div><div class="line">;; WHEN: 三 5月 24 05:56:29 CST 2017</div><div class="line">;; MSG SIZE  rcvd: 133</div><div class="line"></div><div class="line">[root@localhost ~]# dig -t NS maxiecloud.com @172.16.1.52</div><div class="line"></div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-29.el7 &lt;&lt;&gt;&gt; -t NS maxiecloud.com @172.16.1.52</div><div class="line">;; global options: +cmd</div><div class="line">;; Got answer:</div><div class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 41932</div><div class="line">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 3</div><div class="line"></div><div class="line">;; OPT PSEUDOSECTION:</div><div class="line">; EDNS: version: 0, flags:; udp: 4096</div><div class="line">;; QUESTION SECTION:</div><div class="line">;maxiecloud.com.			IN	NS</div><div class="line"></div><div class="line">;; ANSWER SECTION:</div><div class="line">maxiecloud.com.		600	IN	NS	dns2.maxiecloud.com.</div><div class="line">maxiecloud.com.		600	IN	NS	dns1.maxiecloud.com.</div><div class="line"></div><div class="line">;; ADDITIONAL SECTION:</div><div class="line">dns1.maxiecloud.com.	600	IN	A	172.16.1.51</div><div class="line">dns2.maxiecloud.com.	600	IN	A	172.16.1.52</div><div class="line"></div><div class="line">;; Query time: 0 msec</div><div class="line">;; SERVER: 172.16.1.52#53(172.16.1.52)</div><div class="line">;; WHEN: 三 5月 24 05:56:37 CST 2017</div><div class="line">;; MSG SIZE  rcvd: 113</div></pre></td></tr></table></figure>
<hr>
<h4 id="子域授权"><a href="#子域授权" class="headerlink" title="子域授权"></a>子域授权</h4><p>现在我们开始配置子域授权，我们在主DNS服务器上进行授权</p>
<p>在<code>maxiecloud.zone</code>中添加如下信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ops.maxiecloud.com. IN          NS dns1.ops.maxiecloud.com. </div><div class="line">ops.maxiecloud.com. IN          NS dns2.ops.maxiecloud.com.</div><div class="line">dns1.ops.maxiecloud.com. IN          A  172.16.1.53         <span class="comment">#子域DNS服务器的IP地址</span></div><div class="line">dns2.ops.maxiecloud.com. IN          A  172.16.1.54         <span class="comment">#子域DNS服务器的IP地址</span></div></pre></td></tr></table></figure>
<h5 id="在子域DNS服务器上配置"><a href="#在子域DNS服务器上配置" class="headerlink" title="在子域DNS服务器上配置"></a>在子域DNS服务器上配置</h5><p>安装bind并修改配置文件信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ yum install -y <span class="built_in">bind</span></div><div class="line">$ vim /etc/named.conf</div><div class="line">options &#123;</div><div class="line">	//listen-on port 53 &#123; 127.0.0.1; &#125;     <span class="comment">#注释掉这段信息或者添加本地IP地址也可以</span></div><div class="line">	directory 	<span class="string">"/var/named"</span>;</div><div class="line">	dump-file 	<span class="string">"/var/named/data/cache_dump.db"</span>;</div><div class="line">	statistics-file <span class="string">"/var/named/data/named_stats.txt"</span>;</div><div class="line">	memstatistics-file <span class="string">"/var/named/data/named_mem_stats.txt"</span>;</div><div class="line">	allow-query     &#123; any; &#125;;	     <span class="comment">#修改为any</span></div><div class="line"></div><div class="line">	dnssec-enable no;	             <span class="comment">#设置为no</span></div><div class="line">	dnssec-validation no;                <span class="comment">#设置为no</span></div></pre></td></tr></table></figure>
<p>在/etc/named.rfs1912.zones中添加子域的信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ vim /etc/named.rfs1912.zones</div><div class="line">zone <span class="string">"ops.maxiecloud.com"</span> IN &#123;</div><div class="line">    <span class="built_in">type</span> master;</div><div class="line">    file <span class="string">"ops.maxiecloud.zone"</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>定义子域解析库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ vim /var/named/ops.maxiecloud.zone</div><div class="line"><span class="variable">$TTL</span> 600</div><div class="line">@   IN  SOA     maxiecloud.com.     nsadmin.maxiecloud.com. (</div><div class="line">        2017052301</div><div class="line">        1H</div><div class="line">        2M</div><div class="line">        3D</div><div class="line">        1D )</div><div class="line">        IN  NS  dns1.ops.maxiecloud.com.</div><div class="line">        IN  NS  dns2.ops.maxiecloud.com.</div><div class="line">dns1    IN  A   172.16.1.53</div><div class="line">dns2    IN  A   172.16.1.54</div><div class="line">www     IN  A   172.16.1.12</div></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">[root@localhost named]# service named start</div><div class="line">Starting named:                                            [  OK  ]</div><div class="line"> </div><div class="line">通过本机解析本域主机名</div><div class="line">[root@localhost named]# host -t A www.ops.maxiecloud.com 172.16.1.53</div><div class="line">Using domain server:</div><div class="line">Name: 172.16.1.53</div><div class="line">Address: 172.16.1.53#53</div><div class="line">Aliases: </div><div class="line">www.ops.maxiecloud.com has address 172.16.1.53</div><div class="line"> </div><div class="line">通过父域DNS解析本域下的主机名</div><div class="line"> </div><div class="line">[root@localhost named]# host -t A www.ops.maxiecloud.com 172.16.1.54</div><div class="line">Using domain server:</div><div class="line">Name: 172.16.1.54</div><div class="line">Address: 172.16.1.54#53</div><div class="line">Aliases: </div><div class="line"> </div><div class="line">www.ops.maxiecloud.com has address 172.16.1.54</div><div class="line"> </div><div class="line">通过本机DNS解析父域中的主机名</div><div class="line">[root@localhost named]# host -t A www.maxiecloud.com 172.16.1.53</div><div class="line">;; connection timed out; trying next origin</div><div class="line">Using domain server:</div><div class="line">Name: 172.16.1.53</div><div class="line">Address: 172.16.1.53#53</div><div class="line">Aliases: </div><div class="line"> </div><div class="line">Host www.maxiecloud.com not found: 3(NXDOMAIN)</div></pre></td></tr></table></figure>
<p>但是我们可能会发现一个问题，如果我需要解析父域中的主机名，只能通过递归到根域去解析，这是非常不便的，所以我们要设置转发器。</p>
<h5 id="设置区域转发"><a href="#设置区域转发" class="headerlink" title="设置区域转发"></a>设置区域转发</h5><p>区域转发：仅转发对特定区域的解析请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@localhost named]# vim /etc/named.rfc1912.zones</div><div class="line">zone &quot;maxiecloud.com&quot; IN &#123;	         #这里的ZONE_NAME是区域的名称，而非子域名称；所以这里应该是maxiecloud.com</div><div class="line">				type forward;</div><div class="line">				forward &#123; only; &#125;;</div><div class="line">				forwarders &#123; 172.16.1.51; &#125;;</div><div class="line">			&#125;;</div></pre></td></tr></table></figure>
<p>重载、测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@localhost named]<span class="comment"># rndc reload</span></div><div class="line">[root@localhost named]<span class="comment"># dig -t A www.maxiecloud.com @172.16.1.53</span></div></pre></td></tr></table></figure>
<hr>
<div class="note danger"><h3 id="BIND视图实现smart-DNS"><a href="#BIND视图实现smart-DNS" class="headerlink" title="BIND视图实现smart DNS"></a>BIND视图实现smart DNS</h3></div>
<p>由于中国的运营商之间的带宽是非常低，但是无论我们是哪个运营商的宽带，访问那些大型电商站点都是非常的快，那是因为在dns服务器中定义了来自哪些IP的请求解析成哪些地址，这就是视图的功能。</p>
<h4 id="配置视图"><a href="#配置视图" class="headerlink" title="配置视图"></a>配置视图</h4><p>初始化设置与上面的实验操作无异：</p>
<ol>
<li>安装bind</li>
<li>修改主配置文件的监听IP和allow-query、dnssec的配置</li>
</ol>
<p>初始化完毕之后，我们开始配置视图：</p>
<h5 id="定义acl"><a href="#定义acl" class="headerlink" title="定义acl"></a>定义acl</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@localhost named]# vim /etc/named.conf     #在此文件中 options的选项之前添加如下信息</div><div class="line">acl localnet &#123;</div><div class="line">	192.168.10.0/24;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">acl mynet &#123;</div><div class="line">	172.16.0.0/16;</div><div class="line">	127.0.0.0/8</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里需要注意的是，因为主配置文件中有一段 zone的配置信息，我们需要把其剪切出来，粘贴到/etc/named.rfc1912.zones的view local视图中：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1ffwja1t1i3g30jg0eihe6.gif" alt=""></p>
<p>配置/etc/named.rfc1912.zones文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">[root@localhost named]# vim /etc/named.rfc1912.zones</div><div class="line">view local &#123;</div><div class="line">	match-clients &#123; localnet; &#125;;</div><div class="line"></div><div class="line">zone &quot;.&quot; IN &#123;</div><div class="line">        type hint;</div><div class="line">        file &quot;named.ca&quot;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">zone &quot;localhost.localdomain&quot; IN &#123;</div><div class="line">	type master;</div><div class="line">	file &quot;named.localhost&quot;;</div><div class="line">	allow-update &#123; none; &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">zone &quot;localhost&quot; IN &#123;</div><div class="line">	type master;</div><div class="line">	file &quot;named.localhost&quot;;</div><div class="line">	allow-update &#123; none; &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">zone &quot;1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa&quot; IN &#123;</div><div class="line">	type master;</div><div class="line">	file &quot;named.loopback&quot;;</div><div class="line">	allow-update &#123; none; &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">zone &quot;1.0.0.127.in-addr.arpa&quot; IN &#123;</div><div class="line">	type master;</div><div class="line">	file &quot;named.loopback&quot;;</div><div class="line">	allow-update &#123; none; &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">zone &quot;0.in-addr.arpa&quot; IN &#123;</div><div class="line">	type master;</div><div class="line">	file &quot;named.empty&quot;;</div><div class="line">	allow-update &#123; none; &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">zone &quot;maxiecloud.com&quot; IN &#123;</div><div class="line">	type master;</div><div class="line">	file &quot;maxiecloud.zone/localnet&quot;;</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">view my &#123;</div><div class="line">	match-clients &#123; mynet; &#125;;</div><div class="line"></div><div class="line">zone &quot;maxiecloud.com&quot; IN &#123;</div><div class="line">	type master;</div><div class="line">	file &quot;maxiecloud.zone/mynet&quot;;</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">view ex &#123;</div><div class="line">	match-clients &#123; any; &#125;;</div><div class="line"></div><div class="line">zone &quot;maxiecloud.com&quot; IN &#123;</div><div class="line">	type master;</div><div class="line">	file &quot;maxiecloud.zone/ex&quot;;</div><div class="line">&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>创建maxiecloud.zone目录以及文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">[root@localhost named]# mkdir /var/named/maxiecloud.zone</div><div class="line">[root@localhost named]# vim localnet</div><div class="line">$TTL 610</div><div class="line">@	IN 		SOA  	maxiecloud.com.		nsadmin.maxiecloud.com. (</div><div class="line">			2017052301</div><div class="line">			1H</div><div class="line">			2M</div><div class="line">			1D</div><div class="line">			2D )</div><div class="line">@	IN 		NS 		dns1.maxiecloud.com.</div><div class="line">dns1 	IN 	A 		172.16.1.53</div><div class="line">www 	IN 	A 		1.1.1.1</div><div class="line"></div><div class="line"></div><div class="line">[root@localhost named]# vim mynet </div><div class="line">$TTL 620</div><div class="line">@	IN 		SOA  	maxiecloud.com.		nsadmin.maxiecloud.com. (</div><div class="line">			2017052301</div><div class="line">			1H</div><div class="line">			2M</div><div class="line">			1D</div><div class="line">			2D )</div><div class="line">@	IN 		NS 		dns1.maxiecloud.com.</div><div class="line">dns1 	IN 	A 		172.16.1.53</div><div class="line">www 	IN 	A 		2.1.1.1</div><div class="line"></div><div class="line">[root@localhost named]# vim ex </div><div class="line">$TTL 630</div><div class="line">@	IN 		SOA  	maxiecloud.com.		nsadmin.maxiecloud.com. (</div><div class="line">			2017052301</div><div class="line">			1H</div><div class="line">			2M</div><div class="line">			1D</div><div class="line">			2D )</div><div class="line">@	IN 		NS 		dns1.maxiecloud.com.</div><div class="line">dns1 	IN 	A 		172.16.1.53</div><div class="line">www 	IN 	A 		3.1.1.1</div></pre></td></tr></table></figure>
<p>测试验证：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1ffwjgtpxtlj30ma0hpn48.jpg" alt="view1"></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1ffwjgtg8yqj30ma0hpgsn.jpg" alt="view2"></p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1ffwjgt59yoj30iy0ezdlv.jpg" alt="view3"></p>
<hr>
<div class="note primary"><h3 id="自建根域-HTTPD服务-访问"><a href="#自建根域-HTTPD服务-访问" class="headerlink" title="自建根域 + HTTPD服务 访问"></a>自建根域 + HTTPD服务 访问</h3></div>
<p>自建根域+HTTPD服务教程：</p>
<iframe height="498" width="510" src="http://player.youku.com/embed/XMjc4NzA0NDI0OA==" frameborder="0" 'allowfullscreen'=""></iframe>


<p>Youtube：</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/K-kFhmsoSIA" frameborder="0" allowfullscreen></iframe>

<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=758649&auto=1&height=66"></iframe>

<p>本文出自<a href="http://maxiecloud.com" target="_blank" rel="external">Maxie’s Notes</a>博客，转载请务必保留此出处。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;网域名称系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。&lt;br&gt;它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。&lt;br&gt;DNS使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。&lt;br&gt;&lt;/blockquote&gt;

&lt;p&gt;DNS最早于1983年由保罗·莫卡派乔斯（Paul Mockapetris）发明；原始的技术规范在882号因特网标准草案（RFC 882）中发布。1987年发布的第1034和1035号草案修正了DNS技术规范，并废除了之前的第882和883号草案。在此之后对因特网标准草案的修改基本上没有涉及到DNS技术规范部分的改动。&lt;/p&gt;
&lt;p&gt;早期的域名必须以英文句号“.”结尾，当用户访问&lt;code&gt;www.maxiecloud.com&lt;/code&gt;的HTTP服务时必须在地址栏中输入：&lt;code&gt;http://www.maxiecloud.com.&lt;/code&gt;，这样DNS才能够进行域名解析。如今DNS服务器已经可以自动补上结尾的句号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.neustar.biz/blog/dns-cloud.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux进阶" scheme="http://yoursite.com/categories/linux%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="bind" scheme="http://yoursite.com/tags/bind/"/>
    
      <category term="dns" scheme="http://yoursite.com/tags/dns/"/>
    
      <category term="config" scheme="http://yoursite.com/tags/config/"/>
    
  </entry>
  
  <entry>
    <title>Linux文本三剑客之&quot;awk&quot;</title>
    <link href="http://yoursite.com/2017/05/21/awk-report-generator/"/>
    <id>http://yoursite.com/2017/05/21/awk-report-generator/</id>
    <published>2017-05-21T04:47:39.000Z</published>
    <updated>2017-05-21T06:39:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">awk是一个强大的文本分析工具。<br>它不仅是Liunx中，也是任何环境中现有功能最强大的数据处理引擎之一。<br>相对于“grep“的查找，”sed“的编译，awk在其对数据分析并生成报告时，显得尤为强大。<br></blockquote>

<p>当你第一次拿起双手在电脑上使用 awk 命令处理一个或者多个文件的时候，它会依次读取文件的每一行内容, 然后对其进行处理，awk 命令默认从 stdio 标准输入获取文件内容, awk 使用一对单引号来表示 一些可执行的脚本代码，在可执行脚本代码里面，使用一对花括号来表示一段可执行代码块，可以同时存在多个代码块。 awk 的每个花括号内同时又可以有多个指令，每一个指令用分号分隔，awk 其实就是一个脚本编程语言。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Fallen-leaves.png" class="full-image" alt="jumpserver"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<a id="more"></a>
<div class="note primary"><h3 id="awk语法以及基本使用方法"><a href="#awk语法以及基本使用方法" class="headerlink" title="awk语法以及基本使用方法"></a>awk语法以及基本使用方法</h3></div>
<h4 id="awk命令的基本语法"><a href="#awk命令的基本语法" class="headerlink" title="awk命令的基本语法"></a>awk命令的基本语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk [OPTIONS] &apos;program&apos; FILE...</div></pre></td></tr></table></figure>
<p>options 这个表示一些可选的参数选项，反正就是你爱用不用，不用可以拉到。。。 </p>
<p><strong>常用选项有：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-F fs：字段分隔符；fs指定输入分隔符，fs可以是字符串或正则表达式，如-F: </div><div class="line">-v var=value：用于实现自定义变量</div><div class="line"><span class="_">-f</span> FILENAME：直接从文件内读取执行的 <span class="string">'program'</span></div></pre></td></tr></table></figure>
<p>program 这个表示 awk 的可执行脚本代码，这个是必须要有的。<br>其中<code>program</code>的格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'program'</span>：PATTERN&#123;ACTION STATEMENTS&#125;</div><div class="line">ACTION STATEMENTS：动作语句，可以有多个；语句之间用分号分隔</div></pre></td></tr></table></figure>
<p>file 这个表示 awk 需要处理的文件，注意是纯文本文件，不是你的 mp3，也不是 mp4 啥的。。</p>
<hr>
<h4 id="awk的內建命令与变量"><a href="#awk的內建命令与变量" class="headerlink" title="awk的內建命令与变量"></a>awk的內建命令与变量</h4><h5 id="一、內建命令"><a href="#一、內建命令" class="headerlink" title="一、內建命令"></a>一、內建命令</h5><p>1、print打印</p>
<p><code>print item1,item2 ...</code></p>
<p>要点：<br>（1）逗号分隔符<br>（2）输出的各 item 可以是字符串，也可以是数值；当前记录的字段、变量或awk的表达式<br>（3）如果省略 item，通常相当于执行 print $0 打印整行字</p>
<p>2、printf 命令</p>
<p>格式化输出：<br><code>printf ”FORMAT“,item1,item2,....</code></p>
<p>要点：<br>（1）FORMAT：必须给出<br>（2）printf：不会自动换行，需要显示给出换行符: \n<br>（3）FORMAT中需要分别为后面的每个item指定一个格式化符号</p>
<p><strong>格式符：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">%c          显示字符的ACSII码</div><div class="line">%d,%i       显示十进制整数；d表示显示10进制，i表示整数</div><div class="line">%e,%E       显示为科学计数法数值显示</div><div class="line">%f          显示为浮点数  float</div><div class="line">%g,%G       以科学计数法或浮点形式显示数值</div><div class="line">%s          显示字符串</div><div class="line">%u          无符号整数</div><div class="line">%%          显示%自身</div></pre></td></tr></table></figure>
<p><strong>实例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">awk &apos;&#123;FS=&quot;:&quot;;printf &quot;%s\n&quot;,$1&#125;&apos; /etc/passwd</div><div class="line"></div><div class="line">[root@centos7 ~]# awk -F: &apos;&#123;printf &quot;Username:   %s\n&quot;,$1&#125;&apos; /etc/passwd</div><div class="line">Username:   root</div><div class="line">Username:   bin</div><div class="line">Username:   daemon</div><div class="line">Username:   adm</div><div class="line"></div><div class="line">[root@centos7 ~]# awk -F: &apos;&#123;printf &quot;Username:  %s UID: %d \n&quot;,$1,$3&#125;&apos; /etc/passwd</div><div class="line">Username:   root UID:   0</div><div class="line">Username:   bin UID:   1</div><div class="line">Username:   daemon UID:   2</div></pre></td></tr></table></figure>
<p><strong>格式符的修饰符：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#[.#]:</div><div class="line">	第一个数字用来控制 显示的宽度</div><div class="line">	第二个数字用来表示 小数点的精度</div><div class="line">	%3.1f</div></pre></td></tr></table></figure>
<p>默认为右对齐</p>
<pre><code>[root@centos7 ~]# awk -F: &apos;{printf &quot;Username: %10s  UID: %d\n&quot;,$1,$3}&apos; /etc/passwd
Username:       root  UID: 0
Username:        bin  UID: 1
Username:     daemon  UID: 2
</code></pre><p>-：减号表示左对齐</p>
<pre><code>root@centos7 ~]# awk -F: &apos;{printf &quot;Username: %-10s  UID: %d\n&quot;,$1,$3}&apos; /etc/passwd
Username: root        UID: 0
Username: bin         UID: 1
Username: daemon      UID: 2
</code></pre><p>+：加号表示显示数值的符号（正数负数）</p>
<h5 id="二、內建变量"><a href="#二、內建变量" class="headerlink" title="二、內建变量"></a>二、內建变量</h5><p><strong>特殊内置变量：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$0 这个表示文本处理时的当前行</div><div class="line"></div><div class="line">$1 表示文本行被分隔后的第 1 个字段列</div><div class="line"></div><div class="line">$2 表示文本行被分割后的第 2 个字段列</div><div class="line"></div><div class="line">$3 表示文本行被分割后的第 3 个字段列</div><div class="line"></div><div class="line">$n 表示文本行被分割后的第 n 个字段列</div></pre></td></tr></table></figure>
<p><code>awk</code>中的內建变量，无需使用 $ 符号直接可以调用变量的值</p>
<p>（1）FS：input field seperator，指定分隔符，默认为空白字符；</p>
<p><code>awk -v FS=&quot;:&quot; &#39;{print $1 }&#39; /etc/passwd</code></p>
<p>（2）OFS：output field seperator，指定输出分隔符，默认为空白字符</p>
<p><code>awk -v FS=&quot;:&quot; -v OFS=&quot;:&quot; &#39;{print $1}&#39; /etc/passwd</code></p>
<p>（3）RS：input record seperator，输入时的换行符</p>
<p><code>awk -v RS=&quot; &quot; &#39;{print}&#39; /etc/passwd</code></p>
<p>（4）ORS：output record seperator，输出时的换行符</p>
<p>（5）NF：number of field，字段数量<br>    {print NF}：显示文本的每行字段数量<br>    {print $NF}：显示每行末尾字段的信息</p>
<p>（6）NR：number of record，行数（默认输出每一行的行号），最后一行的行号即为这个文件的总行数<br>    {print NR}</p>
<p>（7）FNR：files number of record，统计多个文件的行数，分别打印(各文件分别计数)<br>    {print FNR}</p>
<p>（8）FILENAME：当前正在处理的文件名</p>
<p>（9）ARGC：命令行参数的个数<br>    ARGV：数组，保存命令行中所给定的各参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@centos7 ~]# awk &apos;BEGIN&#123;print ARGC&#125;&apos; /etc/fstab</div><div class="line">2</div><div class="line">[root@centos7 ~]# awk &apos;BEGIN&#123;print ARGV[0]&#125;&apos; /etc/fstab /etc/issue</div><div class="line">awk</div><div class="line">[root@centos7 ~]# awk &apos;BEGIN&#123;print ARGV[1]&#125;&apos; /etc/fstab /etc/issue</div><div class="line">/etc/fstab</div></pre></td></tr></table></figure>
<p>自定义变量：<br>(1)-v var=value ：自定义变量<br>    var：变量名，区分大小写<br>    value：值</p>
<p>(2)在’program’中直接定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@centos7 ~]# awk -v test=&quot;hello&quot; &apos;BEGIN&#123;print test&#125;&apos;</div><div class="line">hello</div><div class="line">[root@centos7 ~]# awk &apos;BEGIN&#123;test=&quot;hello&quot;;print test&#125;&apos;</div><div class="line">hello</div></pre></td></tr></table></figure>
<h5 id="三、操作符"><a href="#三、操作符" class="headerlink" title="三、操作符"></a>三、操作符</h5><ul>
<li>算数操作符：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x+y，x-y，x*y，x-y，x/y，x^y，x%y</div><div class="line">-x</div><div class="line">+x：转换为数值</div></pre></td></tr></table></figure>
<ul>
<li><p>字符串操作符：没有符号的操作符(字符串连接)</p>
</li>
<li><p>赋值操作符：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">=，+=，-=，*=，/=，%=，^=，++，--</div></pre></td></tr></table></figure>
<ul>
<li>比较操作符：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;,&gt;=,&lt;,&lt;=,!=不等于,==等值比较</div></pre></td></tr></table></figure>
<ul>
<li>模式匹配符：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">~：左侧字符串是否匹配右侧的模式</div><div class="line">！~：左侧字符串是否不匹配右侧的模式</div></pre></td></tr></table></figure>
<ul>
<li>逻辑操作符：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&amp;&amp;：与</div><div class="line">||：或</div><div class="line">! ：非</div></pre></td></tr></table></figure>
<p>函数调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function_name() ：进行调用函数</div><div class="line">或者</div><div class="line">function_name(arg1,arg2,arg3)</div></pre></td></tr></table></figure>
<p><strong>条件表达式：</strong></p>
<p><code>selector? if-true-expression:if-false-expression</code></p>
<p>selector：条件表达式，后面跟 ? 号<br>如果条件为真，则执行 if-true-expression<br>否则，执行 if-false-expression</p>
<p><strong>实例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@centos7 ~]# awk -F: &apos;&#123;$3&gt;=1000?usertype=&quot;Common User&quot;:usertype=&quot;System User&quot;;printf &quot;Username: %15s %s\n&quot;,$1,usertype&#125;&apos; /etc/passwd</div><div class="line">Username:            root System User</div><div class="line">Username:             bin System User</div><div class="line">Username:          daemon System User</div></pre></td></tr></table></figure>
<p>$3&gt;=1000?  ：以 : 为分隔符，判断第三个字段的值是否大于1000<br>如果为真，执行变量赋值：usertype=”Common User”<br>否则，执行变量赋值：usertype=”System User”</p>
<hr>
<div class="note success"><h3 id="awk进阶使用方法"><a href="#awk进阶使用方法" class="headerlink" title="awk进阶使用方法"></a>awk进阶使用方法</h3></div>
<h4 id="PATTERN-模式匹配"><a href="#PATTERN-模式匹配" class="headerlink" title="PATTERN 模式匹配"></a>PATTERN 模式匹配</h4><p>awk中的模式匹配功能，有点类似于地址定界的功能。</p>
<p>(1) empty（匹配每一行）:空模式</p>
<p>(2) /regular expression/：能够其中基本正则表达式匹配到的行，对其进行处理，未匹配到的行不做任何操作<br>    仅能够处理能够被此处的模式匹配到的行</p>
<p>如果想对其中模式匹配到的取反，可以使用：!/regular expression/ 进行取反操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[root@centos7 ~]# awk &apos;/^UUID/&#123;print $1&#125;&apos; /etc/fstab</div><div class="line">UUID=ab341a4b-a908-47c0-9553-bcf79b05ce43</div><div class="line">UUID=531365c9-8be5-40a1-bd9e-9bc980d21cda</div><div class="line">....</div><div class="line">[root@centos7 ~]# awk &apos;!/^UUID/&#123;print $1&#125;&apos; /etc/fstab</div><div class="line"></div><div class="line">#</div><div class="line">#</div><div class="line">#</div><div class="line">...</div></pre></td></tr></table></figure>
<p>（3） relational expression：关系表达式<br>    结果有真，有假；结果为”真“，才会处理<br>    真表示：结果为非0值，或者非空字符串；0表示假</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">[root@centos7 ~]# awk -F: &apos;$3&gt;=1000&#123;print $1,$3&#125;&apos; /etc/passwd</div><div class="line">nfsnobody 65534</div><div class="line">hacker 1000</div><div class="line">maxie1 1001</div><div class="line"></div><div class="line">其中 $3&gt;=1000 就是关系表达式，如果为真才会打印 $1 $3</div><div class="line"></div><div class="line">注意： 这里的&#123;print $1 $3&#125; 之前没有分号，因为这是一个语句</div><div class="line"></div><div class="line">[root@centos7 ~]# awk -F: &apos;$NF==&quot;/bin/bash&quot;&#123;print $1,$NF&#125;&apos; /etc/passwd</div><div class="line">root /bin/bash</div><div class="line">hacker /bin/bash</div><div class="line">maxie1 /bin/bash</div><div class="line">您在 /var/spool/mail/root 中有新邮件</div><div class="line">[root@centos7 ~]# awk -F: &apos;$NF~&quot;/bin/bash&quot;&#123;print $1,$NF&#125;&apos; /etc/passwd</div><div class="line">root /bin/bash</div><div class="line">hacker /bin/bash</div><div class="line">maxie1 /bin/bash</div><div class="line">[root@centos7 ~]# awk -F: &apos;$NF~/bash$/&#123;print $1,$NF&#125;&apos; /etc/passwd</div><div class="line">root /bin/bash</div><div class="line">hacker /bin/bash</div><div class="line">maxie1 /bin/bash</div></pre></td></tr></table></figure>
<p>这里 $NF 表示的是 每一行最后一个字段的值</p>
<p>注意：在使用模式匹配时，要在前后加上 // 符号</p>
<p>（4）line ranges ：行范围（地址定界）</p>
<p>startline,endline：</p>
<p>/pattern1/,/pattern2/这样来定义<br>或者<br>(NR&gt;=number&amp;&amp;NR&lt;=number)这样的格式来定义</p>
<pre><code>NR：每一行的行号
</code></pre><p>注意：不支持直接给出数字的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">[root@centos7 ~]# awk -F: &apos;/^b/,/^sync/&#123;print $1&#125;&apos; /etc/passwd</div><div class="line">bin</div><div class="line">daemon</div><div class="line">adm</div><div class="line">lp</div><div class="line">sync</div><div class="line"></div><div class="line">[root@centos7 ~]# awk -F: &apos;(NR&lt;=10)&#123;print $1&#125;&apos; /etc/passwd</div><div class="line">root</div><div class="line">bin</div><div class="line">daemon</div><div class="line">adm</div><div class="line">lp</div><div class="line">sync</div><div class="line">shutdown</div><div class="line">halt</div><div class="line">mail</div><div class="line">operator</div><div class="line">[root@centos7 ~]# awk -F: &apos;(NR&lt;=10&amp;&amp;NR&gt;=2)&#123;print $1&#125;&apos; /etc/passwd</div><div class="line">bin</div><div class="line">daemon</div><div class="line">adm</div><div class="line">lp</div><div class="line">sync</div><div class="line">shutdown</div><div class="line">halt</div><div class="line">mail</div><div class="line">operator</div></pre></td></tr></table></figure>
<p>（5）BEGIN/END模式：</p>
<p>BEGIN{}：仅在开始处理文件中的文本之前执行一次（可以打印表头）</p>
<p>END{}：仅在文本处理完成之后执行一次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[root@centos7 ~]# awk -F: &apos;BEGIN&#123;print &quot;username        uid      \n----------------------&quot;&#125; &#123;printf &quot;%-15s %s\n&quot;,$1,$3&#125; END&#123;print &quot;=======================&quot;&#125;&apos; /etc/passwd</div><div class="line">username        uid</div><div class="line">----------------------</div><div class="line">root            0</div><div class="line">bin             1</div><div class="line">daemon          2</div><div class="line">....</div><div class="line">hacker          1000</div><div class="line">maxie1          1001</div><div class="line">dhcpd           177</div><div class="line">=======================</div></pre></td></tr></table></figure>
<hr>
<div class="note info"><h3 id="awk中各控制语句的用法"><a href="#awk中各控制语句的用法" class="headerlink" title="awk中各控制语句的用法"></a>awk中各控制语句的用法</h3></div>
<h4 id="1、if-else-语句"><a href="#1、if-else-语句" class="headerlink" title="1、if-else 语句"></a>1、if-else 语句</h4><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if(condition) statement  [else statement]</div></pre></td></tr></table></figure>
<p>如果有多个语句 则是 {statements}</p>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">[root@centos7 ~]# awk -F: &apos;&#123;if($3&gt;=1000) print $1,$3&#125;&apos; /etc/passwd</div><div class="line">nfsnobody 65534</div><div class="line">hacker 1000</div><div class="line">maxie1 1001</div><div class="line">[root@centos7 ~]# awk -F: &apos;&#123;if($3&gt;=1000) &#123;print $1,$3&#125; else &#123;print &quot;system user&quot;&#125;&#125;&apos; /etc/passwd</div><div class="line"></div><div class="line"></div><div class="line">对一行中字段数量大于6的，进行打印 print $0，也就是匹配的整行</div><div class="line"></div><div class="line">[root@centos7 ~]# awk &apos;&#123;if(NF&gt;6) print&#125;&apos; /etc/fstab</div><div class="line">#Created by anaconda on Sun Mar 19 02:00:07 2017</div><div class="line">#Accessible filesystems, by reference, are maintained under &apos;/dev/disk&apos;</div><div class="line">#See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</div><div class="line"></div><div class="line">[root@centos7 ~]# df -h | awk -F&quot;%&quot; &apos;/^\/dev/&#123;print $1&#125;&apos; | awk &apos;BEGIN&#123; print &quot;Disk full\n------------&quot;&#125;&#123;if($NF&gt;=15) print $1&#125;&apos;</div><div class="line">Disk full</div><div class="line">------------</div><div class="line">/dev/sda3</div><div class="line">/dev/sda1</div></pre></td></tr></table></figure>
<p>先对设备进行取出，并以%为分隔符，取出$1的值；再对$NF,也就是最后一个字段的值进行判断</p>
<p>使用场景：对awk取得的整行或某个字段做条件判断</p>
<h4 id="2、while-循环"><a href="#2、while-循环" class="headerlink" title="2、while 循环"></a>2、while 循环</h4><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">while(condition) statement</div></pre></td></tr></table></figure>
<p>条件为真，进入循环<br>条件为假，退出循环</p>
<p>使用场景：对一行内的多个字段 逐一/类似 处理时使用； 对数组中的各元素逐一处理时使用</p>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="string">'对每一行的每一个字段进行计算字段长度'</span></div><div class="line">[root@centos7 ~]<span class="comment"># awk '/^[[:space:]]*linux16/&#123;i=1;while(i&lt;=NF) &#123;print $i,length($i); i++&#125;&#125;' /etc/grub2.cfg</span></div><div class="line">linux16 7</div><div class="line">/vmlinuz-3.10.0-514.el7.x86_64 30</div><div class="line">root=UUID=ab341a4b<span class="_">-a</span>908-47c0-9553-bcf79b05ce43 46</div><div class="line">ro 2</div><div class="line">rhgb 4</div><div class="line">quiet 5</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">'只有当一个字段内字符长度大于7时，才打印'</span></div><div class="line">[root@centos7 ~]<span class="comment"># awk '/^[[:space:]]*linux16/&#123;i=1;while(i&lt;=NF) &#123;if(length($i)&gt;=7) &#123;print $i,length($i)&#125; i++&#125;&#125;' /etc/grub2.cfg</span></div><div class="line">linux16 7</div><div class="line">/vmlinuz-3.10.0-514.el7.x86_64 30</div><div class="line">root=UUID=ab341a4b<span class="_">-a</span>908-47c0-9553-bcf79b05ce43 46</div><div class="line">LANG=en_US.UTF-8 16</div></pre></td></tr></table></figure>
<h4 id="3、do-while-循环（至少会执行一次循环体）"><a href="#3、do-while-循环（至少会执行一次循环体）" class="headerlink" title="3、do while 循环（至少会执行一次循环体）"></a>3、do while 循环（至少会执行一次循环体）</h4><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">do statement while(condition)</div></pre></td></tr></table></figure>
<h4 id="4、for-循环"><a href="#4、for-循环" class="headerlink" title="4、for 循环"></a>4、for 循环</h4><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for(expr1;expr2;expr3) statement</div><div class="line"></div><div class="line">expr1：控制变量初始化</div><div class="line">expr2：条件判断</div><div class="line">expr3：控制变量数值修正表达式</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for(variable assignment;condition;iteration process) &#123;for-body&#125;</div></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="string">'对每一行的每一个字段进行计算字段长度'</span></div><div class="line">[root@centos7 ~]<span class="comment"># awk '/^[[:space:]]*linux16/&#123;for(i=1;i&lt;=NF;i++) &#123;print $i,length($i)&#125;&#125;' /etc/grub2.cfg</span></div><div class="line">linux16 7</div><div class="line">/vmlinuz-3.10.0-514.el7.x86_64 30</div><div class="line">root=UUID=ab341a4b<span class="_">-a</span>908-47c0-9553-bcf79b05ce43 46</div><div class="line">ro 2</div><div class="line">rhgb 4</div><div class="line"></div><div class="line">[root@centos7 ~]<span class="comment"># awk '/^[[:space:]]*linux16/&#123;for(i=1;i&lt;=NF;i++) &#123;if(length($i)&gt;=7) &#123;print $i,length($i)&#125; &#125;&#125;' /etc/grub2.cfg</span></div><div class="line">linux16 7</div><div class="line">/vmlinuz-3.10.0-514.el7.x86_64 30</div><div class="line">root=UUID=ab341a4b<span class="_">-a</span>908-47c0-9553-bcf79b05ce43 46</div><div class="line">LANG=en_US.UTF-8 16</div></pre></td></tr></table></figure>
<p><strong>特殊用法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="string">'能够遍历数组中的元素'</span></div><div class="line"></div><div class="line">语法：</div><div class="line"><span class="keyword">for</span>(var <span class="keyword">in</span> array) &#123;<span class="keyword">for</span>-body&#125;</div><div class="line"></div><div class="line">若要遍历数组中的每个元素，要使用<span class="keyword">for</span>循环：</div><div class="line"><span class="keyword">for</span>(var <span class="keyword">in</span> array) &#123;<span class="keyword">for</span>-body&#125;</div><div class="line"></div><div class="line">[root@centos7 ~]<span class="comment"># awk 'BEGIN&#123;weekdays["mon"]="Monday";weekdays["tue"]="Tuesday";for(i in weekdays) &#123;print weekdays[i]&#125;&#125;'</span></div><div class="line">Tuesday</div><div class="line">Monday</div></pre></td></tr></table></figure>
<h4 id="5、array数组："><a href="#5、array数组：" class="headerlink" title="5、array数组："></a>5、array数组：</h4><p>关联数组：array[index-expression]</p>
<p>index-expression：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(1)可使用任意字符串;字符串需要使用双引号</div><div class="line">(2)如果某数组元素不存在，在引用时，awk 会自动创建此 元素，并将其初始化为”空串“</div></pre></td></tr></table></figure>
<p>若要判断数组中是否存在某元素，要使用”index in array“格式进行：</p>
<p>weekdays[“mon”]=”Monday”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@centos7 ~]# awk &apos;BEGIN&#123;weekdays[&quot;mon&quot;]=&quot;Monday&quot;;weekdays[&quot;tue&quot;]=&quot;Tuesday&quot;;print weekdays[&quot;tue&quot;]&#125;&apos;</div><div class="line">Tuesday</div><div class="line">[root@centos7 ~]# awk &apos;BEGIN&#123;weekdays[&quot;mon&quot;]=&quot;Monday&quot;;weekdays[&quot;tue&quot;]=&quot;Tuesday&quot;;print weekdays[&quot;mon&quot;]&#125;&apos;</div><div class="line">Monday</div><div class="line">[root@centos7 ~]# awk &apos;BEGIN&#123;weekdays[0]=&quot;Monday&quot;;weekdays[1]=&quot;123&quot;;print weekdays[0]&#125;&apos;</div><div class="line">Monday</div><div class="line">[root@centos7 ~]# awk &apos;BEGIN&#123;weekdays[0]=&quot;Monday&quot;;weekdays[1]=&quot;123&quot;;print weekdays[1]&#125;&apos;</div><div class="line">123</div></pre></td></tr></table></figure>
<p>若要遍历数组中的每个元素，要使用for循环：<br>for(var in array) {for-body}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@centos7 ~]# awk &apos;BEGIN&#123;weekdays[&quot;mon&quot;]=&quot;Monday&quot;;weekdays[&quot;tue&quot;]=&quot;Tuesday&quot;;for(i in weekdays) &#123;print weekdays[i]&#125;&#125;&apos;</div><div class="line">Tuesday</div><div class="line">Monday</div></pre></td></tr></table></figure>
<p>注意：var 会遍历 array 的每个索引，但顺序可能不同</p>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="string">'1、统计 netstat -tnl 中state状态有几种，各出现了几次'</span></div><div class="line">[root@centos7 ~]<span class="comment"># netstat -tnl | awk '/^tcp\&gt;/&#123;state[$NF]++&#125;END&#123;for(i in state) &#123;print i,state[i]&#125;&#125;'</span></div><div class="line">LISTEN 4</div><div class="line"></div><div class="line"><span class="string">'2、统计 httpd 的 /var/log/httpd/access_log 文件中 ip地址的访问次数'</span></div><div class="line">[root@centos7 ~]<span class="comment"># awk '&#123;ip[$1]++&#125;END&#123;for(i in ip) print i,ip[i]&#125;' /var/log/httpd/access_log</span></div><div class="line">172.16.1.122</div><div class="line">172.16.1.11</div><div class="line">::1</div><div class="line"></div><div class="line"><span class="string">'3、netstat -tna 查看连接到本机IP地址和状态'</span></div><div class="line">[root@centos7 ~]<span class="comment"># netstat -tan | awk  -v FS='[[:space:]:]+' '$(NF-2)~/\.+/&#123;if (1!=NR) IpState[$6"  "$NF]++&#125;END&#123;for(i in IpState) &#123;print i,IpState[i]&#125;&#125;'</span></div><div class="line">172.16.1.11  ESTABLISHED 2</div></pre></td></tr></table></figure>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=16532462&auto=1&height=66"></iframe>

<p>本文出自<a href="http://maxiecloud.com" target="_blank" rel="external">Maxie’s Notes</a>博客，转载请务必保留此出处。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;awk是一个强大的文本分析工具。&lt;br&gt;它不仅是Liunx中，也是任何环境中现有功能最强大的数据处理引擎之一。&lt;br&gt;相对于“grep“的查找，”sed“的编译，awk在其对数据分析并生成报告时，显得尤为强大。&lt;br&gt;&lt;/blockquote&gt;

&lt;p&gt;当你第一次拿起双手在电脑上使用 awk 命令处理一个或者多个文件的时候，它会依次读取文件的每一行内容, 然后对其进行处理，awk 命令默认从 stdio 标准输入获取文件内容, awk 使用一对单引号来表示 一些可执行的脚本代码，在可执行脚本代码里面，使用一对花括号来表示一段可执行代码块，可以同时存在多个代码块。 awk 的每个花括号内同时又可以有多个指令，每一个指令用分号分隔，awk 其实就是一个脚本编程语言。&lt;/p&gt;
&lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;/images/Fallen-leaves.png&quot; class=&quot;full-image&quot; alt=&quot;jumpserver&quot; /&gt;&lt;meta itemprop=&quot;width&quot; content=&quot;auto&quot;&gt;&lt;meta itemprop=&quot;height&quot; content=&quot;auto&quot;&gt;&lt;/span&gt;
    
    </summary>
    
      <category term="linux进阶" scheme="http://yoursite.com/categories/linux%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="command" scheme="http://yoursite.com/tags/command/"/>
    
      <category term="awk" scheme="http://yoursite.com/tags/awk/"/>
    
      <category term="editor" scheme="http://yoursite.com/tags/editor/"/>
    
  </entry>
  
  <entry>
    <title>Linux破坏性实验</title>
    <link href="http://yoursite.com/2017/05/13/kernel-experiment/"/>
    <id>http://yoursite.com/2017/05/13/kernel-experiment/</id>
    <published>2017-05-13T07:21:25.000Z</published>
    <updated>2017-05-13T11:25:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">在学习Linux的过程中，不免由于”手速”过快的原因，导致执行 “rm -rf”命令时，删除了我们不想删除的文件。<br>这时，身为小白的我们想到的第一个解决办法就是 “重装系统”，这也不失为一个好的解决办法；<br>但是如果里面有我们辛辛苦苦写了几个星期的一些脚本和笔记呢？<br>这时候就需要使用Linux自带的 “Rescue installed system(救援模式)” 来为我们恢复了！<br></blockquote>

<p>插入 <code>CentOS</code>系统光盘，或者挂载光盘到虚拟机中；</p>
<p>开机按 <code>F2</code> 或者 <code>ESC键</code> ，进入到<code>Boot Menu</code>；</p>
<p>选择<code>CD-ROM Drive</code>即可进入到光盘启动。</p>
<p>进入到光盘界面，使用上下箭头选择模式，这里我们要进入到 “Rescue installed system(救援模式)”，所以选择 <code>第三项</code></p>
<p><img src="http://ww3.sinaimg.cn/large/006tKfTcly1ffjrt1jp05j319k0y0th7.jpg" alt=""></p>
<a id="more"></a>
<p><strong>注意：</strong><br>此次实验的环境为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">内核版本：2.6.32-642.el6.x86_64</div><div class="line">系统版本：CentOS release 6.8 (Final)</div><div class="line">虚拟机版本：VMware Fusion 专业版 8.5.3 (4696910)</div></pre></td></tr></table></figure>
<div class="note primary"><h3 id="Liunx破坏性实验-easy-mode"><a href="#Liunx破坏性实验-easy-mode" class="headerlink" title="Liunx破坏性实验(easy mode)"></a>Liunx破坏性实验(easy mode)</h3></div>
<p>在这一章节，我们只做一些 一学就懂，一做就明白的实验。</p>
<h4 id="第一个实验：修改-etc-inittab文件中的runlevel修改成了6"><a href="#第一个实验：修改-etc-inittab文件中的runlevel修改成了6" class="headerlink" title="第一个实验：修改/etc/inittab文件中的runlevel修改成了6"></a>第一个实验：修改/etc/inittab文件中的runlevel修改成了6</h4><p><code>/etc/inittab</code>文件存放的是我们系统启动时的启动级别。</p>
<p>运行级别：为系统运行或维护等目的而设定；</p>
<p>0-6：7个级别</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0：关机</div><div class="line">1：单用户模式(root自动登录), single, 维护模式     无网络功能</div><div class="line">2: 多用户模式，启动网络功能，但不会启动NFS(默认所有模式都关闭)；维护模式</div><div class="line">3：多用户模式，正常模式；文本界面</div><div class="line">4：预留级别；可同3级别</div><div class="line">5：多用户模式，正常模式；图形界面</div><div class="line">6：重启</div></pre></td></tr></table></figure>
<p>这里我们设置成 <code>6</code> 就是无限重启</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ vim /etc/inittab</div><div class="line">id:6:initdefault:</div></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/006tKfTcly1ffjtx4lx4xg30dw08oe8e.gif" alt=""></p>
<p><strong>解决方法：</strong></p>
<ol>
<li>在菜单界面，按a即可 进入grub启动选项界面；</li>
<li>在一串选项的后面，键入 数字3 或 数字5，都可以进入多用户模式，不同的是一个是字符界面，一个是图形界面</li>
<li>这样我们就能正常启动linux系统啦</li>
<li>但是，不要高兴得太早，现在我们只是手动的修改了启动选项，启动配置文件还没有修改。</li>
<li>进入系统后，修改 <code>/etc/inittab</code> 文件的runlevel等级为5即可。</li>
</ol>
<p><img src="http://ww4.sinaimg.cn/large/006tKfTcly1ffju507jp0j30zm0k6ndf.jpg" alt=""></p>
<p>注意最后面的 数字5</p>
<p>这里我们选择了 以图形化界面启动系统</p>
<hr>
<h4 id="第二个实验，忘记root（超级管理员）用户密码，如何破解？"><a href="#第二个实验，忘记root（超级管理员）用户密码，如何破解？" class="headerlink" title="第二个实验，忘记root（超级管理员）用户密码，如何破解？"></a>第二个实验，忘记root（超级管理员）用户密码，如何破解？</h4><ol>
<li>开机进入倒计时的时候，按下a键，进入到grub内核启动参数的编辑界面</li>
<li>直接在后面输入 <code>single</code> 或者 <code>S</code> 或者 <code>single s</code> 都可以进入到 <code>单用户模式</code></li>
<li>系统以单用户模式启动后，无需输入任何密码，就以 <code>root</code>用户的身份登录到了系统，这样我们就可以使用 <code>passwd</code> 命令修改 <code>root</code>用户的密码了！</li>
</ol>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1ffjuytqqcrj30zi0jsaq5.jpg" alt=""></p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1ffjw76nq0xj318e0x2k0r.jpg" alt=""></p>
<hr>
<h4 id="第三个实验，删除-boot-vmlinuz-2-6-32-642-el6-x86-64文件，如何恢复？"><a href="#第三个实验，删除-boot-vmlinuz-2-6-32-642-el6-x86-64文件，如何恢复？" class="headerlink" title="第三个实验，删除/boot/vmlinuz-2.6.32-642.el6.x86_64文件，如何恢复？"></a>第三个实验，删除/boot/vmlinuz-2.6.32-642.el6.x86_64文件，如何恢复？</h4><p>1、 挂载系统光盘<br>2、 进入救援模式：</p>
<ul>
<li>在出现VMware的界面，快速按<code>ESC键</code>，进入<code>boot menu</code>，选择<code>CD-ROM</code>选项</li>
<li>进入到光盘引导之后，选择第三项，救援模式</li>
</ul>
<p>3、 进入到救援模式后，选择按照默认的选择一步一步的走到 <code>shell start shell</code>的界面时：<br>    回车进入一个<code>shell</code>终端内</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1ffjwucb5xgg30jg0c6e8a.gif" alt=""></p>
<p>4、回到了我们熟悉的命令行界面，现在我们开始正式的恢复之前删除的 <code>vmlinuz</code>文件</p>
<p><strong>步骤如下：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ chroot /mnt/sysimage          <span class="comment">#切根到我们真正的系统根目录上</span></div><div class="line">$ mount /dev/sr0 /mnt           <span class="comment">#挂载系统光盘</span></div><div class="line">$ cp /mnt/isolinux/vmlinuz /boot/vmlinuz-`uname -r`  <span class="comment">#拷贝光盘内的内核文件到我们的/boot目录下</span></div><div class="line">$ sync</div><div class="line">$ <span class="built_in">exit</span></div><div class="line">$ reboot</div></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1ffjx7q5m0eg30jg0c6u1d.gif" alt=""></p>
<p>这样就大功告成啦</p>
<div class="note success"><h3 id="Linux扇区破坏性实验-normal-mode"><a href="#Linux扇区破坏性实验-normal-mode" class="headerlink" title="Linux扇区破坏性实验(normal mode)"></a>Linux扇区破坏性实验(normal mode)</h3></div>
<p>现在开始的实验，非常危险!!!<br>请朋友们，在执行如下操作的时候，确保为<code>实验机</code>做了 <code>快照</code>、<code>备份</code>或者<code>镜像</code>等操作。</p>
<h4 id="第一个实验，破坏MBR前446个字节的信息，并恢复。"><a href="#第一个实验，破坏MBR前446个字节的信息，并恢复。" class="headerlink" title="第一个实验，破坏MBR前446个字节的信息，并恢复。"></a>第一个实验，破坏MBR前446个字节的信息，并恢复。</h4><p>1、先执行<code>dd</code>命令，破坏MBR的前446字节</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ dd <span class="keyword">if</span>=/dev/zero of=/dev/sda bs=1 count=446        <span class="comment">#把前446字节都重写为0</span></div><div class="line">$ hexdump -C -n 512 -v /dev/sda                     <span class="comment">#查看/dev/sda的前512字节，确认446字节都被重写为0</span></div><div class="line">$ reboot</div></pre></td></tr></table></figure>
<p>2、开始恢复：</p>
<ul>
<li>进入救援模式</li>
<li>切根</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chroot /dev/sda</div></pre></td></tr></table></figure>
<ul>
<li>安装grub</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ grub-install /dev/sda</div></pre></td></tr></table></figure>
<ul>
<li>等待安装完毕，查看/dev/sda的信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexdump -C -n 512 /dev/sda</div></pre></td></tr></table></figure>
<ul>
<li>修复成功，重启即可</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sync</div><div class="line">$ <span class="built_in">exit</span> </div><div class="line">$ reboot</div></pre></td></tr></table></figure>
<hr>
<h4 id="第二个实验，破坏MBR后续的2048个字节，并恢复。-stage1-5阶段的破坏"><a href="#第二个实验，破坏MBR后续的2048个字节，并恢复。-stage1-5阶段的破坏" class="headerlink" title="第二个实验，破坏MBR后续的2048个字节，并恢复。(stage1.5阶段的破坏)"></a>第二个实验，破坏MBR后续的2048个字节，并恢复。(stage1.5阶段的破坏)</h4><p>1、先执行<code>dd</code>命令，进行破坏</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ dd <span class="keyword">if</span>=/dev/zero of=/dev/sda bs=1 count=2048 skip=512 seek=512       </div><div class="line">$ hexdump -C -n 2048 -v /dev/sda</div></pre></td></tr></table></figure>
<p>2、开始恢复</p>
<ul>
<li>进入救援模式</li>
<li>切根</li>
<li>进入grub命令行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ grub</div><div class="line">grub&gt; root (hd0,0)          <span class="comment">#boot分区在硬盘上的分区位置</span></div><div class="line">grub&gt; setup (hd0)           <span class="comment">#boot分区在哪个硬盘上</span></div><div class="line">grub&gt; quit</div></pre></td></tr></table></figure>
<ul>
<li>重启，并退出救援模式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">exit</span></div><div class="line">$ reboot</div></pre></td></tr></table></figure>
<ul>
<li>修复成功！</li>
</ul>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1ffjxxi76mwg30jg0c67wt.gif" alt=""></p>
<hr>
<h4 id="第三个实验，删除-boot-grub-，并恢复"><a href="#第三个实验，删除-boot-grub-，并恢复" class="headerlink" title="第三个实验，删除/boot/grub/*，并恢复"></a>第三个实验，删除/boot/grub/*，并恢复</h4><p>1、执行删除操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rm -rf /boot/grub/*</div></pre></td></tr></table></figure>
<p>2、进入救援模式，开始恢复</p>
<ul>
<li>切根</li>
<li>安装grub</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ grub-install /dev/sda</div></pre></td></tr></table></figure>
<ul>
<li>由于<code>grub-install</code>命令并不会为我们产生 grub.conf 配置文件，所以需要我们手写</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ vim /boot/grub/grub.conf</div><div class="line">default 0</div><div class="line">timeout 5</div><div class="line">titile CentOS 6.8(Final)</div><div class="line">    kernel /vmlinuz-2.6.32-642.el6.x86_64 root=/dev/mapper/vg0-root selinux=0</div><div class="line">    initrd /initramfs-2.6.32-642.el6.x86_64.img</div></pre></td></tr></table></figure>
<ul>
<li>修复完成，退出救援模式，并重启</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sync</div><div class="line">$ <span class="built_in">exit</span></div><div class="line">$ reboot</div></pre></td></tr></table></figure>
<ul>
<li>修复完成啦！！！</li>
</ul>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1ffjyfficrbg30jg0c6e87.gif" alt=""></p>
<hr>
<p><strong>以上这些就是我在学习过程中总结的各种实验步骤，希望dalao们多多指点！</strong></p>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=469535480&auto=1&height=66"></iframe> 

<p>本文出自<a href="http://maxiecloud.com" target="_blank" rel="external">Maxie’s Notes</a>博客，转载请务必保留此出处。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;在学习Linux的过程中，不免由于”手速”过快的原因，导致执行 “rm -rf”命令时，删除了我们不想删除的文件。&lt;br&gt;这时，身为小白的我们想到的第一个解决办法就是 “重装系统”，这也不失为一个好的解决办法；&lt;br&gt;但是如果里面有我们辛辛苦苦写了几个星期的一些脚本和笔记呢？&lt;br&gt;这时候就需要使用Linux自带的 “Rescue installed system(救援模式)” 来为我们恢复了！&lt;br&gt;&lt;/blockquote&gt;

&lt;p&gt;插入 &lt;code&gt;CentOS&lt;/code&gt;系统光盘，或者挂载光盘到虚拟机中；&lt;/p&gt;
&lt;p&gt;开机按 &lt;code&gt;F2&lt;/code&gt; 或者 &lt;code&gt;ESC键&lt;/code&gt; ，进入到&lt;code&gt;Boot Menu&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;选择&lt;code&gt;CD-ROM Drive&lt;/code&gt;即可进入到光盘启动。&lt;/p&gt;
&lt;p&gt;进入到光盘界面，使用上下箭头选择模式，这里我们要进入到 “Rescue installed system(救援模式)”，所以选择 &lt;code&gt;第三项&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/006tKfTcly1ffjrt1jp05j319k0y0th7.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux进阶" scheme="http://yoursite.com/categories/linux%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="kernel" scheme="http://yoursite.com/tags/kernel/"/>
    
      <category term="damage" scheme="http://yoursite.com/tags/damage/"/>
    
      <category term="recover" scheme="http://yoursite.com/tags/recover/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络接口配置-&quot;Bonding&quot;</title>
    <link href="http://yoursite.com/2017/05/06/Bonding-Configuration/"/>
    <id>http://yoursite.com/2017/05/06/Bonding-Configuration/</id>
    <published>2017-05-06T03:05:57.000Z</published>
    <updated>2017-05-06T05:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">“Bonding”就是将多块网卡绑定同一IP地址对外提供服务，可以实现高可用/负载均衡。<br><br>在企业以及电信Linux服务器环境上，网络配置都会使用Bonding技术做网口硬件层面的冗余，防止单个网络应用的单点故障。<br></blockquote>

<p>本文将介绍Linux下的<code>Bonding</code>技术，利用这种技术可以将多块网卡接口通过绑定虚拟成一块网卡，在用户看来这个聚合起来的设备好像是一个单独的以太网接口设备，通俗点讲就是多块网卡具有相同的IP地址而并行连接聚合成一个逻辑链路工作。</p>
<a id="more"></a>
<div class="note primary"><h3 id="Bond的几种工作模式"><a href="#Bond的几种工作模式" class="headerlink" title="Bond的几种工作模式"></a>Bond的几种工作模式</h3></div>
<h4 id="模式1：mode-0，（balance-rr）Round-robin（轮循策略）"><a href="#模式1：mode-0，（balance-rr）Round-robin（轮循策略）" class="headerlink" title="模式1：mode=0，（balance-rr）Round-robin（轮循策略）"></a>模式1：mode=0，（balance-rr）Round-robin（轮循策略）</h4><p><strong>特点：</strong><br>传输数据包顺序是依次传输（即：第一个包走eth0，下一包就走eth1…，一直这样循环下去，直到最后一个传输完毕），此模式提供负载平衡和容错能力；但是我们知道如果一个连接或者会话的数据包从不同的接口发出的话，中途再经过不同的链路，在客户端很有可能会出现数据包无序到达的问题，而无序到达的数据包需要重新要求被发送，这样网络的吞吐量就会下降。</p>
<h4 id="模式2：mode-1，即：（active-backup）Active-backup（主备策略）"><a href="#模式2：mode-1，即：（active-backup）Active-backup（主备策略）" class="headerlink" title="模式2：mode=1，即：（active-backup）Active-backup（主备策略）"></a>模式2：mode=1，即：（active-backup）Active-backup（主备策略）</h4><p><strong>特点：</strong><br>只有一个设备（slave）处于活动状态，当一个宕掉另一个马上由备份转为主设备。mac地址是外部可见的，从外面看来，<code>bond</code>的MAC地址是唯一的，以避免交换机（switch）发生混乱。<br>此模式只提供了容错能力；<br>由此可见此模式的优点是可以提供高可用的网络连接，但是它的资源利用率较低，只有一个接口处于工作状态，在有N个网络接口的情况下，资源利用率仅为1/N。</p>
<h4 id="模式3：mode-2，即：（balance-xor）XOR（平衡策略）"><a href="#模式3：mode-2，即：（balance-xor）XOR（平衡策略）" class="headerlink" title="模式3：mode=2，即：（balance-xor）XOR（平衡策略）"></a>模式3：mode=2，即：（balance-xor）XOR（平衡策略）</h4><p><strong>特点：</strong><br>基于指定的传输HASH策略传输数据包。缺省的策略是：（源MAC地址 XOR 目标MAC地址） % slave数量，其他的传输策略可以通过<code>xmit_hash_policy</code>选项指定，此模式提供负载平衡和容错能力。</p>
<h4 id="模式4：mode-3，即：broadcast-广播策略"><a href="#模式4：mode-3，即：broadcast-广播策略" class="headerlink" title="模式4：mode=3，即：broadcast 广播策略"></a>模式4：mode=3，即：broadcast 广播策略</h4><p><strong>特点：</strong><br>在每个slave接口上传输每个数据包，此模式提供了容错能力</p>
<h4 id="模式5：mode-4，即：（802-3ad）IEEE-802-3adDynamic-link-aggregation（IEEE-802-3ad-动态链接聚合）"><a href="#模式5：mode-4，即：（802-3ad）IEEE-802-3adDynamic-link-aggregation（IEEE-802-3ad-动态链接聚合）" class="headerlink" title="模式5：mode=4，即：（802.3ad）IEEE 802.3adDynamic link aggregation（IEEE 802.3ad 动态链接聚合）"></a>模式5：mode=4，即：（802.3ad）IEEE 802.3adDynamic link aggregation（IEEE 802.3ad 动态链接聚合）</h4><p><strong>特点：</strong><br>创建一个聚合组，它们共享同样的速率和双工设定。<br>根据<code>802.3ad</code>规范将多个slave工作在同一个激活的聚合体下。</p>
<p>外出流量的slave选举是基于传输hash策略，该策略可以通过<code>xmit_hash_policy</code>选项从缺省的XOR策略改变到其他策略。需要注意的是，并不是所有的传输策略都是<code>802.3ad</code>适应的，尤其考虑到在<code>802.3ad</code>标准提及的包乱序问题，不同的实现可能会有不同的适应性。</p>
<p><strong>必要条件：</strong></p>
<p>条件1：<code>ethtool</code>支持获取每个slave的速率和双工设定 </p>
<p>条件2：switch(交换机)支持<code>IEEE 802.3ad Dynamic link aggregation</code> </p>
<p>条件3：大多数switch(交换机)需要经过特定配置才能支持<code>802.3ad</code>模式</p>
<h4 id="模式6：mode-5，即：（balance-tlb）Adaptive-transmit-load-balancing（适配器传输负载均衡）"><a href="#模式6：mode-5，即：（balance-tlb）Adaptive-transmit-load-balancing（适配器传输负载均衡）" class="headerlink" title="模式6：mode=5，即：（balance-tlb）Adaptive transmit load balancing（适配器传输负载均衡）"></a>模式6：mode=5，即：（balance-tlb）Adaptive transmit load balancing（适配器传输负载均衡）</h4><p><strong>特点：</strong><br>不需要任何的特别交换机（switch）支持的通道bonding。在每个slave上根据当前的负载（根据速度计算）分配外出流量。如果正在接受数据的slave出故障了，另一个slave接管失败的slave的MAC地址。</p>
<p>该模式的必要条件：ethtool支持获取每个slave的速率。</p>
<h4 id="模式7：mode-6，即：（balance-alb）Adaptive-load-balancing（适配器适应性负载均衡）"><a href="#模式7：mode-6，即：（balance-alb）Adaptive-load-balancing（适配器适应性负载均衡）" class="headerlink" title="模式7：mode=6，即：（balance-alb）Adaptive load balancing（适配器适应性负载均衡）"></a>模式7：mode=6，即：（balance-alb）Adaptive load balancing（适配器适应性负载均衡）</h4><p><strong>特点：</strong><br>该模式包含了balance-tlb模式，同时加上针对IPV4流量的接收负载均衡(receive load balance, rlb)，而且不需要任何switch(交换机)的支持。接收负载均衡是通过ARP协商实现的。bonding驱动截获本机发送的ARP应答，并把源硬件地址改写为bond中某个slave的唯一硬件地址，从而使得不同的对端使用不同的硬件地址进行通信。</p>
<hr>
<div class="note success"><h3 id="常用模式详解"><a href="#常用模式详解" class="headerlink" title="常用模式详解"></a>常用模式详解</h3></div>
<p>Linux Bond有两种经典的模式：主备（mode=1）、负载均衡（mode=0）</p>
<p>下面，我们将对这两个模式进行详细的介绍以及在CentOS6和7上进行试验。</p>
<h4 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h4><p><strong>主备模式：</strong></p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1ffbj1odk5bj30f20dvglz.jpg" alt=""></p>
<p><strong>负载均衡模式：</strong></p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1ffbj1oj6s4j30f20dvwev.jpg" alt=""></p>
<hr>
<h4 id="主备模式、负载均衡模式详解"><a href="#主备模式、负载均衡模式详解" class="headerlink" title="主备模式、负载均衡模式详解"></a>主备模式、负载均衡模式详解</h4><p><strong>1. 我们先看主备模式</strong></p>
<p>主备模式下，Linux Bonding实现会将Bond的两个slave网口的MAC地址改为Bond的MAC地址，而Bond的MAC地址是Bond创建启动后，主用slave网口的MAC地址。</p>
<p>当住用网口故障后，Bond会切换到备用网口，切换过程中，上层的应用是无感知不受影响的，因为Bond在驱动层，会接管上层应用的数据包，缓存起来等备用网卡起来后再通过备用网卡发送出去。当然，前提是切换时间很短，否则缓冲区是会溢出的，溢出后就开始丢包了。具体的时间值本人还没有验证过。</p>
<p><strong>2. 再看负载均衡模式</strong></p>
<p>负载均衡模式下，Linux Bonding实现可以保持两个slave网口的MAC地址不变，Bond的MAC地址是其中一个网卡的，Bond MAC地址的选择是根据Bond自己实现的一个算法来的，具体如何选择还没有研究。</p>
<p>当然，这里要重点说明的是，Bond负载均衡模式下，要求交换机做配置，是的两个slave网口能够互通，否则的话，丢包会很厉害，基本没法使用。这个是因为Bond的负载均衡模式算法，会将包在两个网口之间传输以达到负载均衡。<br>由于负载均衡模式下，两个slave有独立的MAC地址，你可能会想，我能否给slave网口再绑定一个IP地址，用作其他用途。<br>这种方法是实现不了的。</p>
<p>负载均衡模式下，两个slave网口在操作性系统上看到是两个独立的MAC地址，但是当你指定一个MAC地址发送包的时候，实际上发生的现象，不是你期望的。你指定MAC地址1发包，这个数据包可能到MAC地址2出去了。<br>这个是因为Bond对这两个网口做了手脚，改了网口的驱动。看起来他们有独立的MAC地址，实际上他们的MAC地址不是独立的，只能给Bond使用。</p>
<h4 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h4><p><strong>从上面的介绍中，很容易看到Bond的一点不足：</strong></p>
<p>Bond更改了网口的驱动，其网口不能被用作其他用途。</p>
<p>Bond还有一点不足就是其故障监测上面：<br>Bond默认只能做网口MII监测不能做链路监测（链路是指本机到网关的路径），也就是只能监测网口是否连接（网口是否亮）；当然Bond也支持ARP协议的链路监测，但是ARP链路监测在一些场景下，太消耗资源，得不偿失。我们曾经在实际应用中使用过，效果确实不好。</p>
<hr>
<div class="note info"><h3 id="主备模式的实施（CentOS6-and-CentOS7）"><a href="#主备模式的实施（CentOS6-and-CentOS7）" class="headerlink" title="主备模式的实施（CentOS6 and CentOS7）"></a>主备模式的实施（CentOS6 and CentOS7）</h3></div>
<p><strong>实验环境：</strong></p>
<p>CentOS6：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">操作系统（OS）：CentOS release 6.8 (Final)</div><div class="line">内核版本（Kernel）：2.6.32-642.el6.x86_64</div><div class="line">虚拟机环境：VMware Fusion 专业版 8.5.3 (4696910)</div></pre></td></tr></table></figure>
<p>CentOS7：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">操作系统（OS）：CentOS Linux release 7.2.1511 (Core)</div><div class="line">内核版本（Kernel）：3.10.0-514.el7.x86_64</div><div class="line">虚拟机环境：VMware Fusion 专业版 8.5.3 (4696910)</div></pre></td></tr></table></figure>
<h4 id="Centos6实验步骤"><a href="#Centos6实验步骤" class="headerlink" title="Centos6实验步骤"></a>Centos6实验步骤</h4><h5 id="第一步，在VMware的控制台把需要绑定的网卡都设置在一个网段内（都设置成主机模式或者桥接，自定义都可以）"><a href="#第一步，在VMware的控制台把需要绑定的网卡都设置在一个网段内（都设置成主机模式或者桥接，自定义都可以）" class="headerlink" title="第一步，在VMware的控制台把需要绑定的网卡都设置在一个网段内（都设置成主机模式或者桥接，自定义都可以）"></a>第一步，在VMware的控制台把需要绑定的网卡都设置在一个网段内（都设置成主机模式或者桥接，自定义都可以）</h5><h5 id="第二步，在Terminal关闭NetworkManager服务，在-etc-sysconfig-network-scripts-目录下创建ifcfg-bond0配置文件"><a href="#第二步，在Terminal关闭NetworkManager服务，在-etc-sysconfig-network-scripts-目录下创建ifcfg-bond0配置文件" class="headerlink" title="第二步，在Terminal关闭NetworkManager服务，在/etc/sysconfig/network-scripts/目录下创建ifcfg-bond0配置文件"></a>第二步，在<code>Terminal</code>关闭<code>NetworkManager</code>服务，在<code>/etc/sysconfig/network-scripts/</code>目录下创建<code>ifcfg-bond0</code>配置文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ service NetworkManager stop </div><div class="line">$ <span class="built_in">cd</span> /etc/sysconfig/network-scripts</div><div class="line">$ vim ifcfg-bond0</div><div class="line">	DEVICE=bond0</div><div class="line">	BONDING_OPTS=<span class="string">"miiimon=100 mode=1"</span></div><div class="line">	IPADDR=172.16.23.150</div><div class="line">	NETMASK=255.255.255.0</div><div class="line">	GATEWAY=172.16.23.1</div></pre></td></tr></table></figure>
<h5 id="第三步，修改两张物理网卡的配置信息"><a href="#第三步，修改两张物理网卡的配置信息" class="headerlink" title="第三步，修改两张物理网卡的配置信息"></a>第三步，修改两张物理网卡的配置信息</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ vim ifcfg-eth0</div><div class="line">	DEVICE=<span class="string">"eth0"</span></div><div class="line">	MASTER=bond0</div><div class="line">	SLAVE=yes</div><div class="line"></div><div class="line">$ vim ifcfg-eth1</div><div class="line">	DEVICE=<span class="string">"eth1"</span></div><div class="line">	MASTER=bond0</div><div class="line">	SLAVE=yes</div></pre></td></tr></table></figure>
<h5 id="第四步，重启网络服务"><a href="#第四步，重启网络服务" class="headerlink" title="第四步，重启网络服务"></a>第四步，重启网络服务</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ service network restart</div></pre></td></tr></table></figure>
<h5 id="第五步，查看bond0配置信息"><a href="#第五步，查看bond0配置信息" class="headerlink" title="第五步，查看bond0配置信息"></a>第五步，查看<code>bond0</code>配置信息</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">$ cat /proc/net/bonding/bond0 </div><div class="line">	Ethernet Channel Bonding Driver: v3.7.1 (April 27, 2011)</div><div class="line">	Bonding Mode: fault-tolerance (active-backup)</div><div class="line">	Primary Slave: None</div><div class="line">	Currently Active Slave: eth0</div><div class="line">	MII Status: up</div><div class="line">	MII Polling Interval (ms): 100</div><div class="line">	Up Delay (ms): 0</div><div class="line">	Down Delay (ms): 0</div><div class="line"></div><div class="line">	Slave Interface: eth0</div><div class="line">	MII Status: up</div><div class="line">	Speed: 1000 Mbps</div><div class="line">	Duplex: full</div><div class="line">	Link Failure Count: 0</div><div class="line">	Permanent HW addr: 00:0c:29:26:8e:b1</div><div class="line">	Slave queue ID: 0</div><div class="line"></div><div class="line">	Slave Interface: eth1</div><div class="line">	MII Status: up</div><div class="line">	Speed: 1000 Mbps</div><div class="line">	Duplex: full</div><div class="line">	Link Failure Count: 0</div><div class="line">	Permanent HW addr: 00:0c:29:26:8e:bb</div><div class="line">	Slave queue ID: 0</div></pre></td></tr></table></figure>
<h5 id="第六步，手动在VM控制端，模拟网卡故障，-断掉eth0的连接，使用另一台在一个网段的主机一直ping-bond0-的IP地址，查看是否会自动切换网卡"><a href="#第六步，手动在VM控制端，模拟网卡故障，-断掉eth0的连接，使用另一台在一个网段的主机一直ping-bond0-的IP地址，查看是否会自动切换网卡" class="headerlink" title="第六步，手动在VM控制端，模拟网卡故障， 断掉eth0的连接，使用另一台在一个网段的主机一直ping bond0 的IP地址，查看是否会自动切换网卡"></a>第六步，手动在VM控制端，模拟网卡故障， 断掉eth0的连接，使用另一台在一个网段的主机一直<code>ping bond0</code> 的IP地址，查看是否会自动切换网卡</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">$ ping 172.16.23.150</div><div class="line">	64 bytes from 172.16.23.150: icmp_seq=10 ttl=64 time=0.197 ms</div><div class="line">	Request timeout <span class="keyword">for</span> icmp_seq 11</div><div class="line">	Request timeout <span class="keyword">for</span> icmp_seq 12</div><div class="line">	64 bytes from 172.16.23.150: icmp_seq=13 ttl=64 time=0.223 ms</div><div class="line">	64 bytes from 172.16.23.150: icmp_seq=14 ttl=64 time=0.214 ms</div><div class="line"></div><div class="line">已经自动切换，并丢了2个包</div><div class="line">	</div><div class="line">查看bond0的信息，是否已经切换到eth1</div><div class="line"></div><div class="line">$ cat /proc/net/bonding/bond0 </div><div class="line">	Ethernet Channel Bonding Driver: v3.7.1 (April 27, 2011)</div><div class="line"></div><div class="line">	Bonding Mode: fault-tolerance (active-backup)</div><div class="line">	Primary Slave: None</div><div class="line">	Currently Active Slave: eth1</div><div class="line">	MII Status: up</div><div class="line">	MII Polling Interval (ms): 100</div><div class="line">	Up Delay (ms): 0</div><div class="line">	Down Delay (ms): 0</div><div class="line"></div><div class="line">	Slave Interface: eth0</div><div class="line">	MII Status: down</div><div class="line">	Speed: Unknown</div><div class="line">	Duplex: Unknown</div><div class="line">	Link Failure Count: 1</div><div class="line">	Permanent HW addr: 00:0c:29:26:8e:b1</div><div class="line">	Slave queue ID: 0</div><div class="line"></div><div class="line">	Slave Interface: eth1</div><div class="line">	MII Status: up</div><div class="line">	Speed: 1000 Mbps</div><div class="line">	Duplex: full</div><div class="line">	Link Failure Count: 0</div><div class="line">	Permanent HW addr: 00:0c:29:26:8e:bb</div></pre></td></tr></table></figure>
<h5 id="第七步，删除bond0"><a href="#第七步，删除bond0" class="headerlink" title="第七步，删除bond0"></a>第七步，删除bond0</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ ifconfig bond0 down  <span class="comment">#down掉网卡</span></div><div class="line"></div><div class="line">$ rmmod bonding    <span class="comment">#卸载模块</span></div><div class="line"></div><div class="line">$ rm -rf /etc/sysconfig/network-scripts/ifcfg-bond0  <span class="comment">#删除配置文件</span></div><div class="line"></div><div class="line">$ vim ifcfg-eth0</div><div class="line">	BOOTPROTO=static</div><div class="line">	IPADDR=172.16.1.130</div><div class="line">	PREFIX=16</div><div class="line">	GATEWAY=172.16.0.1</div><div class="line"></div><div class="line">$ vim ifcfg-eth1</div><div class="line">	BOOTPROTO=dhcp </div><div class="line"></div><div class="line">$ service network restart <span class="comment">#重启网络</span></div></pre></td></tr></table></figure>
<h4 id="Centos7实验步骤"><a href="#Centos7实验步骤" class="headerlink" title="Centos7实验步骤"></a>Centos7实验步骤</h4><ul>
<li>因为使用的是<code>CentOS7.2</code>所以，网卡名非常的长，不便于实验，先修改网卡名</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ vim /boot/grub2/grub.cfg</div><div class="line">	修改此文件中的linux16一行的行尾添加 net.ifnames=0</div><div class="line">	</div><div class="line">$ vim /etc/sysconfig/network-scripts/ifcfg-eno.....</div><div class="line">	修改原配置文件中的DEVICE名字和NAME名字，以及配置文件的名字为更改后的名字eth0/1之类的</div><div class="line"></div><div class="line">$ reboot </div><div class="line">    即可生效</div></pre></td></tr></table></figure>
<ul>
<li><p>第一步，修改两张网卡都为仅主机模式</p>
</li>
<li><p>第二步，创建<code>bond0</code>设备以及其配置文件</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ nmcli connection add con-name bond0 <span class="built_in">type</span> bond ifname bond0 mode active-backup</div><div class="line"></div><div class="line">$ nmcli connection modift bond0 ipv4.method manual ipv4.addresses 172.16.23.200 gw 172.16.23.1</div></pre></td></tr></table></figure>
<ul>
<li>第三步，将物理网卡添加到<code>bond0</code>中</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ nmcli connection add <span class="built_in">type</span> bond-slave ifname eth0 master bond0 </div><div class="line"></div><div class="line">$ nmcli connection add <span class="built_in">type</span> bond-slave ifname eth1 master bond0</div></pre></td></tr></table></figure>
<ul>
<li>第四步，启动<code>bond-slave</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ nmcli connection up bond-slave-eth1</div><div class="line"></div><div class="line">$ nmcli connection up bond-slave-eth0</div></pre></td></tr></table></figure>
<ul>
<li>第五步，启动<code>bond0</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ nmcli connection up bond0</div></pre></td></tr></table></figure>
<ul>
<li><p>第六步，容错测试，与CentOS6步骤相同</p>
</li>
<li><p>第七步，删除<code>bond0</code></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ nmcli connection down bond0 </div><div class="line"></div><div class="line">$ nmcli connection delete bond0 </div><div class="line"></div><div class="line">$ nmcli connection delete bond-slave-eth0</div><div class="line"></div><div class="line">$ nmcli connection delete bond-slave-eth1</div><div class="line"></div><div class="line">$ systemctl restart network</div></pre></td></tr></table></figure>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=35283291&auto=0&height=66"></iframe>

<p>本文出自<a href="http://maxiecloud.com" target="_blank" rel="external">Maxie’s Notes</a>博客，转载请务必保留此出处。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;“Bonding”就是将多块网卡绑定同一IP地址对外提供服务，可以实现高可用/负载均衡。&lt;br&gt;&lt;br&gt;在企业以及电信Linux服务器环境上，网络配置都会使用Bonding技术做网口硬件层面的冗余，防止单个网络应用的单点故障。&lt;br&gt;&lt;/blockquote&gt;

&lt;p&gt;本文将介绍Linux下的&lt;code&gt;Bonding&lt;/code&gt;技术，利用这种技术可以将多块网卡接口通过绑定虚拟成一块网卡，在用户看来这个聚合起来的设备好像是一个单独的以太网接口设备，通俗点讲就是多块网卡具有相同的IP地址而并行连接聚合成一个逻辑链路工作。&lt;/p&gt;
    
    </summary>
    
      <category term="linux网络配置" scheme="http://yoursite.com/categories/linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="network" scheme="http://yoursite.com/tags/network/"/>
    
      <category term="bonding" scheme="http://yoursite.com/tags/bonding/"/>
    
  </entry>
  
  <entry>
    <title>route命令详解</title>
    <link href="http://yoursite.com/2017/05/04/route-command/"/>
    <id>http://yoursite.com/2017/05/04/route-command/</id>
    <published>2017-05-04T11:47:48.000Z</published>
    <updated>2017-05-06T03:08:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">Linux系统的route命令用于显示和操作IP路由表<br><br>要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。<br></blockquote>

<p><strong>在Linux系统中，设置路由通常是为了解决以下问题：</strong></p>
<p>该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的IP地址设置为Linux机器的默认路由。</p>
<p>要注意的是，直接在命令行执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了。</p>
<p>可以在<code>/etc/sysconfig/network-scripts/</code>目录下创建<code>route-IFACE</code>类似的配置文件。</p>
<p>其中<code>IFACE</code>的名字不是很重要，起一个能够辨识其功能的名字即可。</p>
<a id="more"></a>
<div class="note primary"><h3 id="路由的分类"><a href="#路由的分类" class="headerlink" title="路由的分类"></a>路由的分类</h3></div>
<p><strong>主机路由</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">针对特定的地址，非常精细</div><div class="line"></div><div class="line">route add -host 2.2.2.2 gw 1.1.1.1 dev eth0</div><div class="line">这条路由只指向2.2.2.2这个主机，不包括在其网络内的其他主机</div></pre></td></tr></table></figure>
<p><strong>网络路由</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">指明网段的路由，网络路由针对的是一个网段的路由，比主机路由精细度要低一些</div><div class="line"></div><div class="line">route add -net 2.2.2.0/24 gw 1.1.1.1 dev eth0</div><div class="line">这条路由指向的是2.2.2.0/24这个网络内的所有IP。</div></pre></td></tr></table></figure>
<p><strong>默认路由</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">默认路由就是0.0.0.0/0，意思是实在没有其他路由了，就走这个路由了。</div></pre></td></tr></table></figure>
<p>在路由表中的优先级：<br><strong>精度越高，优先级越高</strong></p>
<hr>
<div class="note success"><h3 id="路由表构成"><a href="#路由表构成" class="headerlink" title="路由表构成"></a>路由表构成</h3></div>
<ol>
<li><p>目标网络:<br> 网络ID和子网掩码组成（网络路由）<br> <code>192.168.0.0/24</code><br> 或者<br> 目标是一个IP地址，<code>192,168,1.100</code>（主机路由）</p>
</li>
<li><p>接口<br> 数据包到达目标网络从路由器的哪个接口出来，就是这个接口。</p>
</li>
<li><p>网关<br> 下一个路由器的临近接口的IP地址（下一跳的地址），与出口IP地址在同一个网段。</p>
</li>
</ol>
<hr>
<div class="note info"><h3 id="route命令详解"><a href="#route命令详解" class="headerlink" title="route命令详解"></a>route命令详解</h3></div>
<h4 id="命令语法格式"><a href="#命令语法格式" class="headerlink" title="命令语法格式"></a>命令语法格式</h4><p><code>route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]]</code></p>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p><code>route</code>命令是用于操作基于内核IP路由表，它的主要作用是创建一个静态路由由让指定一个主机或者一个网络通过一个网络接口，如<code>eth0</code>。</p>
<p>当使用<code>add</code>或者<code>del</code>参数时，路由表被修改，如果没有参数，则显示路由表当前的内容。</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">-A          设置地址类型</div><div class="line">-C          打印将Linux核心的路由缓存 </div><div class="line">-v          详细信息模式</div><div class="line">-n          不执行DNS反向查找，直接显示数字形式的IP地址</div><div class="line"><span class="_">-e</span>          netstat格式显示路由表</div><div class="line">-net        到一个网络的路由表 </div><div class="line">-host       到一个主机的路由表</div><div class="line"></div><div class="line">Add：增加指定的路由记录</div><div class="line">Del：删除指定的路由记录</div><div class="line">Target：目的网络或目的主机</div><div class="line">gw：设置默认网关</div><div class="line">mss：设置TCP的最大区块长度（MSS），单位MB</div><div class="line">window：指定通过路由表的TCP连接的TCP窗口大小</div><div class="line">dev：路由记录所表示的网络接口</div></pre></td></tr></table></figure>
<h4 id="设置永久生效路由表"><a href="#设置永久生效路由表" class="headerlink" title="设置永久生效路由表"></a>设置永久生效路由表</h4><p>在<code>/etc/sysconfig/network-scripts/</code>目录下创建<code>route-IFACE</code>配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@maxie ~]<span class="comment"># vim /etc/sysconfig/network-scripts/route-eth0</span></div><div class="line">10.0.0.0/8 via 10.170.191.247 dev eth0</div><div class="line">100.64.0.0/10 via 10.170.191.247 dev eth0</div><div class="line">172.16.0.0/12 via 10.170.191.247 dev eth0</div></pre></td></tr></table></figure>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><strong>1、显示当前路由</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[root@maxie ~]<span class="comment"># route -n</span></div><div class="line">Kernel IP routing table</div><div class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</div><div class="line">0.0.0.0         123.56.103.247  0.0.0.0         UG    0      0        0 eth1</div><div class="line">10.0.0.0        10.170.191.247  255.0.0.0       UG    0      0        0 eth0</div><div class="line">10.170.184.0    0.0.0.0         255.255.248.0   U     0      0        0 eth0</div><div class="line">100.64.0.0      10.170.191.247  255.192.0.0     UG    0      0        0 eth0</div><div class="line">123.56.100.0    0.0.0.0         255.255.252.0   U     0      0        0 eth1</div><div class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0</div><div class="line">169.254.0.0     0.0.0.0         255.255.0.0     U     1003   0        0 eth1</div><div class="line">172.16.0.0      10.170.191.247  255.240.0.0     UG    0      0        0 eth0</div></pre></td></tr></table></figure>
<p>其中：</p>
<p>Destination：目标网络</p>
<p>Gateway：下一跳地址</p>
<p>Genmask：子网掩码</p>
<p>Flags：路由标志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">U：表示此路由为启动状态</div><div class="line">H：表示此网关为一主机</div><div class="line">G：表示此网关为一路由器</div><div class="line">R：使用动态路由重新初始化的路由</div><div class="line">!：表示此路由当前为关闭状态</div></pre></td></tr></table></figure>
<p>2、添加一条路由</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@maxie ~]<span class="comment"># route add -net 192.168.1.0/24 gw 123.56.100.148</span></div></pre></td></tr></table></figure>
<p>3、屏蔽一条路由</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[root@maxie ~]<span class="comment"># route add -net 192.168.1.0/24 reject</span></div><div class="line">[root@maxie ~]<span class="comment"># route</span></div><div class="line">Kernel IP routing table</div><div class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</div><div class="line">default         gateway         0.0.0.0         UG    0      0        0 eth1</div><div class="line">10.0.0.0        10.170.191.247  255.0.0.0       UG    0      0        0 eth0</div><div class="line">10.170.184.0    0.0.0.0         255.255.248.0   U     0      0        0 eth0</div><div class="line">100.64.0.0      10.170.191.247  255.192.0.0     UG    0      0        0 eth0</div><div class="line">123.56.100.0    0.0.0.0         255.255.252.0   U     0      0        0 eth1</div><div class="line">link-local      0.0.0.0         255.255.0.0     U     1002   0        0 eth0</div><div class="line">link-local      0.0.0.0         255.255.0.0     U     1003   0        0 eth1</div><div class="line">172.16.0.0      10.170.191.247  255.240.0.0     UG    0      0        0 eth0</div><div class="line">192.168.1.0     -               255.255.255.0   !     0      -        0 -</div><div class="line">192.168.1.0     maxie           255.255.255.0   UG    0      0        0 eth1</div></pre></td></tr></table></figure>
<p>4、删除一条路由记录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@maxie ~]<span class="comment"># route del -net 192.168.1.0/24</span></div><div class="line">[root@maxie ~]<span class="comment"># route del -net 192.168.1.0/24 reject</span></div></pre></td></tr></table></figure>
<hr>
<div class="note danger"><h3 id="实验：2台Linux主机通过3台路由器相同通信"><a href="#实验：2台Linux主机通过3台路由器相同通信" class="headerlink" title="实验：2台Linux主机通过3台路由器相同通信"></a>实验：2台Linux主机通过3台路由器相同通信</h3></div>
<p>现有2台Linux主机，以及3台路由器，要实现让两台Linux主机经过3台路由器后可以互相通信的功能。</p>
<h4 id="第一步，根据需求制作网络拓扑图"><a href="#第一步，根据需求制作网络拓扑图" class="headerlink" title="第一步，根据需求制作网络拓扑图"></a>第一步，根据需求制作网络拓扑图</h4><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1ff9msnpcm0j315k0kc3zi.jpg" alt=""></p>
<h4 id="第二步，配置两台Linux主机的IP以及关闭防火墙和其他环境配置"><a href="#第二步，配置两台Linux主机的IP以及关闭防火墙和其他环境配置" class="headerlink" title="第二步，配置两台Linux主机的IP以及关闭防火墙和其他环境配置"></a>第二步，配置两台Linux主机的IP以及关闭防火墙和其他环境配置</h4><p>这里Linux1和Linux2作为客户端（client）<br>Route1、2、3作为路由</p>
<p><strong>Linux1的配置：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">1、配置网卡信息</div><div class="line">$ vim /etc/sysconfig/network-scripts/ifcfg-ens33</div><div class="line">	IPADDR=172.16.0.2</div><div class="line">	PREFIX=16</div><div class="line">	GATEWAY=172.16.0.3</div><div class="line">	</div><div class="line">2、清空并关闭防火墙，设置开机不自启</div><div class="line">$ iptables -F</div><div class="line">$ service iptables stop 或者 systemctl stop firewalld.service</div><div class="line">$ chkconfig iptables off 或者 systemctl disable firewalld.service</div><div class="line">	</div><div class="line">3、route -n 查看路由表信息</div><div class="line">	</div><div class="line">4、重启网络</div><div class="line">$ service network restart 或者 systemctl restart network</div></pre></td></tr></table></figure>
<p>Linux2因为硬件软件配置与1相同，所以除IP地址不同外，其他设置都相同1的网卡信息</p>
<p>所以Linux2的IP地址配置如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ vim /etc/sysconfig/network-scripts/ifcfg-eth0</div><div class="line">	IPADDR=10.0.0.2</div><div class="line">	PREFIX=8</div><div class="line">	GATEWAY=10.0.0.3</div></pre></td></tr></table></figure>
<h4 id="第四步，配置router的信息以及环境"><a href="#第四步，配置router的信息以及环境" class="headerlink" title="第四步，配置router的信息以及环境"></a>第四步，配置router的信息以及环境</h4><p><strong>route1：与Linux1机器、route2直连</strong></p>
<p>eth0网卡连接Linux1<br>eth1网卡连接route2</p>
<p>配置信息如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">1、配置网卡信息</div><div class="line">vim /etc/sysconfig/network-scripts/ifcfg-eth0</div><div class="line">	IPADDR=172.16.0.3</div><div class="line">	PREFIX=16</div><div class="line">	GATEWAY=172.16.0.3</div><div class="line">	</div><div class="line">vim /etc/sysconfig/network-scripts/ifcfg-eth1</div><div class="line">	IPADDR=192.168.1.3</div><div class="line">	PREFIX=24</div><div class="line">	</div><div class="line">	</div><div class="line">2、关闭防火墙</div><div class="line">iptables -F</div><div class="line">service iptables stop</div><div class="line">chkconfig iptables off</div><div class="line">	</div><div class="line">	</div><div class="line">3、重启网卡</div><div class="line">service network restart</div></pre></td></tr></table></figure>
<p><strong>route2：与route1和route3直连</strong></p>
<p>eth0连接Route1<br>eth1连接Route3</p>
<p>配置信息如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">1、配置网卡信息</div><div class="line">vim /etc/sysconfig/network-scripts/ifcfg-eth0</div><div class="line">	IPADDR=192.168.1.4</div><div class="line">	PREFIX=24</div><div class="line">	</div><div class="line">vim /etc/sysconfig/network-scripts/ifcfg-eth1</div><div class="line">	IPADDR=192.168.2.4</div><div class="line">	PREFIX=24</div><div class="line">	</div><div class="line">2、关闭防火墙</div><div class="line">iptables -F</div><div class="line">service iptables stop</div><div class="line">chkconfig iptables off</div><div class="line">	</div><div class="line">3、重启网卡</div><div class="line">service network restart</div></pre></td></tr></table></figure>
<p><strong>route3：与linux2机器、route3直连</strong></p>
<p>eth0连接Route3<br>eth1连接Linux2</p>
<p>配置信息如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">1、配置网卡信息</div><div class="line">vim /etc/sysconfig/network-scripts/ifcfg-eth0</div><div class="line">	IPADDR=192.168.2.2</div><div class="line">	PREFIX=24</div><div class="line">	</div><div class="line">vim /etc/sysconfig/network-scripts/ifcfg-eth1</div><div class="line">	IPADDR=10.0.0.3</div><div class="line">	PREFIX=8</div><div class="line">	GATEWAY=10.0.0.3	</div><div class="line">	</div><div class="line">2、关闭防火墙</div><div class="line">iptables -F</div><div class="line">service iptables stop</div><div class="line">chkconfig iptables off</div><div class="line">	</div><div class="line">	</div><div class="line">3、重启网卡</div><div class="line">service network restart</div></pre></td></tr></table></figure>
<h4 id="配置各router的路由表信息"><a href="#配置各router的路由表信息" class="headerlink" title="配置各router的路由表信息"></a>配置各router的路由表信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">Route1：</div><div class="line">	</div><div class="line">不做路由的情况下可以访问172.16.0.0/16以及192.168.1.0/24这两个网络内的IP地址</div><div class="line">	</div><div class="line">所以我们需要做两个网络的路由，也就是192.168.2.0/24和10.0.0.0/8这两个网络的路由</div><div class="line">	</div><div class="line">所以Route1的路由表就是：</div><div class="line">	</div><div class="line">	192.168.2.0/24 gw 192.168.1.4 dev eth1</div><div class="line">	10.0.0.0/8 gw 192.168.1.4 dev eth1</div><div class="line">	</div><div class="line">配置之前需要开启路由转发功能：</div><div class="line">	cat /proc/sys/net/ipv4/ip_forward</div><div class="line">	<span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</div><div class="line">	</div><div class="line">使用route命令进行配置路由表：</div><div class="line">	route add -net 192.168.2.0/24 gw 192.168.1.4 dev eth1</div><div class="line">	route add -net 10.0.0.0/8 gw 192.168.1.4 dev eth1</div><div class="line">	</div><div class="line">查看是否配置成功：</div><div class="line">	route -n</div><div class="line">	</div><div class="line">测试ping：由于route2没有配置路由转发功能，目前我们只能ping通route2的192.168.2.4这张网卡的地址</div><div class="line">	</div><div class="line">	ping 192.168.2.4</div><div class="line">	</div><div class="line">	</div><div class="line">---------------------------------------</div><div class="line">	</div><div class="line">Route2：</div><div class="line">	</div><div class="line">不做路由的情况下可以访问192.168.2.0/24以及192.168.1.0/24这两个网络内的IP地址</div><div class="line">	</div><div class="line">所以我们需要做两个网络的路由，也就是172.16.0.0/16和10.0.0.0/8这两个网络的路由</div><div class="line">	</div><div class="line">所以Route2的路由表就是：</div><div class="line">	</div><div class="line">	172.16.0.0/16 gw 192.168.1.4 dev eth0</div><div class="line">	10.0.0.0/8 gw 192.168.2.4 dev eth1</div><div class="line">	</div><div class="line">配置之前需要开启路由转发功能：</div><div class="line">	cat /proc/sys/net/ipv4/ip_forward</div><div class="line">	<span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</div><div class="line">	</div><div class="line">使用route命令进行配置路由表：</div><div class="line">	route add -net 172.16.0.0/16 gw 192.168.1.3 dev eth0</div><div class="line">	route add -net 10.0.0.0/8 gw 192.168.2.2 dev eth1</div><div class="line">	</div><div class="line">查看是否配置成功：</div><div class="line">	route -n</div><div class="line">	</div><div class="line">测试ping：由于route3没有配置路由转发功能，目前我们只能ping通route3的10.0.0.3这张网卡的地址和route1的两张网卡地址以及Linux1的地址</div><div class="line">	</div><div class="line">	ping 10.0.0.3</div><div class="line">	ping 172.16.0.3</div><div class="line">	ping 172.16.0.2</div><div class="line">	</div><div class="line">	</div><div class="line">-----------------------------------------------</div><div class="line">	</div><div class="line">	</div><div class="line">	</div><div class="line">Route3：</div><div class="line">	</div><div class="line">不做路由的情况下可以访问10.0.0.0/8以及192.168.2.0/24这两个网络内的IP地址</div><div class="line">	</div><div class="line">所以我们需要做两个网络的路由，也就是192.168.1.0/24和172.16.0.0/16这两个网络的路由</div><div class="line">	</div><div class="line"></div><div class="line">所以Route3的路由表就是：</div><div class="line">	</div><div class="line">	192.168.1.0/24 gw 192.168.2.4 dev eth0</div><div class="line">	172.16.0.0/16 gw 192.168.2.4 dev eth0</div><div class="line">	</div><div class="line">配置之前需要开启路由转发功能：</div><div class="line">	cat /proc/sys/net/ipv4/ip_forward</div><div class="line">	<span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</div><div class="line">	</div><div class="line">使用route命令进行配置路由表：</div><div class="line">	route add -net 192.168.1.0/24 gw 192.168.2.4 dev eth0</div><div class="line">	route add -net 172.16.0.0/16 gw 192.168.2.4 dev eth0</div><div class="line">	</div><div class="line">查看是否配置成功：</div><div class="line">    route -n</div><div class="line">	</div><div class="line">测试ping：现在，Linux1到Linux2的所有路由都已配置完毕，所以我们可以ping通拓扑图内的所有IP地址</div></pre></td></tr></table></figure>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29550185&auto=1&height=66"></iframe>

<p>本文出自<a href="http://maxiecloud.com" target="_blank" rel="external">Maxie’s Notes</a>博客，转载请务必保留此出处。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;Linux系统的route命令用于显示和操作IP路由表&lt;br&gt;&lt;br&gt;要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。&lt;br&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;在Linux系统中，设置路由通常是为了解决以下问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的IP地址设置为Linux机器的默认路由。&lt;/p&gt;
&lt;p&gt;要注意的是，直接在命令行执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了。&lt;/p&gt;
&lt;p&gt;可以在&lt;code&gt;/etc/sysconfig/network-scripts/&lt;/code&gt;目录下创建&lt;code&gt;route-IFACE&lt;/code&gt;类似的配置文件。&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;IFACE&lt;/code&gt;的名字不是很重要，起一个能够辨识其功能的名字即可。&lt;/p&gt;
    
    </summary>
    
      <category term="linux网络配置" scheme="http://yoursite.com/categories/linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="command" scheme="http://yoursite.com/tags/command/"/>
    
      <category term="route" scheme="http://yoursite.com/tags/route/"/>
    
  </entry>
  
  <entry>
    <title>磁盘配额(Quota)详解</title>
    <link href="http://yoursite.com/2017/04/30/disk-quota/"/>
    <id>http://yoursite.com/2017/04/30/disk-quota/</id>
    <published>2017-04-30T05:00:59.000Z</published>
    <updated>2017-04-30T07:17:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">Quota这个配额，字面上的意思来看就是有多少“限额”的意思。<br>如果是在计算机主机的磁盘使用量上呢？<br>以Linux来说，就是有多少容量限制的意思。<br>我们可以使用quota来限制Linux中用户或者组对磁盘的使用。<br></blockquote>

<p><strong>Quota的一般用途</strong></p>
<p><code>quota</code> 比较常使用的几个情况是：</p>
<ul>
<li>针对 WWW server，例如对每个人的网页空间的容量限制</li>
<li>针对 mail server，例如对每个人的邮件空间限制。</li>
<li>针对 ftp server，例如对每个人的最大可用网络共享空间的限制。</li>
</ul>
<p>上面主要介绍了一些针对网络服务的设计。</p>
<p>下面是针对Linux系统主机上面的设置：</p>
<ul>
<li>限制某一群组所能使用的最大磁盘限额（使用grpquota）</li>
<li>限制某一使用者的最大磁盘限额（使用usrquota）</li>
<li>限制某一目录的最大磁盘配额：针对旧版CentOS来说，就是以挂载点的方式进行限制，<code>xfs</code>文件系统的限制方法使用project这种模式，不过在此文章内先不介绍。</li>
</ul>
<p><code>quota</code>的用途大概就是这些了。</p>
<a id="more"></a>
<div class="note primary"><h2 id="Quota的规范设置项目"><a href="#Quota的规范设置项目" class="headerlink" title="Quota的规范设置项目"></a>Quota的规范设置项目</h2></div>
<p><code>quota</code>针对文件系统的限制主要分为下面几个部分：</p>
<ul>
<li>容量限制或文件数量限制（block或inode）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">限制inode用量：可以管理使用者可创建的“文件数量”</div><div class="line">限制block数量：管理使用者磁盘容量的限制，大多时候使用这种方式</div></pre></td></tr></table></figure>
<ul>
<li>柔性劝导与硬性规定（soft/hard）</li>
</ul>
<p>既然是规范，当然就有限制值。不管是 inode/block ，限制值都有两个，分别是 soft 与 hard。 通常 hard 限制值要比 soft 还要高。举例来说，若限制项目为 block ，可以限制 hard 为 500MBytes 而 soft 为 400MBytes。这两个限值的意义为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hard：表示使用者的用量绝对不会超过这个限制值，以上面的设置为例，使用者所能使用的磁盘容量绝对不会超过500MBytes，若超过这个值则系统会锁住该用户的磁盘使用权</div><div class="line">soft：表示使用者在低于 soft 限值时 （此例中为 400MBytes），可以正常使用磁盘，但若超过 soft 且低于 hard 的限值 （介于 400~500MBytes 之间时），每次使用者登陆系统时，系统会主动发出磁盘即将爆满的警告讯息， 且会给予一个宽限时间 （grace time）。</div></pre></td></tr></table></figure>
<ul>
<li>宽限时间（grace time）</li>
</ul>
<p>刚刚上面就谈到宽限时间了！这个宽限时间只有在使用者的磁盘用量介于 soft 到 hard 之间时，才会出现且会倒数的一个咚咚！ 由于达到 hard 限值时，使用者的磁盘使用权可能会被锁住。为了担心使用者没有注意到这个磁盘配额的问题， 因此设计了 soft 。当你的磁盘用量即将到达 hard 且超过 soft 时，系统会给予警告，但也会给一段时间让使用者自行管理磁盘。 一般默认的宽限时间为七天，如果七天内你都不进行任何磁盘管理，那么 soft 限制值会即刻取代 hard 限值来作为 quota 的限制。</p>
<p>以上面设置的例子来说，假设你的容量高达 450MBytes 了，那七天的宽限时间就会开始倒数， 若七天内你都不进行任何删除文件的动作来替你的磁盘用量瘦身， 那么七天后你的磁盘最大用量将变成 400MBytes （那个 soft 的限制值），此时你的磁盘使用权就会被锁住而无法新增文件了。</p>
<hr>
<div class="note success"><h2 id="一个EXT3文件系统的Quota实作范例"><a href="#一个EXT3文件系统的Quota实作范例" class="headerlink" title="一个EXT3文件系统的Quota实作范例"></a>一个EXT3文件系统的Quota实作范例</h2></div>
<p>坐而言不如起而行，所以这里我们使用一个范例来设计一下如何处理Quota的设置流程。</p>
<ol>
<li>目的与账号：限制我想要让3个用户在一个组中。这3个用户分别是：maxie1，maxie2，maxie3，三个用户的密码都是123456，同属于myquotagrp这个组。</li>
<li>账号的磁盘容量限制值：让3个用户都能够得到100MBytes的磁盘使用量（hard），文件数量不予限制。此外，只要容量超过80MBytes，就予以警告（soft）</li>
<li>群组的限制：让群组内的用户只能使用200MBytes的容量。也就是说，如果有2个用户都使用了80MBytes时，最后一个用户只能使用（200-80*2=40MBytes）的磁盘容量了。</li>
</ol>
<h3 id="第一步，先让我们将账号的相关属性、参数和其他环境搞定好再说吧！"><a href="#第一步，先让我们将账号的相关属性、参数和其他环境搞定好再说吧！" class="headerlink" title="第一步，先让我们将账号的相关属性、参数和其他环境搞定好再说吧！"></a>第一步，先让我们将账号的相关属性、参数和其他环境搞定好再说吧！</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 由于需要设置的账号和环境较多，我们这里使用 script 来创建环境</span></div><div class="line"></div><div class="line">[root@centos7 ~]<span class="comment"># vim addcount.sh</span></div><div class="line"><span class="comment">#创建所需的组</span></div><div class="line">groupadd myquotagrp</div><div class="line"></div><div class="line"><span class="comment">#创建3个实验用户</span></div><div class="line"><span class="keyword">for</span> username <span class="keyword">in</span> maxie1 maxie2 maxie3</div><div class="line"><span class="keyword">do</span></div><div class="line">        useradd -g myquotagrp <span class="variable">$username</span></div><div class="line">        <span class="built_in">echo</span> <span class="string">"123456"</span> | passwd --stdin <span class="variable">$username</span></div><div class="line"><span class="keyword">done</span></div><div class="line"></div><div class="line">mkdir /mnt/myquota</div><div class="line"></div><div class="line">[root@centos7 ~]<span class="comment"># sh addcount.sh</span></div><div class="line"></div><div class="line">检查是否执行成功：</div><div class="line">root@centos7 ~]<span class="comment"># id maxie1</span></div><div class="line">uid=1001(maxie1) gid=1001(myquotagrp) 组=1001(myquotagrp)</div><div class="line">[root@centos7 ~]<span class="comment"># id maxie2</span></div><div class="line">uid=1002(maxie2) gid=1001(myquotagrp) 组=1001(myquotagrp)</div><div class="line">[root@centos7 ~]<span class="comment"># id maxie3</span></div><div class="line">uid=1003(maxie3) gid=1001(myquotagrp) 组=1001(myquotagrp)</div></pre></td></tr></table></figure>
<h3 id="第二步创建文件系统并挂载至-mnt-myquota"><a href="#第二步创建文件系统并挂载至-mnt-myquota" class="headerlink" title="第二步创建文件系统并挂载至/mnt/myquota"></a>第二步创建文件系统并挂载至/mnt/myquota</h3><p>先使用之前学过的<code>fdisk</code>命令创建一个分区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">[root@centos7 ~]<span class="comment"># fdisk /dev/sdb</span></div><div class="line">欢迎使用 fdisk (util-linux 2.23.2)。</div><div class="line"></div><div class="line">更改将停留在内存中，直到您决定将更改写入磁盘。</div><div class="line">使用写入命令前请三思。</div><div class="line"></div><div class="line">Device does not contain a recognized partition table</div><div class="line">使用磁盘标识符 0x38b1700d 创建新的 DOS 磁盘标签。</div><div class="line"></div><div class="line">The device presents a logical sector size that is smaller than</div><div class="line">the physical sector size. Aligning to a physical sector (or optimal</div><div class="line">I/O) size boundary is recommended, or performance may be impacted.</div><div class="line"></div><div class="line">命令(输入 m 获取帮助)：n</div><div class="line">Partition <span class="built_in">type</span>:</div><div class="line">   p   primary (0 primary, 0 extended, 4 free)</div><div class="line">   e   extended</div><div class="line">Select (default p): p</div><div class="line">分区号 (1-4，默认 1)：</div><div class="line">起始 扇区 (2048-209715199，默认为 2048)：</div><div class="line">将使用默认值 2048</div><div class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2048-209715199，默认为 209715199)：+10G</div><div class="line">分区 1 已设置为 Linux 类型，大小设为 10 GiB</div><div class="line"></div><div class="line">命令(输入 m 获取帮助)：p</div><div class="line"></div><div class="line">磁盘 /dev/sdb：107.4 GB, 107374182400 字节，209715200 个扇区</div><div class="line">Units = 扇区 of 1 * 512 = 512 bytes</div><div class="line">扇区大小(逻辑/物理)：512 字节 / 4096 字节</div><div class="line">I/O 大小(最小/最佳)：4096 字节 / 4096 字节</div><div class="line">磁盘标签类型：dos</div><div class="line">磁盘标识符：0x38b1700d</div><div class="line"></div><div class="line">   设备 Boot      Start         End      Blocks   Id  System</div><div class="line">/dev/sdb1            2048    20973567    10485760   83  Linux</div><div class="line"></div><div class="line">命令(输入 m 获取帮助)：w</div><div class="line">The partition table has been altered!</div><div class="line"></div><div class="line">Calling ioctl() to re-read partition table.</div><div class="line">正在同步磁盘。</div><div class="line">[root@centos7 ~]<span class="comment"># lsblk</span></div><div class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</div><div class="line">sda      8:0    0  100G  0 disk</div><div class="line">├─sda1   8:1    0  500M  0 part /boot</div><div class="line">├─sda2   8:2    0   40G  0 part /</div><div class="line">├─sda3   8:3    0   20G  0 part /usr</div><div class="line">├─sda4   8:4    0    1K  0 part</div><div class="line">├─sda5   8:5    0    2G  0 part [SWAP]</div><div class="line">├─sda6   8:6    0    1M  0 part</div><div class="line">├─sda7   8:7    0    1G  0 part /data</div><div class="line">└─sda8   8:8    0   10G  0 part</div><div class="line">sdb      8:16   0  100G  0 disk</div><div class="line">└─sdb1   8:17   0   10G  0 part</div></pre></td></tr></table></figure>
<p>格式化分区，创建文件系统</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">[root@centos7 ~]<span class="comment"># mkfs.ext4 /dev/sdb1</span></div><div class="line">mke2fs 1.42.9 (28-Dec-2013)</div><div class="line">Discarding device blocks: 完成</div><div class="line">文件系统标签=</div><div class="line">OS <span class="built_in">type</span>: Linux</div><div class="line">块大小=4096 (<span class="built_in">log</span>=2)</div><div class="line">分块大小=4096 (<span class="built_in">log</span>=2)</div><div class="line">Stride=0 blocks, Stripe width=0 blocks</div><div class="line">655360 inodes, 2621440 blocks</div><div class="line">131072 blocks (5.00%) reserved <span class="keyword">for</span> the super user</div><div class="line">第一个数据块=0</div><div class="line">Maximum filesystem blocks=2151677952</div><div class="line">80 block groups</div><div class="line">32768 blocks per group, 32768 fragments per group</div><div class="line">8192 inodes per group</div><div class="line">Superblock backups stored on blocks:</div><div class="line">	32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632</div><div class="line"></div><div class="line">Allocating group tables: 完成</div><div class="line">正在写入inode表: 完成</div><div class="line">Creating journal (32768 blocks): 完成</div><div class="line">Writing superblocks and filesystem accounting information: 完成</div></pre></td></tr></table></figure>
<p>挂载分区至/mnt/myquota下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@centos7 ~]<span class="comment"># mount /dev/sdb1 /mnt/myquota/</span></div><div class="line">[root@centos7 ~]<span class="comment"># vim /etc/fstab</span></div><div class="line">UID=<span class="string">"485c4a7c-dd90-40c3-8fd4-164888a0ff67"</span> /mnt/myquota ext4 defaults,usrquota,grpquota 0 0</div><div class="line">[root@centos7 ~]<span class="comment"># mount -o remount /dev/sdb1</span></div></pre></td></tr></table></figure>
<h3 id="第三步开始配置磁盘配额"><a href="#第三步开始配置磁盘配额" class="headerlink" title="第三步开始配置磁盘配额"></a>第三步开始配置磁盘配额</h3><p>进入<code>/mnt/myquota</code>目录下开始设置磁盘配额：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[root@centos7 ~]<span class="comment"># cd /mnt/myquota/</span></div><div class="line"></div><div class="line">禁用SElinux</div><div class="line">[root@centos7 myquota]<span class="comment"># setenforce 0</span></div><div class="line">[root@centos7 myquota]<span class="comment"># getenforce</span></div><div class="line">Disabled</div><div class="line"></div><div class="line">创建磁盘配额数据库</div><div class="line">[root@centos7 myquota]<span class="comment"># quotacheck -cug /mnt/myquota/</span></div><div class="line">[root@centos7 myquota]<span class="comment"># ll</span></div><div class="line">总用量 32</div><div class="line">-rw------- 1 root root  6144 4月  28 19:59 aquota.group</div><div class="line">-rw------- 1 root root  6144 4月  28 19:59 aquota.user</div><div class="line">drwx------ 2 root root 16384 4月  28 19:52 lost+found</div></pre></td></tr></table></figure>
<p>启动磁盘配额数据库:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@centos7 myquota]<span class="comment"># quotaon /mnt/myquota/</span></div><div class="line">[root@centos7 myquota]<span class="comment"># quotaon -p /mnt/myquota/</span></div><div class="line">group quota on /mnt/myquota (/dev/sdb1) is on</div><div class="line">user quota on /mnt/myquota (/dev/sdb1) is on</div></pre></td></tr></table></figure>
<p>开始对之前创建的用户和组进行磁盘配额设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[root@centos7 myquota]<span class="comment"># edquota maxie1</span></div><div class="line">Disk quotas <span class="keyword">for</span> user maxie1 (uid 1001):</div><div class="line">  Filesystem                   blocks       soft       hard     inodes     soft     hard</div><div class="line">  /dev/sdb1                         0      81920     102400          0        0        0</div><div class="line"></div><div class="line">通过-p选项，直接复制maxie1的配置信息，作为其他两个用户的磁盘配额配置信息：</div><div class="line">[root@centos7 myquota]<span class="comment"># edquota -p maxie1 maxie2</span></div><div class="line">[root@centos7 myquota]<span class="comment"># edquota -p maxie1 maxie3</span></div><div class="line"></div><div class="line">创建对组的磁盘配额：</div><div class="line">[root@centos7 myquota]<span class="comment"># edquota -g myquotagrp</span></div><div class="line">Disk quotas <span class="keyword">for</span> group myquotagrp (gid 1001):</div><div class="line">  Filesystem                   blocks       soft       hard     inodes     soft     hard</div><div class="line">  /dev/sdb1                         0          0     204800          0        0        0</div></pre></td></tr></table></figure>
<h3 id="第四步，测试磁盘配额"><a href="#第四步，测试磁盘配额" class="headerlink" title="第四步，测试磁盘配额"></a>第四步，测试磁盘配额</h3><p>修改/mnt/myquota目录的权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@centos7 mnt]<span class="comment"># chmod 777 myquota/</span></div></pre></td></tr></table></figure>
<ul>
<li>测试用户磁盘配额</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">maxie1@centos7 myquota]$ <span class="built_in">pwd</span></div><div class="line">/mnt/myquota</div><div class="line">[maxie1@centos7 myquota]$ dd <span class="keyword">if</span>=/dev/zero of=maxie1file bs=1M count=50</div><div class="line">记录了50+0 的读入</div><div class="line">记录了50+0 的写出</div><div class="line">52428800字节(52 MB)已复制，0.0307593 秒，1.7 GB/秒</div><div class="line">[maxie1@centos7 myquota]$ ll -h</div><div class="line">总用量 51M</div><div class="line">-rw------- 1 root   root       7.0K 4月  28 19:59 aquota.group</div><div class="line">-rw------- 1 root   root       7.0K 4月  28 19:59 aquota.user</div><div class="line">drwx------ 2 root   root        16K 4月  28 19:52 lost+found</div><div class="line">-rw-r--r-- 1 maxie1 myquotagrp  50M 4月  28 20:17 maxie1file</div><div class="line">[maxie1@centos7 myquota]$ dd <span class="keyword">if</span>=/dev/zero of=maxie1file bs=1M count=81</div><div class="line">sdb1: warning, user block quota exceeded.</div><div class="line">记录了81+0 的读入</div><div class="line">记录了81+0 的写出</div><div class="line">84934656字节(85 MB)已复制，0.0545585 秒，1.6 GB/秒</div><div class="line">[maxie1@centos7 myquota]$ dd <span class="keyword">if</span>=/dev/zero of=maxie1file bs=1M count=101</div><div class="line">sdb1: warning, user block quota exceeded.</div><div class="line">sdb1: write failed, user block <span class="built_in">limit</span> reached.</div><div class="line">dd: 写入<span class="string">"maxie1file"</span> 出错: 超出磁盘限额</div><div class="line">记录了101+0 的读入</div><div class="line">记录了100+0 的写出</div><div class="line">104857600字节(105 MB)已复制，0.0665764 秒，1.6 GB/秒</div><div class="line">[maxie1@centos7 myquota]$ ll -h</div><div class="line">总用量 101M</div><div class="line">-rw------- 1 root   root       7.0K 4月  28 19:59 aquota.group</div><div class="line">-rw------- 1 root   root       7.0K 4月  28 19:59 aquota.user</div><div class="line">drwx------ 2 root   root        16K 4月  28 19:52 lost+found</div><div class="line">-rw-r--r-- 1 maxie1 myquotagrp 100M 4月  28 20:17 maxie1file</div></pre></td></tr></table></figure>
<ul>
<li>测试组的磁盘配额：</li>
</ul>
<p>先使用maxie1和maxie2用户在目录中各创建一个80MBytes的文件，再切换到maxie3用户测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">[maxie1@centos7 myquota]$ su maxie2</div><div class="line">密码：</div><div class="line">[maxie2@centos7 myquota]$ dd <span class="keyword">if</span>=/dev/zero of=maxie1file2 bs=1M count=80</div><div class="line">记录了80+0 的读入</div><div class="line">记录了80+0 的写出</div><div class="line">83886080字节(84 MB)已复制，0.0498647 秒，1.7 GB/秒</div><div class="line">[maxie2@centos7 myquota]$ ll -h</div><div class="line">总用量 161M</div><div class="line">-rw------- 1 root   root       7.0K 4月  28 19:59 aquota.group</div><div class="line">-rw------- 1 root   root       7.0K 4月  28 19:59 aquota.user</div><div class="line">drwx------ 2 root   root        16K 4月  28 19:52 lost+found</div><div class="line">-rw-r--r-- 1 maxie1 myquotagrp  80M 4月  28 20:19 maxie1file</div><div class="line">-rw-r--r-- 1 maxie2 myquotagrp  80M 4月  28 20:20 maxie1file2</div><div class="line"></div><div class="line"><span class="comment">#切换到maxie3，测试组的磁盘配额限制</span></div><div class="line">[maxie2@centos7 myquota]$ su maxie3</div><div class="line">密码：</div><div class="line">[maxie3@centos7 myquota]$ dd <span class="keyword">if</span>=/dev/zero of=filemaxie3 bs=1M count=30</div><div class="line">30+0 records <span class="keyword">in</span></div><div class="line">30+0 records out</div><div class="line">31457280 bytes (31 MB) copied, 0.0162361 s, 1.9 GB/s</div><div class="line"></div><div class="line">[maxie3@centos7 myquota]$ ll -h</div><div class="line">total 191M</div><div class="line">-rw------- 1 root   root       7.0K Apr 28 19:59 aquota.group</div><div class="line">-rw------- 1 root   root       7.0K Apr 28 19:59 aquota.user</div><div class="line">-rw-r--r-- 1 maxie3 myquotagrp  30M Apr 28 20:22 filemaxie3</div><div class="line">drwx------ 2 root   root        16K Apr 28 19:52 lost+found</div><div class="line">-rw-r--r-- 1 maxie1 myquotagrp  80M Apr 28 20:19 maxie1file</div><div class="line">-rw-r--r-- 1 maxie2 myquotagrp  80M Apr 28 20:20 maxie1file2</div><div class="line"></div><div class="line">[maxie3@centos7 myquota]$ du -sh .</div><div class="line">191M	.</div><div class="line"></div><div class="line">[maxie3@centos7 myquota]$ dd <span class="keyword">if</span>=/dev/zero of=filemaxie3 bs=1M count=40</div><div class="line">40+0 records <span class="keyword">in</span></div><div class="line">40+0 records out</div><div class="line">41943040 bytes (42 MB) copied, 0.0265194 s, 1.6 GB/s</div><div class="line"></div><div class="line">[maxie3@centos7 myquota]$ dd <span class="keyword">if</span>=/dev/zero of=filemaxie3 bs=1M count=50</div><div class="line">sdb1: write failed, group block <span class="built_in">limit</span> reached.</div><div class="line">dd: error writing ‘filemaxie3’: Disk quota exceeded</div><div class="line">41+0 records <span class="keyword">in</span></div><div class="line">40+0 records out</div><div class="line">41943040 bytes (42 MB) copied, 0.027217 s, 1.5 GB/s</div><div class="line"></div><div class="line">[maxie3@centos7 myquota]$ ll -h</div><div class="line">total 201M</div><div class="line">-rw------- 1 root   root       7.0K Apr 28 19:59 aquota.group</div><div class="line">-rw------- 1 root   root       7.0K Apr 28 19:59 aquota.user</div><div class="line">-rw-r--r-- 1 maxie3 myquotagrp  40M Apr 28 20:23 filemaxie3</div><div class="line">drwx------ 2 root   root        16K Apr 28 19:52 lost+found</div><div class="line">-rw-r--r-- 1 maxie1 myquotagrp  80M Apr 28 20:19 maxie1file</div><div class="line">-rw-r--r-- 1 maxie2 myquotagrp  80M Apr 28 20:20 maxie1file2</div><div class="line">[maxie3@centos7 myquota]$ du -sh .</div><div class="line">201M	.</div></pre></td></tr></table></figure>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=16714264&auto=1&height=66"></iframe>

<p>本文出自<a href="http://maxiecloud.com" target="_blank" rel="external">Maxie’s Notes</a>博客，转载请务必保留此出处。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;Quota这个配额，字面上的意思来看就是有多少“限额”的意思。&lt;br&gt;如果是在计算机主机的磁盘使用量上呢？&lt;br&gt;以Linux来说，就是有多少容量限制的意思。&lt;br&gt;我们可以使用quota来限制Linux中用户或者组对磁盘的使用。&lt;br&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Quota的一般用途&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;quota&lt;/code&gt; 比较常使用的几个情况是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;针对 WWW server，例如对每个人的网页空间的容量限制&lt;/li&gt;
&lt;li&gt;针对 mail server，例如对每个人的邮件空间限制。&lt;/li&gt;
&lt;li&gt;针对 ftp server，例如对每个人的最大可用网络共享空间的限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面主要介绍了一些针对网络服务的设计。&lt;/p&gt;
&lt;p&gt;下面是针对Linux系统主机上面的设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;限制某一群组所能使用的最大磁盘限额（使用grpquota）&lt;/li&gt;
&lt;li&gt;限制某一使用者的最大磁盘限额（使用usrquota）&lt;/li&gt;
&lt;li&gt;限制某一目录的最大磁盘配额：针对旧版CentOS来说，就是以挂载点的方式进行限制，&lt;code&gt;xfs&lt;/code&gt;文件系统的限制方法使用project这种模式，不过在此文章内先不介绍。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;quota&lt;/code&gt;的用途大概就是这些了。&lt;/p&gt;
    
    </summary>
    
      <category term="linux磁盘管理" scheme="http://yoursite.com/categories/linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="disk" scheme="http://yoursite.com/tags/disk/"/>
    
      <category term="quota" scheme="http://yoursite.com/tags/quota/"/>
    
  </entry>
  
  <entry>
    <title>dd命令详解</title>
    <link href="http://yoursite.com/2017/04/27/dd-command/"/>
    <id>http://yoursite.com/2017/04/27/dd-command/</id>
    <published>2017-04-27T07:15:28.000Z</published>
    <updated>2017-04-27T08:36:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">dd命令可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。<br>dd命令非常强大，让我们一起来学习吧！<br></blockquote>



<h2 id="dd命令"><a href="#dd命令" class="headerlink" title="dd命令"></a>dd命令</h2><div class="note primary"><h3 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h3></div>
<p>dd [OPERAND]…<br>dd OPTION</p>
<a id="more"></a>
<hr>
<div class="note success"><h3 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h3></div>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>=文件名          输入文件名，缺省为标准输入。即指定源文件。</div><div class="line">of=文件名          输出文件名，缺省为标准输出。即指定目的文件。</div><div class="line">ibs=bytes         一次读入bytes个字节，即指定一个块大小为bytes个字节。</div><div class="line">obs=bytes         一次输出bytes个字节，即指定一个块大小为bytes个字节。</div><div class="line">bs=bytes          同时设置读入/输出的块大小为bytes个字节。</div><div class="line">cbs=bytes         一次转换bytes个字节，即指定转换缓冲区大小。</div><div class="line">skip=blocks       从输入文件开头跳过blocks个块后再开始复制。</div><div class="line">seek=blocks       从输出文件开头跳过blocks个块后再开始复制。</div><div class="line">count=blocks      仅拷贝blocks个块，块大小等于ibs指定的字节数。</div></pre></td></tr></table></figure>
<p><strong>其中的关键字用法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">conv=&lt;关键字&gt;，关键字可以有以下11种：</div><div class="line">conversion      用指定的参数转换文件。</div><div class="line">ascii           转换ebcdic为ascii</div><div class="line">ebcdic          转换ascii为ebcdic</div><div class="line">ibm             转换ascii为alternate ebcdic</div><div class="line">block           把每一行转换为长度为cbs，不足部分用空格填充</div><div class="line">unblock         使每一行的长度都为cbs，不足部分用空格填充</div><div class="line">lcase           把大写字符转换为小写字符</div><div class="line">ucase           把小写字符转换为大写字符</div><div class="line">swab            交换输入的每对字节</div><div class="line">noerror         出错时不停止</div><div class="line">notrunc         不截短输出文件</div><div class="line">sync            将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。</div><div class="line">--help          显示帮助信息</div><div class="line">--version       显示版本信息</div></pre></td></tr></table></figure>
<hr>
<div class="note info"><h3 id="dd命令提供的各种功能"><a href="#dd命令提供的各种功能" class="headerlink" title="dd命令提供的各种功能"></a>dd命令提供的各种功能</h3></div>
<p><strong>备份</strong></p>
<p>使用dd命令，可以将一个磁盘上的数据整个的备份到另一个磁盘上。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dd <span class="keyword">if</span>=/dev/sdx of=/dev/sdy</div><div class="line">将本地的/dev/sdx整盘备份到/dev/sdy</div><div class="line"></div><div class="line">dd <span class="keyword">if</span>=/dev/sdx of=/path/to/image</div><div class="line">将/dev/sdx全盘数据备份到指定路径的image文件</div><div class="line"></div><div class="line">dd <span class="keyword">if</span>=/dev/sdx | gzip &gt;/path/to/image.gz</div><div class="line">备份/dev/sdx全盘数据，并利用gzip工具进行压缩，保存到指定路径</div></pre></td></tr></table></figure>
<p><strong>恢复</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dd <span class="keyword">if</span>=/path/to/image of=/dev/sdx</div><div class="line">将备份文件恢复到指定盘</div><div class="line"></div><div class="line">gzip -dc /path/to/image.gz | dd of=/dev/sdx</div><div class="line">将压缩的备份文件恢复到指定盘</div></pre></td></tr></table></figure>
<p><strong>拷贝内存资料到硬盘</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dd <span class="keyword">if</span>=/dev/mem of=/root/mem.bin bs=1024</div><div class="line">将内存里的数据拷贝到root目录下的mem.bin文件</div></pre></td></tr></table></figure>
<p><strong>从光盘拷贝iso镜像</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dd <span class="keyword">if</span>=/dev/cdrom of=/root/cd.iso</div><div class="line">拷贝光盘数据到root文件夹下，并保存为cd.iso文件</div></pre></td></tr></table></figure>
<p><strong>销毁磁盘数据</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dd <span class="keyword">if</span>=/dev/urandom of=/dev/sda1</div><div class="line">利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据，执行此操作以后，/dev/sda1将无法挂载，创建和拷贝操作无法执行</div></pre></td></tr></table></figure>
<p><strong>测试硬盘读写速度</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dd <span class="keyword">if</span>=/dev/zero of=/root/1Gb.file bs=1024 count=1000000</div><div class="line">dd <span class="keyword">if</span>=/root/1Gb.file bs=64k | dd of=/dev/null</div><div class="line">通过上两个命令输出的执行时间，可以计算出测试硬盘的写/读／速度</div></pre></td></tr></table></figure>
<p><strong>修复硬盘</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dd <span class="keyword">if</span>=/dev/sda of=/dev/sda</div><div class="line">当硬盘较长时间（比如1,2年）放置不使用后，磁盘上会产生消磁点。当磁头读到这些区域时会遇到困难，并可能导致I/O错误。当这种情况影响到硬盘的第一个扇区时，可能导致硬盘报废。上边的命令有可能使这些数据起死回生,且这个过程是安全高效的</div></pre></td></tr></table></figure>
<hr>
<div class="note danger"><h3 id="使用dd命令制作USB启动盘"><a href="#使用dd命令制作USB启动盘" class="headerlink" title="使用dd命令制作USB启动盘"></a>使用dd命令制作USB启动盘</h3></div>
<ul>
<li>第一步，格式化U盘，为了格式化我们首先需要umount U盘：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo fdisk <span class="_">-l</span></div></pre></td></tr></table></figure>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1ff1bbawpirj30hw08vq4z.jpg" alt=""></p>
<p>使用上面命令我们可以查看到,<code>/dev/sdb</code>是我的U盘设备</p>
<p>下面让我们<code>umount</code> U盘，并格式化：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo umount /dev/sdb</div><div class="line">$ sudo mkfs.vfat /dev/sdb -I</div></pre></td></tr></table></figure>
<p>我们把U盘格式化成了<code>FAT</code>格式</p>
<ul>
<li>第二步，开始制作启动U盘：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo dd <span class="keyword">if</span>=~/home/maxie/CentOS7-Everything.iso of=/dev/sdb</div></pre></td></tr></table></figure>
<p>上面命令把<code>ISO</code>镜像写入到U盘，等待几分钟即可。</p>
<p><strong>在Mac上使用dd命令制作启动盘</strong></p>
<ul>
<li>第一步，查看存储设备：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ diskutil list</div></pre></td></tr></table></figure>
<ul>
<li>第二步，使用dd命令拷贝ISO镜像到U盘：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo dd <span class="keyword">if</span>=CentOS7-Everything.iso of=/dev/disk2</div></pre></td></tr></table></figure>
<hr>
<div class="note warning"><h3 id="Mac下使用命令制作Linux启动USB盘"><a href="#Mac下使用命令制作Linux启动USB盘" class="headerlink" title="Mac下使用命令制作Linux启动USB盘"></a>Mac下使用命令制作Linux启动USB盘</h3></div>
<p>由于作者使用的是<code>Mac</code>本，而且<code>Mac</code>使用的是<code>bash</code>，所以研究了一下，怎么在<code>Mac</code>上制作USB启动盘。</p>
<p>下面就让我们开始制作启动盘吧！</p>
<ul>
<li>第一步，在终端下，将ISO镜像转换为DMG格式：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ hdiutil convert -format UDRW -o ~/linux.dmg /tmp/linux.iso</div><div class="line"></div><div class="line">正在读取Master Boot Record（MBR：0）…</div><div class="line">正在读取Linux                       （Apple_ISO：1）…</div><div class="line">正在读取（Windows_NTFS_Hidden：2）…</div><div class="line">.......................................................................................................................</div><div class="line">经过时间：14.829s</div><div class="line">速度：145.1M 字节/秒</div><div class="line">节省：0.0%</div><div class="line">created: /tmp/linux.dmg</div></pre></td></tr></table></figure>
<ul>
<li>第二步，插入USB，然后在终端下，查找该设备的设备名：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ diskutil list</div><div class="line">/dev/disk0</div><div class="line">   <span class="comment">#:                       TYPE NAME                    SIZE       IDENTIFIER</span></div><div class="line">   0:      GUID_partition_scheme                        *121.3 GB   disk0</div><div class="line">   1:                        EFI                         209.7 MB   disk0s1</div><div class="line">   2:                  Apple_HFS Macintosh HD            120.5 GB   disk0s2</div><div class="line">   3:                 Apple_Boot Recovery HD             650.0 MB   disk0s3</div><div class="line">/dev/disk1</div><div class="line">   <span class="comment">#:                       TYPE NAME                    SIZE       IDENTIFIER</span></div><div class="line">   0:     FDisk_partition_scheme                        *15.8 GB    disk1</div><div class="line">   1:               Windows_NTFS wxy-u3                  15.8 GB    disk1s1</div></pre></td></tr></table></figure>
<p>通过上面命令查看到U盘设备名是：/dev/disk1</p>
<ul>
<li>卸载USB盘，但是不要<code>推出</code>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ diskutil umountDisk /dev/disk1</div><div class="line">Unmount of all volumes on disk1 was successful</div></pre></td></tr></table></figure>
<ul>
<li>第四步，镜像上面生成的DMG内容到USB盘：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ sudo dd <span class="keyword">if</span>=linux.dmg of=/dev/rdisk1 bs=1m</div><div class="line">Password:</div><div class="line">2151+1 records <span class="keyword">in</span></div><div class="line">2151+1 records out</div><div class="line">2256076800 bytes transferred <span class="keyword">in</span> 90.277905 secs (24990354 bytes/sec)</div></pre></td></tr></table></figure>
<p>此处要千万注意，指定的of别写错了，否则悔之晚矣。另外，of参数指定的设备名，可以用上面找到的/dev/disk1，也可以用/dev/rdisk1，此处的“r”据说会写入较快。</p>
<p>另外，如果报错：“dd: Invalid number `1m’”，可能是使用的不同版本的dd，可以换为bs=1M试试。</p>
<p>如果报错：“dd: /dev/diskN: Resource busy”，可能是上面的步骤中没有完成卸载USB盘。</p>
<ul>
<li>第五步，推出USB盘。在上面复制之后，系统可能会报错，“此电脑不能读取能插入的磁盘”，不必理会，直接推出即可。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ diskutil eject /dev/disk1</div></pre></td></tr></table></figure>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=404783635&auto=0&height=66"></iframe>

<p>本文出自<a href="http://maxiecloud.com" target="_blank" rel="external">Maxie’s Notes</a>博客，转载请务必保留此出处。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;dd命令可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。&lt;br&gt;dd命令非常强大，让我们一起来学习吧！&lt;br&gt;&lt;/blockquote&gt;



&lt;h2 id=&quot;dd命令&quot;&gt;&lt;a href=&quot;#dd命令&quot; class=&quot;headerlink&quot; title=&quot;dd命令&quot;&gt;&lt;/a&gt;dd命令&lt;/h2&gt;&lt;div class=&quot;note primary&quot;&gt;&lt;h3 id=&quot;命令语法&quot;&gt;&lt;a href=&quot;#命令语法&quot; class=&quot;headerlink&quot; title=&quot;命令语法&quot;&gt;&lt;/a&gt;命令语法&lt;/h3&gt;&lt;/div&gt;
&lt;p&gt;dd [OPERAND]…&lt;br&gt;dd OPTION&lt;/p&gt;
    
    </summary>
    
      <category term="linux基础知识" scheme="http://yoursite.com/categories/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="command" scheme="http://yoursite.com/tags/command/"/>
    
      <category term="dd" scheme="http://yoursite.com/tags/dd/"/>
    
  </entry>
  
  <entry>
    <title>Linux中分区工具的使用详解</title>
    <link href="http://yoursite.com/2017/04/22/how-to-use-partition-tools/"/>
    <id>http://yoursite.com/2017/04/22/how-to-use-partition-tools/</id>
    <published>2017-04-22T09:16:04.000Z</published>
    <updated>2017-04-22T11:48:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">对磁盘磁盘分区有什么好处？<br>优化I/O性能<br>实现磁盘空间配额限制<br>提高修复速度<br>隔离系统和程序<br>安装多个OS<br>采用不同文件系统<br></blockquote>

<p><strong>Linux中必要有的分区：</strong></p>
<p><code>/</code>：根分区，是所有文件/目录的”父亲”。<br><code>/boot</code>：boot分区，系统启动引导的分区。<br><code>/app</code>：app分区，一般在生产环境中需要此分区，做到程序与系统隔离。<br><code>swap</code>：swap分区是一个特殊的分区，它是相当于内存的存在。</p>
<a id="more"></a>
<h2 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h2><div class="note primary"><h3 id="MBR分区表"><a href="#MBR分区表" class="headerlink" title="MBR分区表"></a>MBR分区表</h3></div>
<p>在MBR分区表的设置中，引导扇区是每个分区(partition)的第一扇区，而主引导扇区是硬盘的第一扇区。</p>
<p>主引导扇区由三个部分组成：</p>
<ol>
<li>主引导记录MBR</li>
<li>硬盘分区表DPT</li>
<li>硬盘有效标志</li>
</ol>
<p>在主引导扇区里MBR占用446bytes(字节)，分区表占用64bytes(字节)，硬盘有效标志占2bytes(字节)。</p>
<p>而MBR有一个特点就是：<br><strong>只有4个分区：3主分区+1扩展分区(N个逻辑分区)</strong></p>
<div class="note success"><h3 id="GPT分区表"><a href="#GPT分区表" class="headerlink" title="GPT分区表"></a>GPT分区表</h3></div>
<p>GPT的分区信息是在分区中，而不象MBR一样在主引导扇区，为保护GPT不受MBR类磁盘管理软件的危害，GPT在主引导扇区建立了一个保护分区（Protective MBR）的MBR分区表（此分区并不必要），这种分区的类型标识为0xEE，这个保护分区的大小在Windows下为128MB，Mac OS X下为200MB，在Window磁盘管理器里名为GPT保护分区，可让MBR类磁盘管理软件把GPT看成一个未知格式的分区，而不是错误地当成一个未分区的磁盘。</p>
<p>另外，为了保护分区表，GPT的分区信息使用128位UUID(Universally Unique Identifier) 表示磁盘和分区GPT分区表自动备份在头和尾两份，并有CRC校验位</p>
<hr>
<h2 id="管理分区"><a href="#管理分区" class="headerlink" title="管理分区"></a>管理分区</h2><p><strong>lsblk命令</strong>：<br>    列出Linux中块设备</p>
<pre><code>注意：这个命令只能列出内存中的块设备信息
</code></pre><div class="note info"><h3 id="分区表管理工具"><a href="#分区表管理工具" class="headerlink" title="分区表管理工具"></a>分区表管理工具</h3></div>
<p>创建分区表工具：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fdisk       创建MBR分区</div><div class="line">gdisk       创建GPT分区</div><div class="line">parted      高级分区操作（创建，复制，调整大小等）</div><div class="line">partprobe   重新设置内存中的内核分区表版本(CentOS6不适用此命令)</div></pre></td></tr></table></figure>
<div class="note danger"><h3 id="fdisk-gdisk工具"><a href="#fdisk-gdisk工具" class="headerlink" title="fdisk/gdisk工具"></a>fdisk/gdisk工具</h3></div>
<p><strong>fdisk命令：</strong><br>用于观察硬盘实体使用情况，也可对硬盘分区。它采用传统的问答式界面，而非类似DOS fdisk的cfdisk互动式操作界面，因此在使用上较为不便，但功能却丝毫不打折扣。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ fdisk DEVICE</div><div class="line"></div><div class="line">各选项意义：</div><div class="line">-b &lt;分区大小&gt;       指定每个分区的大小</div><div class="line"><span class="_">-l</span>                 列出指定的设备的分区表状况</div><div class="line"><span class="_">-s</span> &lt;分区编号&gt;       将指定的分区大小输出到标准输出上，单位为区块</div><div class="line">-u                 搭配 <span class="_">-l</span> 参数列表，会用分区数目取代柱面数目，来表示每个分区的起始地址</div><div class="line">-v                 显示版本信息</div></pre></td></tr></table></figure>
<p><strong>fdisk的子命令</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">p           列出分区列表</div><div class="line">t           更改分区类型</div><div class="line">n           创建新分区</div><div class="line">d           删除分区</div><div class="line">w           保存并退出</div><div class="line">q           不保存并退出</div></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">[root@node /]<span class="comment"># fdisk  /dev/sdb</span></div><div class="line"></div><div class="line">WARNING: DOS-compatible mode is deprecated. Its strongly recommended to</div><div class="line">         switch off the mode (<span class="built_in">command</span> <span class="string">'c'</span>) and change display units to</div><div class="line">         sectors (<span class="built_in">command</span> <span class="string">'u'</span>).</div><div class="line"></div><div class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</div><div class="line"></div><div class="line">Disk /dev/sdb: 214.7 GB, 214748364800 bytes</div><div class="line">255 heads, 63 sectors/track, 26108 cylinders</div><div class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</div><div class="line">Sector size (logical/physical): 512 bytes / 512 bytes</div><div class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</div><div class="line">Disk identifier: 0x45ef120e</div><div class="line"></div><div class="line">   Device Boot      Start         End      Blocks   Id  System</div><div class="line"></div><div class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</div><div class="line">Command action</div><div class="line">   e   extended</div><div class="line">   p   primary partition (1-4)</div><div class="line">p</div><div class="line">Partition number (1-4): 1</div><div class="line">First cylinder (1-26108, default 1):</div><div class="line">Using default value 1</div><div class="line">Last cylinder, +cylinders or +size&#123;K,M,G&#125; (1-26108, default 26108): +10G</div><div class="line"></div><div class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</div><div class="line">The partition table has been altered!</div><div class="line"></div><div class="line">Calling ioctl() to re-read partition table.</div><div class="line">Syncing disks.</div></pre></td></tr></table></figure>
<p><strong>gdisk命令</strong></p>
<p>gdisk命令使用方法与fdisk相似，只是gdisk 是为GPT分区创建的工具。</p>
<div class="note warning"><h3 id="同步分区表"><a href="#同步分区表" class="headerlink" title="同步分区表"></a>同步分区表</h3></div>
<p>在使用 <code>fdisk/gdisk</code>工具对硬盘进行分区之后，有时会提示<strong>硬盘分区表与内存中的分区表不同步</strong>，这是因为<strong>1.可能是硬盘是很旧之前挂载上来的；2.没有手动同步分区表</strong></p>
<p>那么如何同步分区表，让我们来看看吧！</p>
<p><strong>第一步</strong>：先查看是否内核已经识别到了新的分区：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">[root@node /]<span class="comment"># cat /proc/partitions</span></div><div class="line">major minor  <span class="comment">#blocks  name</span></div><div class="line"></div><div class="line">   8        0  209715200 sda</div><div class="line">   8        1     204800 sda1</div><div class="line">   8        2   62914560 sda2</div><div class="line">   8       16  209715200 sdb</div><div class="line">   8       17   10490413 sdb1</div><div class="line"> 253        0   20971520 dm-0</div><div class="line"> 253        1    2097152 dm-1</div><div class="line"> 253        2   10485760 dm-2</div><div class="line"> 253        3   20971520 dm-3</div><div class="line"> </div><div class="line">[root@node /]<span class="comment"># lsblk</span></div><div class="line">NAME                MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</div><div class="line">sda                   8:0    0  200G  0 disk</div><div class="line">├─sda1                8:1    0  200M  0 part /boot</div><div class="line">└─sda2                8:2    0   60G  0 part</div><div class="line">  ├─vg0-root (dm-0) 253:0    0   20G  0 lvm  /</div><div class="line">  ├─vg0-swap (dm-1) 253:1    0    2G  0 lvm  [SWAP]</div><div class="line">  ├─vg0-usr (dm-2)  253:2    0   10G  0 lvm  /usr</div><div class="line">  └─vg0-var (dm-3)  253:3    0   20G  0 lvm  /var</div><div class="line">sdb                   8:16   0  200G  0 disk</div><div class="line">└─sdb1                8:17   0   10G  0 part</div><div class="line">sr0                  11:0    1  2.1G  0 rom  /centos6-my</div></pre></td></tr></table></figure>
<p>上面这个两条命令：</p>
<ol>
<li>cat /proc/partiotion：查看内核是否已经识别新的分区</li>
<li>lsblk：这条命令我们在上面说过，也是查看分区的一个信息</li>
<li>只要是我们创建了分区之后，使用这两条命令都没有查看到我们创建的分区名，那我们就要执行接下来的操作了，就是手动同步分区表。</li>
</ol>
<p><strong>第二步</strong>：通知内核重新读取硬盘分区表</p>
<p>对于CentOS6：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">新增分区：</div><div class="line"> partx <span class="_">-a</span> /dev/DEVICE     一般执行3次，强制生效</div><div class="line"> kpartx <span class="_">-a</span> <span class="_">-f</span> /dev/DEVICE </div><div class="line">删除分区：</div><div class="line"> partx <span class="_">-d</span> --nr M-N /dev/DEVICE</div></pre></td></tr></table></figure>
<p>对于Centos5，7：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">新增，删除分区：</div><div class="line"> partprobe [/dev/DEVICE]</div></pre></td></tr></table></figure>
<p>上面这条命令后如果不跟任何设备名，则表示更新所有设备的分区表信息。</p>
<hr>
<h3 id="制作脚本自动使用fdisk创建分区"><a href="#制作脚本自动使用fdisk创建分区" class="headerlink" title="制作脚本自动使用fdisk创建分区"></a>制作脚本自动使用fdisk创建分区</h3><p>此脚本目前只能实现简单的创建功能，希望<code>dalao</code> 多多指点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line">[root@node ~]<span class="comment"># cat disk-make.sh</span></div><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment">#FileName: disk-make.sh</span></div><div class="line"><span class="comment">#Description: just auto make a disk partition use fidsk command.</span></div><div class="line"><span class="comment">#Author: Maxie</span></div><div class="line"><span class="comment">#Date: 2017-04-20</span></div><div class="line"><span class="comment">#Version: 1.0</span></div><div class="line"></div><div class="line"></div><div class="line">Hard=<span class="string">'/dev/sda'</span></div><div class="line"></div><div class="line"><span class="comment">#grep the extended partition exist or not.</span></div><div class="line">Exten=`fdisk <span class="_">-l</span> <span class="variable">$Hard</span>|grep Extended`</div><div class="line"></div><div class="line"><span class="comment">#grep the max number of the partition table</span></div><div class="line">Maxnum=`fdisk <span class="_">-l</span> <span class="variable">$Hard</span>|grep -o <span class="string">"^/dev/sda[1-9]\&gt;"</span>|tr <span class="_">-d</span> [[:punct:]]|tr <span class="_">-d</span> <span class="string">'A-Za-z'</span>|sort -n|tail -1`</div><div class="line"></div><div class="line"><span class="comment">#now judge the extended and maxnum.</span></div><div class="line"><span class="keyword">if</span> [[  -z <span class="variable">$Exten</span> ]];<span class="keyword">then</span></div><div class="line">        <span class="keyword">if</span> [[ <span class="variable">$Maxnum</span> -ge 4 ]];<span class="keyword">then</span></div><div class="line"><span class="comment">#if maxnum = 4,cant make major partition and extend partition.just exit.</span></div><div class="line">                <span class="built_in">echo</span> <span class="string">"Disk partitions error!..."</span></div><div class="line">                <span class="built_in">exit</span> 1</div><div class="line">        <span class="keyword">elif</span> [ <span class="variable">$Maxnum</span> <span class="_">-eq</span> 1 -o <span class="variable">$Maxnum</span> <span class="_">-eq</span> 2 ];<span class="keyword">then</span></div><div class="line"><span class="comment">#       echo "1---3"</span></div><div class="line"><span class="comment">#judge the max number in 1 and 3, and make partition of the number 3</span></div><div class="line">                cat &lt;&lt; EOF</div><div class="line">                e|E)use all free disk greate is Extended;</div><div class="line">                *)Quit;</div><div class="line">EOF</div><div class="line">                Sdanum=$((Maxnum+1))</div><div class="line">                <span class="built_in">read</span> Opt</div><div class="line">                <span class="keyword">case</span> <span class="variable">$Opt</span> <span class="keyword">in</span></div><div class="line">                e|E)</div><div class="line">fdisk <span class="variable">$Hard</span> &amp;&gt; /opt/fdisk.log &lt;&lt;EOF</div><div class="line">n</div><div class="line">e</div><div class="line"><span class="variable">$Sdanum</span></div><div class="line"></div><div class="line"></div><div class="line">w</div><div class="line"></div><div class="line">EOF</div><div class="line">                ;;</div><div class="line">                *)</div><div class="line">                <span class="built_in">echo</span> <span class="string">"None operating ,Exit"</span></div><div class="line">                <span class="built_in">exit</span> 2</div><div class="line">                ;;</div><div class="line">                <span class="keyword">esac</span></div><div class="line">        <span class="keyword">else</span></div><div class="line"><span class="comment">#make partition of the number 4,the last number of the partition.</span></div><div class="line">                cat &lt;&lt; EOF</div><div class="line">        e|E)use all free disk greate is Extended;</div><div class="line">        *)Quit;</div><div class="line">EOF</div><div class="line">                <span class="built_in">read</span> Opt</div><div class="line">                <span class="keyword">case</span> <span class="variable">$Opt</span> <span class="keyword">in</span></div><div class="line">                e|E)</div><div class="line">                fdisk <span class="variable">$Hard</span> &amp;&gt; /opt/fdisk.log &lt;&lt;EOF</div><div class="line">                n</div><div class="line">                e</div><div class="line"></div><div class="line"></div><div class="line">                w</div><div class="line">EOF</div><div class="line"></div><div class="line">                ;;</div><div class="line">                *)</div><div class="line">                <span class="built_in">echo</span> <span class="string">"None operating ,Exit"</span></div><div class="line">                <span class="built_in">exit</span> 2</div><div class="line">                ;;</div><div class="line">                <span class="keyword">esac</span></div><div class="line"></div><div class="line">        <span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">elif</span> [[ ! -z <span class="variable">$Exten</span> ]] &amp;&amp; [[ <span class="variable">$Maxnum</span> <span class="_">-eq</span> 3 ]]; <span class="keyword">then</span></div><div class="line">	<span class="built_in">echo</span> <span class="string">"Please input new partition szie(MB),Only number."</span></div><div class="line">	<span class="built_in">read</span> ESize</div><div class="line">	CK=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$ESize</span>"</span> | grep <span class="string">"[[:punct:]]\+"</span>`</div><div class="line">		<span class="keyword">while</span> [[ <span class="variable">$ESize</span> -le 1 || -n <span class="variable">$CK</span> ]]</div><div class="line">		<span class="keyword">do</span></div><div class="line">			<span class="built_in">echo</span> <span class="string">"That wrong, Please try again"</span></div><div class="line"><span class="comment">#Variable initialization</span></div><div class="line">			ESize=</div><div class="line">			<span class="built_in">read</span> ESize</div><div class="line">			CK=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$ESize</span>"</span> | grep <span class="string">"[[:punct:]]\+"</span>`</div><div class="line">		<span class="keyword">done</span></div><div class="line"><span class="comment">#Variable initialization, use :- just output 50 and clear Eanswer's value</span></div><div class="line">	Eanswer=<span class="variable">$&#123;ESize:-50&#125;</span></div><div class="line">	fdisk <span class="variable">$Hard</span> &amp;&gt; /opt/fdisk.log &lt;&lt;EOF</div><div class="line">	n</div><div class="line"></div><div class="line">	l</div><div class="line"></div><div class="line">	+<span class="variable">$&#123;ESize&#125;</span>M</div><div class="line"></div><div class="line">	w</div><div class="line"></div><div class="line">EOF</div><div class="line"></div><div class="line"><span class="keyword">else</span></div><div class="line">        <span class="built_in">echo</span> <span class="string">'Please input new partition size(MB),Only number.'</span></div><div class="line">        <span class="built_in">read</span> Size</div><div class="line">        Pun=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$Size</span>"</span>|grep <span class="string">"[[:punct:]]\+"</span>`</div><div class="line">                <span class="keyword">while</span> [[ <span class="variable">$Size</span> -le 1 || -n <span class="variable">$Pun</span> ]]</div><div class="line">                <span class="keyword">do</span></div><div class="line">                        <span class="built_in">echo</span> <span class="string">"Wrong try again!"</span></div><div class="line">                        Size=</div><div class="line">                        <span class="built_in">read</span> Size</div><div class="line">                        Pun=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$Size</span>"</span>|grep <span class="string">"[[:punct:]]\+"</span>`</div><div class="line">                <span class="keyword">done</span></div><div class="line">        answer=<span class="variable">$&#123;Size:-50&#125;</span></div><div class="line">        fdisk <span class="variable">$Hard</span> &amp;&gt; /opt/fdisk.log &lt;&lt;EOF</div><div class="line">        n</div><div class="line"></div><div class="line">        +<span class="variable">$&#123;Size&#125;</span>M</div><div class="line">        w</div><div class="line"></div><div class="line">EOF</div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=406000222&auto=1&height=66"></iframe>

<p>本文出自<a href="http://maxiecloud.com" target="_blank" rel="external">Maxie’s Notes</a>博客，转载请务必保留此出处。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;对磁盘磁盘分区有什么好处？&lt;br&gt;优化I/O性能&lt;br&gt;实现磁盘空间配额限制&lt;br&gt;提高修复速度&lt;br&gt;隔离系统和程序&lt;br&gt;安装多个OS&lt;br&gt;采用不同文件系统&lt;br&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Linux中必要有的分区：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/&lt;/code&gt;：根分区，是所有文件/目录的”父亲”。&lt;br&gt;&lt;code&gt;/boot&lt;/code&gt;：boot分区，系统启动引导的分区。&lt;br&gt;&lt;code&gt;/app&lt;/code&gt;：app分区，一般在生产环境中需要此分区，做到程序与系统隔离。&lt;br&gt;&lt;code&gt;swap&lt;/code&gt;：swap分区是一个特殊的分区，它是相当于内存的存在。&lt;/p&gt;
    
    </summary>
    
      <category term="linux磁盘管理" scheme="http://yoursite.com/categories/linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="command" scheme="http://yoursite.com/tags/command/"/>
    
      <category term="fdisk" scheme="http://yoursite.com/tags/fdisk/"/>
    
      <category term="partition" scheme="http://yoursite.com/tags/partition/"/>
    
  </entry>
  
  <entry>
    <title>rpm命令使用详解</title>
    <link href="http://yoursite.com/2017/04/17/rpm-is-package-manager/"/>
    <id>http://yoursite.com/2017/04/17/rpm-is-package-manager/</id>
    <published>2017-04-17T14:59:49.000Z</published>
    <updated>2017-04-18T03:08:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">rpm是Red Hat公司在1995年引入的Linux包管理器<br>在后来被其他Linux发行版所广泛引用，所以rpm也被称为RPM is Package Manager.<br></blockquote>

<p>rpm命令选项分为三组：</p>
<ul>
<li>用于查询和检查包</li>
<li>用于安装、升级和删除包</li>
<li>用于执行其他功能</li>
</ul>
<p>还应该注意 <code>rpm</code> 是操作 <code>RPM</code> 的主要命令，而 <code>.rpm</code> 是 <code>RPM</code> 文件使用的扩展名。所以 “一个rpm” 或 “某某rpm” 一般是指 RPM文件，而 <code>rpm</code> 通常指命令。</p>
<a id="more"></a>
<div class="note primary"><h2 id="本次的实验环境"><a href="#本次的实验环境" class="headerlink" title="本次的实验环境"></a>本次的实验环境</h2></div>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1feqk0g4j0dj31ac07mq5j.jpg" alt=""></p>
<h2 id="程序包管理器"><a href="#程序包管理器" class="headerlink" title="程序包管理器"></a>程序包管理器</h2><p>不同的发行版，也有不同的包管理器，虽然RedHat发行的 <code>rpm</code>包管理器是公认的包管理器，但是也不全是所有发行版都使用的是其包管理器。</p>
<blockquote>
<p>Debian发行版： <code>dpkg</code>包管理器，<code>.deb</code>文件<br>RedHat发行版： <code>rpm</code>包管理器, <code>.rpm</code>文件<br>S.u.S.E发行版： <code>rpm</code>包管理器, <code>.rpm</code>文件<br>Genntoo发行版： <code>ports</code>包管理器</p>
</blockquote>
<h2 id="包概念简介"><a href="#包概念简介" class="headerlink" title="包概念简介"></a>包概念简介</h2><h3 id="rpm包命名方式"><a href="#rpm包命名方式" class="headerlink" title="rpm包命名方式"></a>rpm包命名方式</h3><p><code>rpm</code>的包一般都是以 <code>Name-Version-release.arch.rpm</code> 的格式呈现在目录中的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Name            --包名</div><div class="line">VERSION         --版本号,一般是 major.minor.release的格式</div><div class="line">release         --编译版本号</div><div class="line">arch            --CPU架构,常见的有 i386,i686,x86_64</div></pre></td></tr></table></figure>
<p>我们可以使用一条命令查看 <code>CentOS</code>系统光盘自带的<code>Packages</code>中有几种类型的<code>rpm</code>包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ grep -o <span class="string">"\&lt;[^.]\+\&gt;.rpm$"</span> | cut <span class="_">-d</span><span class="string">"."</span> <span class="_">-f</span>1  | sort | uniq -c</div><div class="line">   2072 i686</div><div class="line">   3044 noarch</div><div class="line">   4247 x86_64</div></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>i686：32位CPU架构</li>
<li>x86_64：64位CPU架构</li>
<li>noarch：无关硬件架构，任何架构的CPU都可以安装</li>
</ul>
<p>在这些包中还有主包和子包的区分：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Application-VERSION-ARCH.rpm        --主包</div><div class="line">Application-devle-VERSION-ARCH.rpm  --开发子包</div><div class="line">Application-utils-VERSION-ARCH.rpm  --工具子包</div><div class="line">Application-libs-VERSION-ARCH.rpm   --依赖库子包</div></pre></td></tr></table></figure>
<p>需要注意的一点是：</p>
<ul>
<li><code>rpm</code>包与包可能存在依赖关系，甚至循环依赖，处理好这些依赖关系是学好<code>rpm</code>命令的重点。</li>
</ul>
<hr>
<h3 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h3><p>程序包管理器的功能：</p>
<pre><code>将编译好的应用程序的各组成文件打包成一个或几个程序包文件，从而方便快捷的实现程序包的安装、卸载、升级和校验等管理操作。
</code></pre><p><code>rpm</code>包文件的组成：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RPM包内的文件</div><div class="line">RPM的元数据、名称、版本、依赖性、描述等</div><div class="line">安装rpm包时运行的脚本</div></pre></td></tr></table></figure>
<p><code>rpm</code>数据库：</p>
<p>一般存放在/var/lib/rpm目录下</p>
<p>存放以下这些文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">程序包名称以及版本</div><div class="line">依赖关系</div><div class="line">功能说明</div><div class="line">包安装后生成的各文件路径以及校验码信息</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="程序包的来源"><a href="#程序包的来源" class="headerlink" title="程序包的来源"></a>程序包的来源</h3><p>获取程序包的途径：</p>
<ol>
<li><p>系统发行版的光盘或官方的服务器<br><a href="https://www.centos.org/download" target="_blank" rel="external">https://www.centos.org/download</a><br><a href="http://mirrors.aliyun.com" target="_blank" rel="external">http://mirrors.aliyun.com</a><br><a href="http://mirrors.163.com" target="_blank" rel="external">http://mirrors.163.com</a></p>
</li>
<li><p>项目的官方站点<br><a href="http://httpd.apache.org/download.cgi#apache24" target="_blank" rel="external">http://httpd.apache.org/download.cgi#apache24</a><br><a href="http://nginx.org/en/download.html" target="_blank" rel="external">http://nginx.org/en/download.html</a></p>
</li>
<li><p>第三方组织：Fedora-EPEL<br><a href="https://dl.fedoraproject.org/pub/epel/" target="_blank" rel="external">https://dl.fedoraproject.org/pub/epel/</a></p>
</li>
</ol>
<p>RPMforge：RHEL推荐使用</p>
<p>或者使用专用搜索引擎<br><a href="http://pkgs.org" target="_blank" rel="external">http://pkgs.org</a><br><a href="http://rpmfind.net" target="_blank" rel="external">http://rpmfind.net</a><br><a href="http://rpm.pbone.net" target="_blank" rel="external">http://rpm.pbone.net</a><br><a href="http://sourceforge.net" target="_blank" rel="external">http://sourceforge.net</a></p>
<p><em>注意：</em>第三方包建议要检查其合法性（来源合法性以及程序包的完整性）</p>
<hr>
<h2 id="rpm包管理"><a href="#rpm包管理" class="headerlink" title="rpm包管理"></a>rpm包管理</h2><p>我们可以使用 <code>rpm</code>命令对包进行安装、升级、卸载、查询、校验以及数据库维护等操作。</p>
<div class="note success"><h3 id="安装rpm包"><a href="#安装rpm包" class="headerlink" title="安装rpm包"></a>安装rpm包</h3></div>
<p><code>rpm {-i|--install} [install-options] PACKAGE_FILE …</code></p>
<p>安装时常用的选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-v          verbose，显示安装时的详细信息</div><div class="line">-h          <span class="built_in">hash</span>，以50个<span class="built_in">hash</span>标记，也就是<span class="comment">#号的形式显示安装程序包的执行进度条</span></div></pre></td></tr></table></figure>
<p>常用格式为：<br><code>rpm -ivh PACKAGE_FILE</code></p>
<p>注意这里是<code>PACKAGE_FILE</code>，是需要包的全名，例如<code>tree-1.6.0-10.el7.x86_64.rpm</code></p>
<p>常用长选项有：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">--test              测试安装，但不真正执行安装，即dry run模式</div><div class="line">--nodeps            忽略依赖关系</div><div class="line">--replacepkgs | replacefiles（只覆盖某个重复的文件）</div><div class="line">--nosignature       不检查来源合法性</div><div class="line">--nodigest          不检查包完整性</div><div class="line">--noscripts         不执行程序包脚本</div><div class="line">	%pre：安装前脚本；--nopre 不执行安装前的脚本</div><div class="line">	%post：安装后脚本；--nopost</div><div class="line">	%preun：卸载前脚本；--nopreun</div><div class="line">	%postun：卸载后脚本；--nopostun</div></pre></td></tr></table></figure>
<p>实例：</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1feql1v03u5j318k06m40z.jpg" alt=""></p>
<div class="note info"><h3 id="升级rpm包"><a href="#升级rpm包" class="headerlink" title="升级rpm包"></a>升级rpm包</h3></div>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rpm &#123;-U|--upgrade&#125; [install-options] PACKAGE_FILE ...</div><div class="line">rpm &#123;-F|--freshen&#125; [install-options] PACKAGE_FILE …</div></pre></td></tr></table></figure>
<p>其中<code>U</code>选项表示：<br>    upgrade：安装时，如果有旧版程序包，则“升级”；如果不存在旧版程序包，则“安装”</p>
<p>其中<code>F</code>选项表示：<br>    fresh：安装时，如果有旧版程序包，则“升级”；如果不存在旧版程序包，则“不执行任何操作”</p>
<p>常用格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rpm -Uvh PACKAGE_FILE…</div><div class="line">rpm -Fvh PACKAGE_FILE…</div></pre></td></tr></table></figure>
<p>长选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">--oldpackage        降级安装</div><div class="line">--force             强制安装</div></pre></td></tr></table></figure>
<p>对内核升级：<br>内核的升级比较特殊，因为在生产环境中基本不会对内核升级。而Linux提供了一个很方便的东西，那就是允许多内核并存。<br>这样我们无需”真正的升级”，而是安装另一个新的内核即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm -ivh kernel-3.10.0-514.el7.x86_64.rpm</div></pre></td></tr></table></figure>
<p>实例：</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1feqlmvvbjjj318g07k410.jpg" alt=""></p>
<p>这个实例是在<code>centos7.2</code>上强制完成的，升级内核的操作十分危险，建议没有特殊需求，不要对内核进行升级！！！</p>
<div class="note danger"><h3 id="查询rpm包"><a href="#查询rpm包" class="headerlink" title="查询rpm包"></a>查询rpm包</h3></div>
<p>使用查询命令，我们可以知道某个<code>rpm</code>包中有什么信息，以及可以查看我们已经安装了那些<code>rpm</code>包</p>
<p><code>rpm {-q|--query} [select-options] [query-options]</code></p>
<p>常用选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="_">-a</span>                  所有包</div><div class="line"><span class="_">-f</span>                  查看指定的文件由哪个程序包安装生成</div><div class="line">-p PACKAGE_FILE     针对尚未安装的程序包文件做查询操作；配合 <span class="_">-l</span> 选项一起使用</div><div class="line"><span class="_">-l</span>                  查看已安装的包包含哪些文件；</div><div class="line">--changelog         查询rpm包的修改日志</div><div class="line">-c                  查询程序的配置文件</div><div class="line"><span class="_">-d</span>                  查询程序的文档</div><div class="line">-i                  查询程序的信息information（已安装的程序包）</div><div class="line">--provides          列出指定程序包所提供的CAPBILITY</div><div class="line">--whatprovides CAPBILITY    查询指定的CAPBILITY由那个包提供</div><div class="line">--whatrequires CAPBILITY    查询指定的CAPBILITY被哪个包所依赖</div><div class="line">--scripts           程序包自带的脚本</div><div class="line">-R                  查询指定的程序包所依赖的CAPBILITY</div></pre></td></tr></table></figure>
<p><em>注意：</em></p>
<p>当删除了一个程序的/usr/bin/下的执行文件之后，还是可以通过 <code>rpm -qf</code> 查询到，这是因为在安装这个包时，会在<code>rpm</code>数据中保存信息。</p>
<p><strong>实例：</strong></p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1feqm5y3auij319e0u0tgx.jpg" alt=""></p>
<div class="note warning"><h3 id="校验rpm包"><a href="#校验rpm包" class="headerlink" title="校验rpm包"></a>校验rpm包</h3></div>
<p><code>rpm {-V|--verify} [select-options] [verify-options]</code></p>
<p>校验时是，比对<code>rpm</code>数据库中的信息与当前的信息是否一致<br>如果被修改过，不管是否再修改回去，都是会提示的。</p>
<p>提示信息详解：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">S file Size differs                     文件大小被修改</div><div class="line">M Mode differs (includes permissions and file <span class="built_in">type</span>)         权限被修改</div><div class="line">5 digest (formerly MD5 sum) differs     MD5被修改，内容改变（内容被修改，就会提示）</div><div class="line">D Device major/minor number mismatch    主次设备号不匹配</div><div class="line">L <span class="built_in">read</span>Link(2) path mismatch：           readlink路径不匹配</div><div class="line">U User ownership differs                属主修改</div><div class="line">G Group ownership differs               属组修改</div><div class="line">T mTime differs                         时间戳修改（最近修改时间）</div><div class="line">P caPabilities differ                   caPabilitie被修改</div></pre></td></tr></table></figure>
<p>常用选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-V          检查已安装的软件名称</div><div class="line">-K          手动检测完整性，以及Key的信息</div><div class="line">--nofiles   不检查</div><div class="line">-Va         检查所有包</div><div class="line"><span class="_">-f</span>          检查某个文件的完整性</div><div class="line">-p          检查某个rpm文件的档名</div></pre></td></tr></table></figure>
<p><strong>包来源合法性验证以及完整性验证</strong>：<br>    完整性验证：SHA256<br>    来源合法性验证：RSA</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1feqnex09ckj30jj0dj77r.jpg" alt="RPM包制作数字签名过程"></p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1feqnexswksj30to0kwq5q.jpg" alt="RPM包数字签名验证过程"></p>
<p><strong>公钥加密</strong>：<br>    对称加密：加密、解密使用同一密钥<br>    非对称加密：密钥是对儿的<br>        public key：公钥，公开给所有人<br>        secret key：私钥，不能公开</p>
<p><strong>导入所需要的公钥</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</div><div class="line">$ rpm -qa <span class="string">"gpg-pubkey*"</span></div><div class="line">gpg-pubkey<span class="_">-f</span>4a80eb5-53a7ff4b</div></pre></td></tr></table></figure>
<p>导入key后，我们再安装包时就不会提示警告没有key的信息啦！</p>
<p><strong>卸载key</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rpm -qa <span class="string">"gpg-pubkey*"</span></div><div class="line">gpg-pubkey<span class="_">-f</span>4a80eb5-53a7ff4b</div><div class="line">$ rpm <span class="_">-e</span> gpg-pubkey<span class="_">-f</span>4a80eb5-53a7ff4b</div></pre></td></tr></table></figure>
<p><strong>实例：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1feqn8dae1yj318i09kmzn.jpg" alt=""></p>
<p>我们在README文件中添加一个空行，导致文件被修改。</p>
<div class="note default"><h3 id="卸载rpm包"><a href="#卸载rpm包" class="headerlink" title="卸载rpm包"></a>卸载rpm包</h3></div>
<p><code>rpm {-e|--erase} [--allmatches] [--nodeps] [--noscripts] [--test] PACKAGE_NAME ...</code></p>
<p>常用选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">--allmatch      卸载所有匹配指定名称的程序包的各版本</div><div class="line">--nodeps        忽略依赖关系</div><div class="line">--test          卸载测试，dry run模式</div></pre></td></tr></table></figure>
<p><strong>实例：</strong></p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1feqncs4b5ij318g03cwf5.jpg" alt=""></p>
<div class="note primary"><h3 id="RPM数据库"><a href="#RPM数据库" class="headerlink" title="RPM数据库"></a>RPM数据库</h3></div>
<p><code>rpm</code>数据库的位置一般在：<code>/var/lib/rpm/</code>目录下</p>
<p><code>rpm {--initdb | --rebuilddb}</code></p>
<p>–initdb：初始化数据库<br>    如果事先不存在数据库，则新建之<br>    否则，不执行任何操作</p>
<p>–rebuilddb：重新构建，通过读取当前系统上所有已经安装过的程序包进行创建</p>
<p>–dbpath：指定初始化数据库的位置, –dbpath=/PATH/TO/</p>
<p>恢复 RPM Database 前，一定先将原有数据进行备份，然后再使用恢复命令！<br>通常，恢复方法有下面三种：</p>
<ol>
<li>只移除 <code>/var/lib/rpm/__db*</code> 文件，然后执行 <code>rpm --rebuilddb</code>命令</li>
<li>当上面的方法没能恢复数据库时，转移 <code>/var/lib/rpm</code> 文件夹，然后执行 <code>rpm --rebuilddb</code>命令</li>
<li>当前面两个方法都没奏效时，则表示情况比较严重，需要重新创建 RPM 数据库，再进行重建数据库操作。首先，选择一个目录创建新的数据库，执行 <code>rpm --initdb --dbpath new_db_path</code>然后，执行重构数据库命令：<code>rpm --rebuilddb</code></li>
</ol>
<p>查看数据库文件：</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1feqnls5z6sj318g0i2aj6.jpg" alt=""></p>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=433018366&auto=0&height=66"></iframe>

<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
<p>本文出自<a href="http://maxiecloud.com" target="_blank" rel="external">Maxie’s Notes</a>博客，转载请务必保留此出处。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;rpm是Red Hat公司在1995年引入的Linux包管理器&lt;br&gt;在后来被其他Linux发行版所广泛引用，所以rpm也被称为RPM is Package Manager.&lt;br&gt;&lt;/blockquote&gt;

&lt;p&gt;rpm命令选项分为三组：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于查询和检查包&lt;/li&gt;
&lt;li&gt;用于安装、升级和删除包&lt;/li&gt;
&lt;li&gt;用于执行其他功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还应该注意 &lt;code&gt;rpm&lt;/code&gt; 是操作 &lt;code&gt;RPM&lt;/code&gt; 的主要命令，而 &lt;code&gt;.rpm&lt;/code&gt; 是 &lt;code&gt;RPM&lt;/code&gt; 文件使用的扩展名。所以 “一个rpm” 或 “某某rpm” 一般是指 RPM文件，而 &lt;code&gt;rpm&lt;/code&gt; 通常指命令。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux包管理" scheme="http://yoursite.com/categories/Linux%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="command" scheme="http://yoursite.com/tags/command/"/>
    
      <category term="rpm" scheme="http://yoursite.com/tags/rpm/"/>
    
      <category term="package" scheme="http://yoursite.com/tags/package/"/>
    
  </entry>
  
  <entry>
    <title>bash脚本编程基础（二）</title>
    <link href="http://yoursite.com/2017/04/14/shell-programming-basis-2/"/>
    <id>http://yoursite.com/2017/04/14/shell-programming-basis-2/</id>
    <published>2017-04-14T11:01:13.000Z</published>
    <updated>2017-04-14T13:12:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">在编写脚本的同时，我们不仅要让功能实现，也要让使用者能看懂我们写的脚本。所以要在必要的地方加上注释。<br></blockquote>

<p><strong>注释</strong></p>
<p>在<code>bash</code>中除了第一行的<code>&quot;shebang&quot;</code>，其余的行如果有<code>#</code>号开头的行，解释器都会忽略这些行，因为这些行都被视为是代码的注释信息。</p>
<p><code>bash</code>中没有多行注释，只能每行加一个<code>#</code>号。</p>
<p>像这样：</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1femfa3r7eqj310y0rwn02.jpg" alt=""></p>
<p>如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？</p>
<p>每一行加一个<code>#</code>号太费劲了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，不调用这个函数，这样我们就实现了 “多行注释” 的效果。</p>
<a id="more"></a>
<div class="note primary"><h2 id="如何传递参数"><a href="#如何传递参数" class="headerlink" title="如何传递参数"></a>如何传递参数</h2></div>
<p>我们可以在执行<code>shell</code>脚本时，向脚本传递参数，脚本内获取参数的格式为：<code>$n</code></p>
<blockquote>
<p>n 代表一个数字，1 为执行脚本的第一个参数， 2 为执行脚本的第二个参数，以此类推…</p>
</blockquote>
<p><strong>实例：</strong></p>
<p>以下实例，我们将向脚本传递 2 个参数，并分别输出，注意 <code>$0</code> 是脚本本身：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"现在我们开始传递参数！"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"脚本名为:<span class="variable">$&#123;0&#125;</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"第一个参数为:<span class="variable">$&#123;1&#125;</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"第一个参数为:<span class="variable">$&#123;2&#125;</span>"</span></div></pre></td></tr></table></figure>
<p>执行脚本前，需要给脚本授予执行权限。</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1femfjftwkbj310y0rwtck.jpg" alt=""></p>
<p>另外，还有几个特殊字符用来处理参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$#</span>          --传递到脚本的参数的个数</div><div class="line">$*          --以一个单字符串显示所有向脚本传递的参数</div><div class="line">$$          --脚本运行的当前进程号</div><div class="line">$!          --后台运行的最后一个进程号</div><div class="line"><span class="variable">$@</span>          --与$*相同，但是使用时加引号，并在引号中返回每个参数</div><div class="line">$-          --显示shell使用的当前选项，与<span class="built_in">set</span>命令功能相同</div><div class="line">$?          --显示最后命令的退出状态。0 表示没有错误，1-255 表示有错。</div></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1femft847auj310007cq4d.jpg" alt=""></p>
<p>* 与 @ 的区别：</p>
<ul>
<li>相同点：都是引用所有参数。</li>
<li>不同点：只有在双引号中体现出。</li>
</ul>
<blockquote>
<p>假设在脚本运行时写了三个参数 1、2、3，则 * 表示“1 2 3”（相当于传递了一个参数），而 @ 表示 “1” “2” “3”(传递了三个参数）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"传递参数实例:"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"第一个参数为:<span class="variable">$&#123;1&#125;</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"第二个参数为:<span class="variable">$&#123;2&#125;</span>"</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">" \$* 演示"</span></div><div class="line">    </div><div class="line">    <span class="keyword">for</span> I <span class="keyword">in</span> <span class="string">"$*"</span>; <span class="keyword">do</span></div><div class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;I&#125;</span>"</span></div><div class="line">    <span class="keyword">done</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">" \$@ 演示"</span></div><div class="line">    </div><div class="line">    <span class="keyword">for</span> I <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>; <span class="keyword">do</span></div><div class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;I&#125;</span>"</span></div><div class="line">    <span class="keyword">done</span></div></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1femg1h8kcvj310209ijs8.jpg" alt=""></p>
<hr>
<div class="note success"><h2 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h2></div>
<p>Shell 和其他编程语言一样，支持多种运算符，包括：</p>
<ul>
<li>算数运算符</li>
<li>关系运算符</li>
<li>布尔运算符</li>
<li>字符串运算符</li>
<li>文件测试运算符</li>
</ul>
<p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p>
<p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p>
<p>例如，两个数相加(特别注意：使用的是反引号 ` 而不是单引号 ‘)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line">var=`expr 2 + 2`</div><div class="line"><span class="built_in">echo</span> <span class="string">"两数之和为: <span class="variable">$&#123;var&#125;</span>"</span></div></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">两数之和为: 4</div></pre></td></tr></table></figure>
<p>这里要注意两点：</p>
<ol>
<li>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多编程语言不一样。</li>
<li>完整的表达式要被 反引号 包含，注意这个字符不是常用的单引号，在<code>ESC</code>键的下面。</li>
</ol>
<h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>下面列出了常用的算数运算符，假定变量 a 为 10，变量 b 为 20：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ 加法运算  `expr <span class="variable">$a</span> + <span class="variable">$b</span>` 结果为 30</div><div class="line">- 减法运算  `expr <span class="variable">$a</span> - <span class="variable">$b</span>` 结果为 -10</div><div class="line">* 乘法运算  `expr <span class="variable">$a</span> * <span class="variable">$b</span>` 结果为 200</div><div class="line">/ 除法运算  `expr <span class="variable">$b</span> / <span class="variable">$a</span>` 结果为 2</div><div class="line">% 取余运算  `expr <span class="variable">$b</span> % %b` 结果为 0</div><div class="line">= 赋值     a=<span class="variable">$&#123;b&#125;</span> 将变量 b 的值赋值给 a</div><div class="line">== 相等   用于比较两个数字，相等则返回 <span class="literal">true</span>  [ <span class="variable">$a</span> == <span class="variable">$b</span> ] 返回 <span class="literal">false</span></div><div class="line">!= 不相等 用于比较两个数字,不相等则返回 <span class="literal">true</span>  [ <span class="variable">$a</span> != <span class="variable">$b</span>]  返回 <span class="literal">false</span></div></pre></td></tr></table></figure>
<p><em>注意</em>：条件表达式要放在方括号之间，并且要有空格，例如: <code>[$a==$b]</code>是错误的，必须写成<code>[ $a == $b ]</code></p>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line">a=10</div><div class="line">b=20</div><div class="line"></div><div class="line">var=`expr <span class="variable">$a</span> + <span class="variable">$b</span>`</div><div class="line"><span class="built_in">echo</span> <span class="string">"a + b = <span class="variable">$var</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">""</span></div><div class="line"></div><div class="line">var=`expr <span class="variable">$a</span> - <span class="variable">$b</span>`</div><div class="line"><span class="built_in">echo</span> <span class="string">"a - b = <span class="variable">$var</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">""</span></div><div class="line"></div><div class="line"></div><div class="line">var=`expr <span class="variable">$a</span> * <span class="variable">$b</span>`</div><div class="line"><span class="built_in">echo</span> <span class="string">"a * b = <span class="variable">$var</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">""</span></div><div class="line"></div><div class="line">var=`expr <span class="variable">$b</span> / <span class="variable">$a</span>`</div><div class="line"><span class="built_in">echo</span> <span class="string">"b / a = <span class="variable">$var</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">""</span></div><div class="line"></div><div class="line"></div><div class="line">var=`expr <span class="variable">$b</span> % <span class="variable">$a</span>`</div><div class="line"><span class="built_in">echo</span> <span class="string">"a + b = <span class="variable">$var</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">""</span></div><div class="line"></div><div class="line"><span class="keyword">if</span>  [ <span class="variable">$a</span> == <span class="variable">$b</span>  ]; <span class="keyword">then</span></div><div class="line">        <span class="built_in">echo</span> <span class="string">"a 等于 b"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> != <span class="variable">$b</span>  ]; <span class="keyword">then</span></div><div class="line">        <span class="built_in">echo</span> <span class="string">"a 不等于 b"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下：</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1femgy7fjj4j31000codgj.jpg" alt=""></p>
<p><em>注意</em>：</p>
<ul>
<li>乘号前面必须加反斜杠才能实现乘法运算</li>
<li>if..then..fi是条件判断语句</li>
</ul>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<p>下面列出了常用的关系运算符，我们假定变量 a 为 10，变量 b 为 20.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="_">-eq</span>     检测两个数是否相等，相等返回 <span class="literal">true</span>                    [ <span class="variable">$a</span> <span class="_">-eq</span> <span class="variable">$b</span> ] 返回 <span class="literal">false</span></div><div class="line"><span class="_">-ne</span>     检测两个数是否不相等，不相等返回 <span class="literal">true</span>                  [ <span class="variable">$a</span> <span class="_">-ne</span> <span class="variable">$b</span> ] 返回 <span class="literal">true</span></div><div class="line"><span class="_">-gt</span>     检测左侧数字是否大于右侧数字，如果是，则返回 <span class="literal">true</span>        [ <span class="variable">$a</span> <span class="_">-gt</span> <span class="variable">$b</span> ] 返回 <span class="literal">false</span></div><div class="line">-ge     检测左侧数字是否大于等于右侧数字，如果是，则返回 <span class="literal">true</span>    [ <span class="variable">$a</span> -ge <span class="variable">$b</span> ] 返回 <span class="literal">false</span></div><div class="line"><span class="_">-lt</span>     检测左侧数字是否小于右侧数字，如果是，则返回 <span class="literal">true</span>       [ <span class="variable">$a</span> <span class="_">-lt</span> <span class="variable">$b</span> ] 返回 <span class="literal">true</span></div><div class="line">-le     检测左侧数字是否小于等于右侧数字，如果，则返回 <span class="literal">true</span>     [ <span class="variable">$a</span> -le <span class="variable">$b</span> ] 返回 <span class="literal">true</span></div></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line">a=10</div><div class="line">b=20</div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> <span class="_">-eq</span> <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -eq <span class="variable">$b</span> : a 等于 b"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -eq <span class="variable">$b</span>: a 不等于 b"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> <span class="_">-ne</span> <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -ne <span class="variable">$b</span>: a 不等于 b"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -ne <span class="variable">$b</span> : a 等于 b"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> <span class="_">-gt</span> <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -gt <span class="variable">$b</span>: a 大于 b"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -gt <span class="variable">$b</span>: a 不大于 b"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> <span class="_">-lt</span> <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -lt <span class="variable">$b</span>: a 小于 b"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -lt <span class="variable">$b</span>: a 不小于 b"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -ge <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -ge <span class="variable">$b</span>: a 大于或等于 b"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -ge <span class="variable">$b</span>: a 小于 b"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -le <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -le <span class="variable">$b</span>: a 小于或等于 b"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -le <span class="variable">$b</span>: a 大于 b"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下：</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1femhi2naluj310207imy9.jpg" alt=""></p>
<h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><p>下面列出了常用的布尔运算符，我们假定变量 a 为 10，变量 b 为 20</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">!       非运算，表达式为 <span class="literal">true</span> 则返回 <span class="literal">false</span> ，否则返回 <span class="literal">true</span></div><div class="line">-o      或运算，有一个表达式为 <span class="literal">true</span> 则返回 <span class="literal">true</span></div><div class="line"><span class="_">-a</span>      与运算，两个表达式都为 <span class="literal">true</span> 则返回 <span class="literal">true</span></div></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">a=10</div><div class="line">b=20</div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> != <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> != <span class="variable">$b</span> : a 不等于 b"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> != <span class="variable">$b</span>: a 等于 b"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> <span class="_">-lt</span> 100 <span class="_">-a</span> <span class="variable">$b</span> <span class="_">-gt</span> 15 ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -lt 100 -a <span class="variable">$b</span> -gt 15 : 返回 true"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -lt 100 -a <span class="variable">$b</span> -gt 15 : 返回 false"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> <span class="_">-lt</span> 100 -o <span class="variable">$b</span> <span class="_">-gt</span> 100 ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -lt 100 -o <span class="variable">$b</span> -gt 100 : 返回 true"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -lt 100 -o <span class="variable">$b</span> -gt 100 : 返回 false"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> <span class="_">-lt</span> 5 -o <span class="variable">$b</span> <span class="_">-gt</span> 100 ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -lt 100 -o <span class="variable">$b</span> -gt 100 : 返回 true"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -lt 100 -o <span class="variable">$b</span> -gt 100 : 返回 false"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下：</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1femhv314ojj310005ggmo.jpg" alt=""></p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>以下介绍shell的逻辑运算符，假定变量 a 为 10，变量 b 为 20：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&amp;&amp;      逻辑 AND</div><div class="line">||      逻辑 OR</div></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line">a=10</div><div class="line">b=20</div><div class="line"></div><div class="line"><span class="keyword">if</span> [[ <span class="variable">$a</span> <span class="_">-lt</span> 100 &amp;&amp; <span class="variable">$b</span> <span class="_">-gt</span> 100 ]]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"返回 true"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"返回 false"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [[ <span class="variable">$a</span> <span class="_">-lt</span> 100 || <span class="variable">$b</span> <span class="_">-gt</span> 100 ]]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"返回 true"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"返回 false"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下：</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1femhywfblaj310003a3ys.jpg" alt=""></p>
<h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><p>下面列出了常用的字符串运算符，假定变量 a 为 “abc”， 变量 b 为 “efg”：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">=       检测两个字符串是否相等，相等返回 <span class="literal">true</span></div><div class="line">!=      检测两个字符串是否不相等，不相等返回 <span class="literal">true</span></div><div class="line">-z      检测字符串长度是否为 0 ，如果为 0 则返回 <span class="literal">true</span></div><div class="line">-n      检测字符串长度是否不为 0 ，如果不为0 则返回 <span class="literal">true</span></div><div class="line">str     检测字符串是否为不为空，不为空则返回 <span class="literal">true</span></div></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line">a=<span class="string">"abc"</span></div><div class="line">b=<span class="string">"efg"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> = <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> = <span class="variable">$b</span> : a 等于 b"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> = <span class="variable">$b</span>: a 不等于 b"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> != <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> != <span class="variable">$b</span> : a 不等于 b"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> != <span class="variable">$b</span>: a 等于 b"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ -z <span class="variable">$a</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"-z <span class="variable">$a</span> : 字符串长度为 0"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"-z <span class="variable">$a</span> : 字符串长度不为 0"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ -n <span class="variable">$a</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"-n <span class="variable">$a</span> : 字符串长度不为 0"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"-n <span class="variable">$a</span> : 字符串长度为 0"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> : 字符串不为空"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> : 字符串为空"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下：</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1femi6x7sshj30zw068t9p.jpg" alt=""></p>
<h3 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h3><p>文件测试是用于检测 Linux文件的各种属性</p>
<p>属性检测描述如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">-b file    检测文件是否是块设备文件，如果是，则返回 <span class="literal">true</span>。    </div><div class="line">-c file    检测文件是否是字符设备文件，如果是，则返回 <span class="literal">true</span>。    </div><div class="line"><span class="_">-d</span> file    检测文件是否是目录，如果是，则返回 <span class="literal">true</span>。    </div><div class="line"><span class="_">-f</span> file    检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 <span class="literal">true</span>。    </div><div class="line">-g file    检测文件是否设置了 SGID 位，如果是，则返回 <span class="literal">true</span>。    </div><div class="line">-k file    检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 <span class="literal">true</span>。    </div><div class="line">-p file    检测文件是否是具名管道，如果是，则返回 <span class="literal">true</span>。    </div><div class="line">-u file    检测文件是否设置了 SUID 位，如果是，则返回 <span class="literal">true</span>。    </div><div class="line">-r file    检测文件是否可读，如果是，则返回 <span class="literal">true</span>。   </div><div class="line">-w file    检测文件是否可写，如果是，则返回 <span class="literal">true</span>。    </div><div class="line">-x file    检测文件是否可执行，如果是，则返回 <span class="literal">true</span>。    </div><div class="line"><span class="_">-s</span> file    检测文件是否为空（文件大小是否大于0），不为空返回 <span class="literal">true</span>。   </div><div class="line"><span class="_">-e</span> file    检测文件（包括目录）是否存在，如果是，则返回 <span class="literal">true</span>。</div></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line">a=<span class="string">"abc"</span></div><div class="line">b=<span class="string">"efg"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> = <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> = <span class="variable">$b</span> : a 等于 b"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> = <span class="variable">$b</span>: a 不等于 b"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> != <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> != <span class="variable">$b</span> : a 不等于 b"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> != <span class="variable">$b</span>: a 等于 b"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ -z <span class="variable">$a</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"-z <span class="variable">$a</span> : 字符串长度为 0"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"-z <span class="variable">$a</span> : 字符串长度不为 0"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ -n <span class="variable">$a</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"-n <span class="variable">$a</span> : 字符串长度不为 0"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"-n <span class="variable">$a</span> : 字符串长度为 0"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> : 字符串不为空"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> : 字符串为空"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下：</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1femigh5j08j310208idgt.jpg" alt=""></p>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=32341272&auto=1&height=66"></iframe>

<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
<p>本文出自<a href="http://maxiecloud.com" target="_blank" rel="external">Maxie’s Notes</a>博客，转载请务必保留此出处。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;在编写脚本的同时，我们不仅要让功能实现，也要让使用者能看懂我们写的脚本。所以要在必要的地方加上注释。&lt;br&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;注释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;bash&lt;/code&gt;中除了第一行的&lt;code&gt;&amp;quot;shebang&amp;quot;&lt;/code&gt;，其余的行如果有&lt;code&gt;#&lt;/code&gt;号开头的行，解释器都会忽略这些行，因为这些行都被视为是代码的注释信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash&lt;/code&gt;中没有多行注释，只能每行加一个&lt;code&gt;#&lt;/code&gt;号。&lt;/p&gt;
&lt;p&gt;像这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/006tNc79ly1femfa3r7eqj310y0rwn02.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？&lt;/p&gt;
&lt;p&gt;每一行加一个&lt;code&gt;#&lt;/code&gt;号太费劲了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，不调用这个函数，这样我们就实现了 “多行注释” 的效果。&lt;/p&gt;
    
    </summary>
    
      <category term="linux基础知识" scheme="http://yoursite.com/categories/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="bash" scheme="http://yoursite.com/tags/bash/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
      <category term="programming" scheme="http://yoursite.com/tags/programming/"/>
    
  </entry>
  
  <entry>
    <title>bash脚本编程基础（一）</title>
    <link href="http://yoursite.com/2017/04/12/shell-programming-basis/"/>
    <id>http://yoursite.com/2017/04/12/shell-programming-basis/</id>
    <published>2017-04-12T11:12:50.000Z</published>
    <updated>2017-04-12T13:45:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">Bash(Bourne Again Shell)，是一款在大多数Linux系统中默认的shell。<br>值得注意的是shell与shell script是两个不同的概念。<br></blockquote>

<p><strong>常见的shell</strong></p>
<blockquote>
<p>Bourne Shell (/usr/bin/sh或/bin/sh)<br>Bourne Again Shell (/bin/bash)<br>C Shell (/usr/bin/csh)<br>K Shell (/usr/bin/ksh)<br>Z Shell (/usr/bin/zsh)<br>Shell for Root (/sbin/sh)</p>
</blockquote>
<p>要想成为一个使用Linux的dalao，就离不开shell，那么也就是说离不开shell编程。很多时候服务器都需要编写一些计划任务来定时运行的，所以掌握一些基本的shell编程基础很有必要。</p>
<a id="more"></a>
<hr>
<div class="note primary"><h2 id="什么是Shell脚本"><a href="#什么是Shell脚本" class="headerlink" title="什么是Shell脚本"></a>什么是Shell脚本</h2></div>
<p>先看个例子吧！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="built_in">cd</span> /root</div><div class="line">mkdir script</div><div class="line"><span class="built_in">cd</span> script</div><div class="line"><span class="keyword">for</span> ((i=0; i&lt;10; i++)); <span class="keyword">do</span></div><div class="line">    touch test_<span class="variable">$i</span>.txt</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p>例子解释：</p>
<ul>
<li>第一行：指定脚本的解释器，这里使用的是/bin/bash</li>
<li>第二行：切换到<code>root</code>用户的家目录</li>
<li>第三行：创建一个目录<code>script</code></li>
<li>第四行：切换到<code>script</code>目录下</li>
<li>第五行：for循环以及循环的条件</li>
<li>第六行：创建一个test_1..10.txt的文件</li>
<li>第七行：循环结束</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> mkdir touch 都是系统內建的程序。</div><div class="line"><span class="keyword">for</span> <span class="keyword">do</span> <span class="keyword">done</span> 是bash脚本语言的关键字。</div></pre></td></tr></table></figure>
<hr>
<div class="note success"><h2 id="shell和shell脚本的概念"><a href="#shell和shell脚本的概念" class="headerlink" title="shell和shell脚本的概念"></a>shell和shell脚本的概念</h2></div>
<p>shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p>
<p>Ken Thompson的sh是第一种Unix Shell，Windows Explorer是一个典型的图形界面Shell。shell脚本（shell script），是一种为shell编写的脚本程序。</p>
<p>业界所说的shell通常都是指shell脚本，但读者朋友要知道，shell和shell script是两个不同的概念。</p>
<p>由于习惯的原因，简洁起见，本文出现的“shell编程”都是指shell脚本编程，不是指开发shell自身（如Windows Explorer扩展开发）。</p>
<p>环境shell编程跟java、php编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p>
<p>OS当前主流的操作系统都支持shell编程，本文档所述的shell编程是指Linux下的shell，讲的基本都是POSIX标准下的功能，所以，也适用于Unix及BSD（如Mac OS）。</p>
<p>LinuxLinux默认安装就带了shell解释器。</p>
<p>Mac OSMac OS不仅带了sh、bash这两个最基础的解释器，还内置了ksh、csh、zsh等不常用的解释器。</p>
<p>Windows上的模拟器windows出厂时没有内置shell解释器，需要自行安装，为了同时能用grep, awk, curl等工具，最好装一个cygwin或者mingw来模拟linux环境。</p>
<p>cygwin<br>mingw</p>
<hr>
<div class="note info"><h2 id="脚本解释器-sh"><a href="#脚本解释器-sh" class="headerlink" title="脚本解释器 sh"></a>脚本解释器 sh</h2></div>
<p>即Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh，由Bell Labs开发。</p>
<p>bashBash是Bourne shell的替代品，属GNU Project，二进制文件路径通常是/bin/bash。业界通常混用bash、sh、和shell，比如你会经常在招聘运维工程师的文案中见到：熟悉Linux Bash编程，精通Shell编程。</p>
<p>在CentOS里，/bin/sh是一个指向/bin/bash的符号链接:<br><img src="http://ww3.sinaimg.cn/large/006tNc79ly1fek5u6o8ltj30zw0bqgq5.jpg" alt=""></p>
<p>但在Mac OS上不是，/bin/sh和/bin/bash是两个不同的文件，尽管它们的大小只相差100字节左右:<br><img src="http://ww1.sinaimg.cn/large/006tNc79ly1fek5vty07dj310006swhd.jpg" alt=""></p>
<hr>
<div class="note danger"><h2 id="运行bash脚本"><a href="#运行bash脚本" class="headerlink" title="运行bash脚本"></a>运行bash脚本</h2></div>
<p>运行shell脚本有两种方法：</p>
<p><strong>1、作为可执行程序</strong></p>
<p>将下面的代码输入到test.sh文件中，并给予权限。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="built_in">cd</span> /root</div><div class="line">mkdir script</div><div class="line"><span class="built_in">cd</span> script</div><div class="line"><span class="keyword">for</span> ((i=0; i&lt;10; i++)); <span class="keyword">do</span></div><div class="line">    touch test_<span class="variable">$i</span>.txt</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p>给予文件执行权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chmod +x test.sh</div></pre></td></tr></table></figure>
<p>执行脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./test.sh</div></pre></td></tr></table></figure>
<p><em>注意：</em></p>
<ul>
<li>一定要写成<code>./test.sh</code>，而不是<code>test.sh</code>，运行其他二进制程序也一样。</li>
<li>直接写成<code>test.sh</code>，系统会去<code>$PATH</code>环境变量中的路径中查找有没有叫<code>test.sh</code>文件。</li>
<li>你的当前目录一般不在<code>$PATH</code>设置的路径中，所以写成<code>test.sh</code>是不会找到命令的，要用<code>./test.sh</code>告诉系统，就在当前目录查找。</li>
</ul>
<p><strong>2、作为解释器参数</strong></p>
<p>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ bash test.sh</div><div class="line">$ sh test.sh</div><div class="line">$ /bin/bash test.sh</div><div class="line">$ /bin/sh test.sh</div></pre></td></tr></table></figure>
<p>这种方式运行的脚本，不用在第一行指定注释信息，也就是<code>shebang</code></p>
<hr>
<div class="note warning"><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2></div>
<p>定义变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ name=value</div><div class="line">或者</div><div class="line">$ name=<span class="string">"value"</span></div></pre></td></tr></table></figure>
<p>注意：变量名和等号之间不能有空格。</p>
<p><strong>变量命名法则：</strong></p>
<ol>
<li>首个字母必须为字母或下划线</li>
<li>中间不能有空格，可以使用下划线</li>
<li>不能程序中的保留字：例如if、for</li>
<li>见名知义</li>
<li>统一命名规则：驼峰原则</li>
</ol>
<p><strong>变量种类</strong></p>
<ol>
<li>本地变量：生效范围为当前shell进程；对当前shell之外的其他shell，包括当前shell的子进程均无效</li>
<li>环境变量：生效范围为当前shell及其它shell进程，使用<code>export</code>定义变量</li>
<li>局部变量：生效范围为当前shell进程中某代码片段，通常在函数里面，使用local定义变量</li>
<li>位置变量：$1,$2,$3，用于让脚本在脚本在代码中调用通过命令行传递给它的参数。</li>
<li>特殊变量：$?,$0,$*,$@,$#</li>
</ol>
<p>除了使用上面那样的方式给变量赋值，还可以用语句给变量赋值，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> I <span class="keyword">in</span> `ls /etc`</div></pre></td></tr></table></figure>
<ul>
<li>说明：上面的意思就是把<code>ls /etc</code>的命令输出结果赋值给变量<code>I</code>，并循环显示出来。</li>
</ul>
<p><strong>使用变量</strong></p>
<p>使用一个定义过的变量，只要在变量名之前加上<code>$</code>符号即可。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ name=<span class="string">"value"</span></div><div class="line">$ <span class="built_in">echo</span> <span class="variable">$value</span></div><div class="line">或者</div><div class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;value&#125;</span></div></pre></td></tr></table></figure>
<p>变量名外的花括号是可选的，可加可不加，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> skill <span class="keyword">in</span> Java Python C Go; <span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"I am good at <span class="variable">$&#123;skill&#125;</span>program."</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p>推荐给所有变量加上花括号，这是shell编程的好习惯。</p>
<p>对于已定义的变量，可以被重新定义，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ name=<span class="string">"value"</span></div><div class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;name&#125;</span></div><div class="line">$ name=<span class="string">"maxie"</span></div><div class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;maxie&#125;</span></div></pre></td></tr></table></figure>
<p><strong>只读变量</strong></p>
<p>使用<code>readonly</code>命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>
<p>下面的例子就说明了这一切：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ name=<span class="string">"maxie"</span></div><div class="line">$ <span class="built_in">readonly</span> name</div><div class="line">$ name=<span class="string">"value"</span></div><div class="line">-bash: name: 只读变量</div></pre></td></tr></table></figure>
<p><strong>删除变量</strong></p>
<p>使用<code>unset</code>命令可以删除变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">unset</span> name</div></pre></td></tr></table></figure>
<p>变量被删除后不能再次被使用，unset命令不能删除只读变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ name=<span class="string">"value"</span></div><div class="line">$ <span class="built_in">unset</span> name</div><div class="line">$ <span class="built_in">echo</span> <span class="variable">$name</span></div></pre></td></tr></table></figure>
<hr>
<div class="note default"><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2></div>
<p>字符串是 shell 编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了）。</p>
<p>字符串可以用单引号，也可以用双引号，也可以不用引号。</p>
<p><strong>单引号</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ str=<span class="string">'this is a string'</span></div></pre></td></tr></table></figure>
<p>单引号的特性：</p>
<ul>
<li>单引号里的任何字符都会原样输出，单引号中的变量不会被替换</li>
<li>单引号里不能出现单引号（嵌套）</li>
</ul>
<p><strong>双引号</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ name=<span class="string">"maxie"</span></div><div class="line">$ HELLO=<span class="string">"Hello, I know u r <span class="variable">$&#123;name&#125;</span>! \n "</span></div></pre></td></tr></table></figure>
<p>双引号的特性：</p>
<ul>
<li>双引号里可以有变量，并且会被替换</li>
<li>双引号可以使转义字符生效</li>
</ul>
<p><strong>获取字符串长度</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ alpha=<span class="string">"abcde"</span></div><div class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;#alpha&#125;</span></div><div class="line">5</div></pre></td></tr></table></figure>
<p><strong>提取字符串</strong></p>
<p>从以下实例的字符串第4个字符开始截取4个字符：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BJ=<span class="string">"BeiJing is a nice city"</span></div><div class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;BJ:3:4&#125;</span></div><div class="line">Jing</div></pre></td></tr></table></figure>
<hr>
<div class="note primary"><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2></div>
<p>Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小</p>
<p>获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。</p>
<p>数组中可以存放多个值，与大部分编程语言类似，数组元素的下标由0开始。</p>
<p><strong>定义数组</strong></p>
<p>在shell中，用括号来表示数组，数组元素用“空格”符号分隔开。</p>
<p>定义数组的一般形式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">数组名=(值1 值2 值3 ... 值n)</div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array=(value1 value2 value3)</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">array=(</div><div class="line">value1</div><div class="line">value2</div><div class="line">value3</div><div class="line">)</div></pre></td></tr></table></figure>
<p>还可以单独定义数组的各个分量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">array[1]=value1</div><div class="line">array[2]=value2</div><div class="line">array[3]=value3</div></pre></td></tr></table></figure>
<p>可以不使用连续的下标，而且下标的范围没有限制。</p>
<p><strong>读取数组</strong></p>
<p>读取数组元素值的一般格式是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$&#123;数组名[下标]&#125;</span></div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">values=<span class="variable">$&#123;array[n]&#125;</span></div></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">my_array=(A B <span class="string">"C"</span> D)</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"第一个元素为: <span class="variable">$&#123;my_array[0]&#125;</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"第二个元素为: <span class="variable">$&#123;my_array[1]&#125;</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"第三个元素为: <span class="variable">$&#123;my_array[2]&#125;</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"第四个元素为: <span class="variable">$&#123;my_array[3]&#125;</span>"</span></div></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ chmod +x test.sh </div><div class="line">$ ./test.sh</div><div class="line">第一个元素为: A</div><div class="line">第二个元素为: B</div><div class="line">第三个元素为: C</div><div class="line">第四个元素为: D</div></pre></td></tr></table></figure>
<p>使用 @ 或者 * 符号可以获取数组中的所有元素，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[@]&#125;</span></div></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line">my_array[0]=A</div><div class="line">my_array[1]=B</div><div class="line">my_array[2]=C</div><div class="line">my_array[3]=D</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"数组的元素为: <span class="variable">$&#123;my_array[*]&#125;</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"数组的元素为: <span class="variable">$&#123;my_array[@]&#125;</span>"</span></div></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ chmod +x test.sh </div><div class="line">$ ./test.sh</div><div class="line">数组的元素为: A B C D</div><div class="line">数组的元素为: A B C D</div></pre></td></tr></table></figure>
<p><strong>获取数组的长度</strong></p>
<p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 取得数组元素的个数</span></div><div class="line">length=<span class="variable">$&#123;#array[@]&#125;</span></div><div class="line"><span class="comment"># 或者</span></div><div class="line">length=<span class="variable">$&#123;#array[*]&#125;</span></div><div class="line"><span class="comment"># 取得数组单个元素的长度</span></div><div class="line">lengthn=<span class="variable">$&#123;#array[n]&#125;</span></div></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line">my_array[0]=A</div><div class="line">my_array[1]=B</div><div class="line">my_array[2]=C</div><div class="line">my_array[3]=D</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"数组元素个数为: <span class="variable">$&#123;#my_array[*]&#125;</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"数组元素个数为: <span class="variable">$&#123;#my_array[@]&#125;</span>"</span></div></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ chmod +x test.sh </div><div class="line">$ ./test.sh</div><div class="line">数组元素个数为: 4</div><div class="line">数组元素个数为: 4</div></pre></td></tr></table></figure>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28695603&auto=1&height=66"></iframe>


<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
<p>本文出自<a href="http://maxiecloud.com" target="_blank" rel="external">Maxie’s Notes</a>博客，转载请务必保留此出处。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;Bash(Bourne Again Shell)，是一款在大多数Linux系统中默认的shell。&lt;br&gt;值得注意的是shell与shell script是两个不同的概念。&lt;br&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;常见的shell&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Bourne Shell (/usr/bin/sh或/bin/sh)&lt;br&gt;Bourne Again Shell (/bin/bash)&lt;br&gt;C Shell (/usr/bin/csh)&lt;br&gt;K Shell (/usr/bin/ksh)&lt;br&gt;Z Shell (/usr/bin/zsh)&lt;br&gt;Shell for Root (/sbin/sh)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要想成为一个使用Linux的dalao，就离不开shell，那么也就是说离不开shell编程。很多时候服务器都需要编写一些计划任务来定时运行的，所以掌握一些基本的shell编程基础很有必要。&lt;/p&gt;
    
    </summary>
    
      <category term="linux基础知识" scheme="http://yoursite.com/categories/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="bash" scheme="http://yoursite.com/tags/bash/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
      <category term="programming" scheme="http://yoursite.com/tags/programming/"/>
    
  </entry>
  
  <entry>
    <title>压缩和解压缩</title>
    <link href="http://yoursite.com/2017/04/08/compression-tool/"/>
    <id>http://yoursite.com/2017/04/08/compression-tool/</id>
    <published>2017-04-08T07:45:32.000Z</published>
    <updated>2017-04-12T13:44:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">压缩的目的<br>时间换空间<br>CPU的时间 –&gt; 磁盘空间<br></blockquote>

<p><strong>常见的压缩文件拓展名：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">*.Z         --compress  压缩文件</div><div class="line">*.gz        --gzip      压缩文件</div><div class="line">*.bz2       --bzip2     压缩文件</div><div class="line">*.xz        --xz        压缩文件</div><div class="line">*.tar       --tar       打包文件,并没有经过压缩</div><div class="line">*.tar.gz    --tar       打包文件,其中并且经过 gzip 的压缩</div><div class="line">*.tar.bz2   --tar       打包文件,其中并且经过 bzip2 的压缩</div><div class="line">*.tar.xz    --tar       打包文件,其中并且经过 xz 的压缩</div></pre></td></tr></table></figure>
<p>Linux上常见的压缩命令就是<code>gzip</code>和<code>bzip2</code>，还有新兴的<code>xz</code>，至于<code>compress</code>已经”退环境”了，不再适合当前的版本了。</p>
<a id="more"></a>
<h1 id="压缩与解压缩工具"><a href="#压缩与解压缩工具" class="headerlink" title="压缩与解压缩工具"></a>压缩与解压缩工具</h1><div class="note primary"><h2 id="compress-uncompress工具"><a href="#compress-uncompress工具" class="headerlink" title="compress/uncompress工具"></a>compress/uncompress工具</h2></div>
<p>compress这个压缩工具是非常老旧的一款，我们现在使用的 CentOS6.8 与 CentOS7 默认都没有安装这个软件到系统当中。如果想在系统中使用，需要先安装 <code>ncompress</code> 这个软件才可以。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum install -y ncompress</div></pre></td></tr></table></figure>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fefcgrj5n0j310y1f4gvr.jpg" alt=""></p>
<p>安装完成之后，我们就可以开始使用 <code>compress</code> 软件来对文件进行压缩/解压缩的操作了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ compress [-cdv] FILE</div><div class="line"></div><div class="line">各选项意义：</div><div class="line">-c          --压缩结果输出至标准输出,不删除原文件</div><div class="line">-d          --解压缩,相当于uncompress</div><div class="line">-v          --显示压缩过程</div></pre></td></tr></table></figure>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwly1fefcs2iv3mj310y0rw44l.jpg" alt=""></p>
<p><strong>注意：</strong>从上图我们可以看出，<code>compress</code> 在压缩文件时，会自动删除原文件。我们使用<code>-c</code>选项，并把标准输出中的内容重定向至一个压缩文件中，这样我们即压缩了文件，又保留了原文件，岂不美哉~</p>
<p>还有一个小tips，就是使用 <code>zcat</code> 命令可以查看 <code>compress</code> 压缩的文件内的文本内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ zcat file.Z</div></pre></td></tr></table></figure>
<hr>
<div class="note success"><h2 id="gzip-gunzip工具"><a href="#gzip-gunzip工具" class="headerlink" title="gzip/gunzip工具"></a>gzip/gunzip工具</h2></div>
<p><code>gzip</code> 可以说是Linux中应用最广泛，使用最多的压缩命令了。使用 <code>gzip</code> 创建的压缩文件的后缀是 <code>*.gz</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ gzip [-cdv<span class="comment">#] FILE</span></div><div class="line"></div><div class="line">各选项意义：</div><div class="line">-c          --将压缩的数据输出至标准输出,可以通过重定向来处理</div><div class="line"><span class="_">-d</span>          --解压缩,相当于gunzip</div><div class="line">-v          --显示压缩过程信息</div><div class="line">-<span class="comment">#          --压缩比，默认为6，越大越好，但也越慢，越耗CPU</span></div></pre></td></tr></table></figure>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fefd4ytimej310y0rwaha.jpg" alt=""></p>
<p>与 <code>compress</code> 类似，使用 <code>gzip</code> 压缩文件后，会自动把原文件删除，所以日常使用时我们要在 <code>gzip</code> 后面加上 <code>-c</code> 选项，再重定向至压缩文件中，这样我们即压缩了文件，也保留了原文件。</p>
<p>而且我们可以对比 <code>compress</code> 看出， <code>gzip</code> 的压缩比明显更好，压缩后的文件占用空间更少；我们还可以使用 <code>zcat</code> 查看压缩后的文件中的内容。</p>
<hr>
<div class="note info"><h2 id="bzip2-bunzip2工具"><a href="#bzip2-bunzip2工具" class="headerlink" title="bzip2/bunzip2工具"></a>bzip2/bunzip2工具</h2></div>
<p>如果说 <code>gzip</code> 是为了替代 <code>compress</code> 出现的，那么 <code>bzip2</code> 就是为了替代 <code>gzip</code> 出现的。 <code>bzip2</code> 的压缩比比 <code>gzip</code> 还要好，但是目前来说使用最广泛的还是 <code>gzip</code>。</p>
<p>让我们看看如何使用 <code>bzip2</code> 吧！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ bzip2 [-cdkv<span class="comment">#] FILE</span></div><div class="line"></div><div class="line">各参数意义：</div><div class="line">-c          --将压缩的数据输出至标准输出,可以通过重定向来处理</div><div class="line"><span class="_">-d</span>          --解压缩,相当于bunzip2</div><div class="line">-v          --显示压缩过程信息</div><div class="line">-<span class="comment">#          --压缩比，默认为6，越大越好，但也越慢，越耗CPU</span></div></pre></td></tr></table></figure>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fefdgfkhb0j310y0rwwlu.jpg" alt=""></p>
<p>使用方法与 <code>gzip</code> 其实并没有什么区别，只是要查看使用 <code>bzip2</code> 压缩的文件内的文本内容，就需要使用 <code>bzcat</code> 这个命令来查看了。</p>
<hr>
<div class="note danger"><h2 id="xz-unxz工具"><a href="#xz-unxz工具" class="headerlink" title="xz/unxz工具"></a>xz/unxz工具</h2></div>
<p><code>xz</code> 是一个使用 <a href="https://zh.wikipedia.org/wiki/LZMA" target="_blank" rel="external">LZMA/LZMA2</a> 压缩算法的无损数据压缩文件格式。和 <code>gzip</code> 与 <code>bzip2</code> 一样，同时支持多文件压缩，但是不能将多于一个目标文件压缩进同一个档案(包)里。<code>xz</code> 生成的压缩文件比 <code>gzip/bzip2</code> 生成的压缩文件更小，而且压缩速度也很快。其生成的压缩文件扩展名为 <code>*.xz</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ xz [-kdv<span class="comment">#]         </span></div><div class="line"></div><div class="line">各选项意义：</div><div class="line">-k          --保留原文件，无需使用重定向</div><div class="line"><span class="_">-d</span>          --解压缩，与unxz效果相同</div><div class="line">-v          --显示压缩时的信息</div><div class="line">-<span class="comment">#          --压缩比，默认为6</span></div></pre></td></tr></table></figure>
<p><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fefjjezcgmj310y0rwjx5.jpg" alt=""></p>
<p>由于压缩的文件比较小，所以对比 <code>gzip/bzip2</code> 的优势不是那么明显，但是也还是可以看出 <code>xz</code> 以略微的优势占领了上风。</p>
<p>使用 <code>xzcat</code>同样可以看到压缩后文件内的文本内容。</p>
<hr>
<h1 id="打包-归档-命令"><a href="#打包-归档-命令" class="headerlink" title="打包(归档)命令"></a>打包(归档)命令</h1><p>上面我们说完了压缩/解压缩命令，但是前面的命令只能压缩单一文件，而不能对目录进行压缩的操作。<br>下面我们讲一讲，如何使用打包命令将目录包成一个大文件。</p>
<div class="note warning"><h2 id="tar工具"><a href="#tar工具" class="headerlink" title="tar工具"></a>tar工具</h2></div>
<p><code>tar</code> 可以将多个目录或文件打包成一个大文件，同时它还可以搭配 <code>gzip/bzip2/xz</code> 将此大文件进行压缩。</p>
<p><code>tar</code> 的参数非常多，下面只列取一些常用的选项</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ tar [-j|-J|-z] [cv] [<span class="_">-f</span> 创建的归档的文件名] FILE         --打包与压缩</div><div class="line">$ tar [-j|-J|-z] [xv] [<span class="_">-f</span> 创建的归档的文件名] [-C 目录]    --此选项是将归档文件解压到指定目录</div><div class="line">$ tar [-j|-J|-z] [tv] [<span class="_">-f</span> 创建的归档的文件名]              --查看归档文件内的文件列表</div><div class="line"></div><div class="line">各选项意义：</div><div class="line">-c          --创建归档文件</div><div class="line"><span class="_">-f</span>          --指定归档的文件名(f必须与归档文件名在一起，例如：cf，xf；而非：<span class="built_in">fc</span>)</div><div class="line">-x          --展开归档，通常与-v，-C结合使用</div><div class="line">-t          --查看归档文件内的文件列表</div><div class="line">-v          --在归档/解包的过程中将正在处理的档名显示出来</div><div class="line">-j          --通过 bzip2 将文件归档并压缩；后缀名最好为 *.tar.bz2</div><div class="line">-J          --通过 xz 将文件归档并压缩；后缀名最好为 *.tar.xz</div><div class="line">-z          --通过 gzip 将文件归档并压缩；后缀名最好为 *.tar.gz</div><div class="line">-C          --解压缩时，指定解压缩的位置</div><div class="line">-P          --保留绝对路径</div><div class="line">-p          --保留文件的原本权限和属性，常用于备份重要的文档</div><div class="line">--exclude=FILE      --压缩的过程中，不要将 FILE 这个文件打包</div></pre></td></tr></table></figure>
<p>其实，在生产环境与日常操作练习时，我们只需使用以下的几种方式即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">压  缩: tar -zcv <span class="_">-f</span> filename.tar.gz</div><div class="line">查  询: tar -ztv <span class="_">-f</span> filename.tar.gz</div><div class="line">解压缩: tar -zxv <span class="_">-f</span> filename.tar.gz</div></pre></td></tr></table></figure>
<p>由于现在流行使用的压缩工具大多是 <code>gz</code> 格式的，我们这里就列举了 <code>gz</code> 的三种操作方法。至于其他两种，替换 <code>-z</code> 即可。</p>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwly1fefkii0eikj310y0rwgsb.jpg" alt=""></p>
<p>上图中，我们可以看到有三个归档文件，是三种不同类型的，我执行了以下的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ tar -zcvf etc.tar.gz /etc</div><div class="line">$ tar -Jcvf etc.tar.xz /etc</div><div class="line">$ tar -jcf etc.tar.bz2 /etc</div></pre></td></tr></table></figure>
<p>通过对比，明显看出 <code>xz</code> 的优势蛮大的，<code>bzip2</code> 与 <code>gzip</code> 倒是不分伯仲。</p>
<p>当我们把/etc目录归档好了之后，就可以使用 <code>-t</code> 选项查看我们备份了哪些目录和文件了。</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fefknl2lvej310y0rwqdp.jpg" alt=""></p>
<p>不过由于文件内容过多，我们只取前10行的内容。</p>
<p>现在我们想把其中的 <code>etc/fstab</code> 文件取出来，就可以使用 <code>tar -zxcf etc.tar.gz etc/fstab</code> 命令取出文件了！</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fefkrjz1iij310608m76k.jpg" alt=""></p>
<p>这样，我们就把归档文件内的 <code>etc/fstab</code> 文件单个取出来来啦！</p>
<p>下面我们将把 <code>etc.tar.gz</code> 文件解压到 <code>/tmp</code> 目录下，这时就需要使用 <code>-C</code> 选项了。</p>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwly1fefl0x01z2j310y0rwgtd.jpg" alt=""></p>
<p>注意 <code>-C</code> 选项的位置，在归档文件名之后，目标位置之前。</p>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28458114&auto=0&height=66"></iframe>

<p>本文出自<a href="http://maxiecloud.com" target="_blank" rel="external">Maxie’s Notes</a>博客，转载请务必保留此出处。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;压缩的目的&lt;br&gt;时间换空间&lt;br&gt;CPU的时间 –&amp;gt; 磁盘空间&lt;br&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;常见的压缩文件拓展名：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;*.Z         --compress  压缩文件&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*.gz        --gzip      压缩文件&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*.bz2       --bzip2     压缩文件&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*.xz        --xz        压缩文件&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*.tar       --tar       打包文件,并没有经过压缩&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*.tar.gz    --tar       打包文件,其中并且经过 gzip 的压缩&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*.tar.bz2   --tar       打包文件,其中并且经过 bzip2 的压缩&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*.tar.xz    --tar       打包文件,其中并且经过 xz 的压缩&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Linux上常见的压缩命令就是&lt;code&gt;gzip&lt;/code&gt;和&lt;code&gt;bzip2&lt;/code&gt;，还有新兴的&lt;code&gt;xz&lt;/code&gt;，至于&lt;code&gt;compress&lt;/code&gt;已经”退环境”了，不再适合当前的版本了。&lt;/p&gt;
    
    </summary>
    
      <category term="linux基础知识" scheme="http://yoursite.com/categories/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="compress" scheme="http://yoursite.com/tags/compress/"/>
    
  </entry>
  
  <entry>
    <title>vim编辑器入门使用教程</title>
    <link href="http://yoursite.com/2017/04/06/how-to-use-vim/"/>
    <id>http://yoursite.com/2017/04/06/how-to-use-vim/</id>
    <published>2017-04-06T05:59:28.000Z</published>
    <updated>2017-04-06T09:59:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">Vim是一个高度可配置的文本编辑器，用于创建和更改任何类型的文本非常高效。<br>它与大多数UNIX系统、Linux系统和Apple OS X一起被列为“vi”<br></blockquote>

<p><strong>vim的功能包括：</strong></p>
<ul>
<li>广泛的插件系统</li>
<li>支持数百种编程语言和文件格式</li>
<li>强大的搜索和替换功能</li>
<li>与许多工具集成</li>
</ul>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwly1fecxo9nswuj31040rw77l.jpg" alt=""></p>
<a id="more"></a>
<hr>
<p>下面是vim添加插件之后的效果，很酷吧！</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fecxocn6odj31040rwq5x.jpg" alt=""></p>
<p>让我们一起来学习如何使用这款风靡各个操作系统之间的文本编辑器吧！</p>
<hr>
<h1 id="vim基本概念"><a href="#vim基本概念" class="headerlink" title="vim基本概念"></a>vim基本概念</h1><p>基本上vim可以分为三种模式。分别是：</p>
<ol>
<li>命令模式（Command mode）</li>
<li>插入模式（Insert mode）</li>
<li>末行模式（Last line mode）</li>
</ol>
<p>各模式的功能如下：</p>
<div class="note primary"><p>（1）命令模式：<br>    在<strong>命令模式</strong>，我们可以控制屏幕光标的移动，字符或行的删除，移动复制文本。在<strong>命令模式</strong>可以随时切换到<strong>插入模式</strong>与<strong>末行模式</strong>。  </p>
</div>
<div class="note success"><p>（2）插入模式：<br>    在<strong>插入模式</strong>，我们可以进行文字的输入、删除、修改等操作。按<strong>[ESC]</strong>键可回到<strong>命令模式</strong>。  </p>
</div>
<div class="note warning"><p>（3）末行模式：<br>    在<strong>末行模式</strong>，我们可以将文件保存或退出vim，也可以设置vim的编辑环境。如设置是否显示行号、括号匹配高亮显示和语法高亮等等。 </p>
</div>
<hr>
<div class="note primary"><h1 id="如何在Linux中使用vim"><a href="#如何在Linux中使用vim" class="headerlink" title="如何在Linux中使用vim"></a>如何在Linux中使用vim</h1></div>
<p>了解了<strong>vim</strong>的三个模式之后，我们就开始学习如何在Linux使用<strong>vim</strong>来编辑文件吧！</p>
<p>在Linux的命令行输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim [FILENAME]</div></pre></td></tr></table></figure>
<p>即可打开文件开始编辑了。</p>
<ul>
<li>如果文件事先存在，这时<strong>vim</strong>将会把存在的文件打开，并把光标移动至文本首行的行首。</li>
<li>如果文件不存在，<strong>vim</strong>将会为我们打开一个新的文件，并让我们编辑。</li>
</ul>
<p><em>下面这张图就是在当前工作目录下打开一个新的文件。（这时我们处在命令模式）</em></p>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwly1fecyffn7vqj310y0rwtaf.jpg" alt=""></p>
<hr>
<div class="note warning"><h2 id="各模式使用方法"><a href="#各模式使用方法" class="headerlink" title="各模式使用方法"></a>各模式使用方法</h2></div>
<p>当我们使用<strong>vim</strong>打开一个文件后的最要紧的就是进行文本的输入，然后保存。<br>所以，熟练掌握各模式之间切换的方法至关重要。</p>
<h3 id="各模式之间切换"><a href="#各模式之间切换" class="headerlink" title="各模式之间切换"></a>各模式之间切换</h3><ul>
<li><strong>命令模式 –&gt; 插入模式</strong></li>
</ul>
<p>使用以下<strong>实体键</strong>可以在命令模式<strong>切换</strong>到插入模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">i:insert,在光标所在处输入</div><div class="line">a:append,在光标所在处的后方输入</div><div class="line">o:在光标所在出下方打开一个新行</div><div class="line">A:在光标所在出的行尾输入</div><div class="line">I:在光标所在处的行首输入</div><div class="line">O:在光标所在处的上方打开一个新行</div></pre></td></tr></table></figure>
<ul>
<li><strong>插入模式 –&gt; 命令模式</strong></li>
</ul>
<p>按<strong>[ESC]</strong>即可从插入模式退出到命令模式。如果为了万全，可以按两次。</p>
<ul>
<li><strong>命令模式 –&gt; 末行模式</strong></li>
</ul>
<p>按 <strong>:</strong> 即可进入到末行模式</p>
<ul>
<li><strong>末行模式 –&gt; 命令模式</strong></li>
</ul>
<p>按<strong>[ESC]</strong>即可从末行模式退出到命令模式。如果为了万全，可以按两次。</p>
<h3 id="命令模式下的操作方法"><a href="#命令模式下的操作方法" class="headerlink" title="命令模式下的操作方法"></a>命令模式下的操作方法</h3><div class="note warning"><h4 id="光标跳转"><a href="#光标跳转" class="headerlink" title="光标跳转"></a>光标跳转</h4></div>
<p><strong>字符间跳转：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">h键          --向左跳转一个字符</div><div class="line">l键          --向右跳转一个字符</div><div class="line">j键          --向下跳转一个字符</div><div class="line">k键          --向上跳转一个字符</div></pre></td></tr></table></figure>
<p>如果键盘上有上、下、左、右箭头的导航键，也可以使用其来完成光标的移动。</p>
<p><strong>单词间跳转：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">w键          --跳到下一个单词的词首</div><div class="line">b键          --跳到当前或前一个单词的词首</div><div class="line">e键          --跳到当前或后一个单词的词尾</div></pre></td></tr></table></figure>
<p><strong>行首/尾间跳转：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">^键          --跳转至行首第一个非空白字符</div><div class="line">0键          --跳转至行首(tab键不算）</div><div class="line">$键          --跳转至行尾</div></pre></td></tr></table></figure>
<p><strong>行间跳转：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#G           --跳转至由#号指定的行的行首</span></div><div class="line">1G/gg        --跳转至第一行的行首(这两种方法都可以)</div><div class="line">G键          --跳转至最后一行的行首</div></pre></td></tr></table></figure>
<p><strong>翻屏操作：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Ctrl+f键         --向文件尾部翻一屏</div><div class="line">Ctrl+b键         --向文件首部翻一屏</div><div class="line">Ctrl+d键         --向文件尾部翻半屏</div><div class="line">Ctrl+u键         --向文件首部翻半屏</div><div class="line">Enter键          --按行向后翻</div><div class="line">b键              --按行向前翻</div></pre></td></tr></table></figure>
<p><strong>当前页跳转：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">H键          --跳转至当前页的页首</div><div class="line">M键          --跳转至当前页的中间行位置</div><div class="line">L键          --跳转至当前页的页底</div></pre></td></tr></table></figure>
<p><strong>句间跳转：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">)键          --跳转至前一句</div><div class="line">(键          --跳转至后一句</div></pre></td></tr></table></figure>
<p><strong>段间跳转：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#125;键          --跳转至前一段</div><div class="line">&#123;键          --跳转至后一段</div></pre></td></tr></table></figure>
<div class="note success"><h4 id="替换和删除"><a href="#替换和删除" class="headerlink" title="替换和删除"></a>替换和删除</h4></div>
<p><strong>字符编辑：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x键          --删除光标所在处的字符</div><div class="line">6x键         --删除光标所在处起始的 6 个字符</div><div class="line">nx键         --删除光标所在处的后 n 个字符</div><div class="line">xp键         --交换光标所在处的字符以及后面字符的位置</div></pre></td></tr></table></figure>
<p><strong>替换命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">r键          --替换光标所在处的字符，用任意键替换当前字符</div><div class="line">nrc键        --用 c 替换光标所在处的后 n 个字符</div><div class="line">6rA         --用 A 替换光标所在处的后 6 个字符</div></pre></td></tr></table></figure>
<p><strong>删除命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">d键          --删除命令，可结合光标跳转字符实现范围删除</div><div class="line">d$键         --删除光标所在处到行尾的字符</div><div class="line">d^键         --删除光标所在处到行首的字符</div><div class="line">dd键         --删除光标所在行</div><div class="line">ndd键        --删除光标所在处的行起始共 n 行</div></pre></td></tr></table></figure>
<p><strong>改变命令：</strong></p>
<p>从<strong>命令模式</strong>执行操作之后直接进入到<strong>插入模式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">c键          --改变命令，工作行为相似于d命令</div><div class="line">c$键         --删除光标所在处至行尾的字符，并进入插入模式</div><div class="line">c^键         --删除光标所在处至行首的字符，并进入插入模式</div><div class="line">cw键         --删除光标所在处至当前词尾的字符，并进入插入模式</div><div class="line">cc键         --删除光标所在的行，并进入插入模式</div></pre></td></tr></table></figure>
<div class="note info"><h4 id="其他操作命令"><a href="#其他操作命令" class="headerlink" title="其他操作命令"></a>其他操作命令</h4></div>
<p><strong>复制粘贴：</strong></p>
<p>在vim从正文中删除的内容并没有真正丢失，而是被剪切并复制到一个内存缓冲区中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p键          --小写字母 p ，将缓冲区的内容粘贴至光标所在处的后方</div><div class="line">P键          --大写字母 P ，将缓冲区的内容粘贴至光标所在处的前方</div></pre></td></tr></table></figure>
<p>如果缓冲区的内容是字符或字，直接粘贴在光标的前面或后面；如果缓冲区的内容为整行正文，执行上述粘贴命令将会粘贴在当前光标所在行的上一行或下一行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">y键          --复制命令</div><div class="line">yy键         --复制当前行到内存缓冲区</div><div class="line">nyy键        --复制 n 行内容到内存缓冲区</div></pre></td></tr></table></figure>
<p><strong>撤销和重复：</strong></p>
<p>在编辑文档的过程中，为消除某个错误的编辑命令造成的后果，可以用撤消命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">u键          --撤销此前的操作</div><div class="line">nu键         --撤销此前 n 个操作</div><div class="line"></div><div class="line">Ctrl+r键     --撤销此前的撤销操作</div><div class="line"></div><div class="line">.键          --重复执行前一个修改正文的命令</div></pre></td></tr></table></figure>
<hr>
<h3 id="插入模式下的操作方法"><a href="#插入模式下的操作方法" class="headerlink" title="插入模式下的操作方法"></a>插入模式下的操作方法</h3><div class="note default"><h4 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a>进入插入模式</h4></div>
<p>在命令模式下定位好光标位置后，可以用以下命令进入到<strong>插入模式</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">i:insert,在光标所在处输入</div><div class="line">a:append,在光标所在处的后方输入</div><div class="line">o:在光标所在出下方打开一个新行</div><div class="line">A:在光标所在出的行尾输入</div><div class="line">I:在光标所在处的行首输入</div><div class="line">O:在光标所在处的上方打开一个新行</div></pre></td></tr></table></figure>
<div class="note danger"><h4 id="退出插入模式"><a href="#退出插入模式" class="headerlink" title="退出插入模式"></a>退出插入模式</h4></div>
<p>退出插入模式的方法是，按 ESC 键或组合键 Ctrl+[ ，退出插入模式之后，将会进入编辑模式 。</p>
<hr>
<h3 id="末行模式下的操作方法"><a href="#末行模式下的操作方法" class="headerlink" title="末行模式下的操作方法"></a>末行模式下的操作方法</h3><p>Vim的<strong>末行模式</strong>下，可以使用复杂的命令。在<strong>命令模式</strong>下键入 : ，光标就跳到屏幕最后一行，并在那里显示冒号，此时已进入末行模式，用户输入的内容均显示在屏幕的最后一行，按回车键，Vim 执行命令。</p>
<div class="note primary"><h4 id="打开、保存、退出"><a href="#打开、保存、退出" class="headerlink" title="打开、保存、退出"></a>打开、保存、退出</h4></div>
<p>在已经启动的vim中打开一个文件需要用<code>:e</code>命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:e /PATH/TO/SOMEFILE</div></pre></td></tr></table></figure>
<p>保存当前编辑的文件需要用<code>:w</code>命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:w</div></pre></td></tr></table></figure>
<p>另存为当前编辑的文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:w /path/to/somefile</div></pre></td></tr></table></figure>
<p>在命令模式下，可以使用<code>:q</code>或者<code>ZZ</code>退出vim</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">:q          --在未修改文件内容的情况下退出</div><div class="line">:q!         --放弃修改，退出vim</div><div class="line">ZZ键        --保存并退出</div><div class="line">:wq         --保存并退出</div></pre></td></tr></table></figure>
<div class="note success"><h4 id="地址定界"><a href="#地址定界" class="headerlink" title="地址定界"></a>地址定界</h4></div>
<p>在命令模式下每一行正文都有自己的行号，用以下命令可以将光标移动至指定行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">:n           --将光标移动至第 n 行</div><div class="line">:.           --表示当前行</div><div class="line">:$           --表示正文的最后一行</div><div class="line">:n,m         --指定行范围，n 为起始行,m为结束行(m&gt;n)</div><div class="line">:n,+n        --指定行范围，n为起始行，+n 为 n 的偏移量。</div><div class="line">:1,$         --第一行至最后一行</div><div class="line">:%           --表示全文</div><div class="line">:233         --将光标移动至第 233 行</div><div class="line">:233w file   --将第 233 行写入 file 文件内</div><div class="line">:3,5w file   --将第 3 行至第 5 行写入file文件内</div><div class="line">:1,.w file   --将第1行至当前行写入 file 文件</div><div class="line">:.,<span class="variable">$w</span> file   --将当前行至最后一行写入 file 文件</div><div class="line">:.,.+5w file --从当前行开始将 6 行内容写入 file 文件</div><div class="line">:1,<span class="variable">$w</span> file   --将所有内容写入 file 文件</div></pre></td></tr></table></figure>
<div class="note info"><h4 id="查找与替换"><a href="#查找与替换" class="headerlink" title="查找与替换"></a>查找与替换</h4></div>
<p><strong>末行模式</strong>可以进行字符串搜索，给出一个字符串，可以通过搜索该字符串到达指定行。如果希望进行正向搜索，将待搜索的字符串置于两个 <strong>/</strong> 之间；如果希望反向搜索，则将字符串放在两个 <strong>？</strong> 之间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:/PATTERN           --正向搜索，将光标移到下一个包含字符串 PATTERN 的行</div><div class="line">:?PATTERN           --反向搜索，将光标移到上一个包含字符串 PATTERN 的行</div></pre></td></tr></table></figure>
<p>使用 <code>n</code> 键进行在匹配到的字符串之间向下跳转<br>使用 <code>N</code> 键进行在匹配到的字符串之间向下跳转</p>
<p>在末行模式也可以对正文内容进行替换的操作，使用 <code>:s</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s/要查找的内容/替换为的内容/修饰符</div><div class="line">:%s/str1/str2/          --用字符串 str2 替换全文行中第一次出现的字符串 str1</div><div class="line">:s/str1/str2/g          --用字符串 str2 替换当前光标所在行中所有的 str1</div><div class="line">:n,ms/str1/str2/g       --将从 n 行到 m 行的所有 str1 替换成 str2</div></pre></td></tr></table></figure>
<p>从上述命令可以看到：</p>
<ul>
<li><code>%</code> 表示替换范围是所有行，即全文内容</li>
<li><code>s</code> 后面跟一串替换的命令</li>
<li><code>g</code> 是修饰符，表示全局替换</li>
<li><code>i</code> 是修饰符，表示查找时忽略字符大小写</li>
<li><code>/</code> 是分隔符，而且此分隔符可以替换成其他特殊字符；如：@、#</li>
</ul>
<p>另外一个实用的命令，统计全文中字符串 <code>str1</code> 出现的次数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:%s/str1/&amp;/gn</div></pre></td></tr></table></figure>
<div class="note warning"><h4 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h4></div>
<p>在末行模式下，也可以实现删除正文的功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">:d                              --删除光标当前所在行</div><div class="line">:nd                             --删除光标所在处的行以及下面 n-1 行的内容</div><div class="line">:.,<span class="variable">$d</span>                           --删除当前行至行尾的内容</div><div class="line">:g/^\(.*\)$\n\1$/d              --删除连续相同的行，保留最后一行</div><div class="line">:g/\%(^\1$\n\)\@&lt;=\(.*\)$/d     --删除连续相同的行，保留最开始一行</div><div class="line">:g/^\s*$\n\s*$/d                --删除连续多个空行，只保留一行空行</div><div class="line">:5,20s/^<span class="comment">#//g                    --删除5到20行开头的 # 注释</span></div></pre></td></tr></table></figure>
<h3 id="定制vim的工作特性"><a href="#定制vim的工作特性" class="headerlink" title="定制vim的工作特性"></a>定制vim的工作特性</h3><p>在末行模式下进行定制，仅对当前 <code>vim</code> 进程有效。</p>
<p>永久有效：</p>
<ol>
<li>全局：/etc/vimrc文件</li>
<li>用户个人：~/.vimrc（一般没有，需要手动创建）</li>
</ol>
<p>使用 <code>:set</code> 命令进行设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:<span class="built_in">set</span> [option]           --选项的设置</div></pre></td></tr></table></figure>
<div class="note warning"><p>常见的功能选项包括</p>
</div>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">autoindent          --设置该选项，则正文自动缩进</div><div class="line">ignorecase          --设置该选项，则忽略规则表达式中大小写字母的区别</div><div class="line">number              --设置该选项，则显示正文行号</div><div class="line">ruler               --设置该选项，则在屏幕底部显示光标所在行、列的位置</div><div class="line">tabstop             --设置按 Tab 键跳过的空格数。例如 :<span class="built_in">set</span> tabstop=n，n 默认值为 8</div><div class="line">hlsearch            --设置该选项，则搜索高亮显示</div><div class="line">syntax              --设置该选项，则启动语法高亮</div><div class="line"><span class="built_in">help</span>                --获取帮助</div></pre></td></tr></table></figure>
<h3 id="分屏功能"><a href="#分屏功能" class="headerlink" title="分屏功能"></a>分屏功能</h3><p>如果想同时查看多个文件，就需要用到 <code>vim</code> 的分屏功能。<br><code>vim</code> 的分屏，主要有两种方式：</p>
<ol>
<li>上下分屏（水平）</li>
<li>左右分屏（垂直）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:sp             --上下分屏</div><div class="line">:vsp            --左右分屏</div></pre></td></tr></table></figure>
<p>也可以在终端的命令行就启用分屏功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ vim -o file1 file2 ...    --水平分屏</div><div class="line">$ vim -O file1 file2 ...    --垂直分屏</div></pre></td></tr></table></figure>
<p>理论上，一个<code>vim</code>窗口可以，可以分为多个屏幕，切换屏幕需要使用键盘组合键以及方向键：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Ctrl+w+←        --切换到当前分屏的左边一屏</div><div class="line">Ctrl+w+→        --切换到当前分屏的右边一屏</div><div class="line">Ctrl+w+↓        --切换到当前分屏的下边一屏</div><div class="line">Ctrl+w+↑        --切换到当前分屏的上边一屏</div></pre></td></tr></table></figure>
<hr>
<h1 id="vim插件"><a href="#vim插件" class="headerlink" title="vim插件"></a>vim插件</h1><p>vim“编辑器之神”的称号并不是浪得虚名，然而，这个荣誉的背后，或许近半的功劳要归功于强大的插件支持特性，以及社区开发的各种各样功能强大的插件。</p>
<p>插件的配置，请参考下面的链接：</p>
<ol>
<li>Vim配置、插件和使用技巧：<a href="http://www.jianshu.com/p/a0b452f8f720" target="_blank" rel="external">http://www.jianshu.com/p/a0b452f8f720</a></li>
<li>手把手教你把Vim改装成一个IDE编程环境：<a href="http://blog.csdn.net/wooin/article/details/1858917" target="_blank" rel="external">http://blog.csdn.net/wooin/article/details/1858917</a></li>
</ol>
<hr>
<h1 id="vim官方文档"><a href="#vim官方文档" class="headerlink" title="vim官方文档"></a>vim官方文档</h1><ol>
<li>vim官方文档：<a href="http://vimdoc.sourceforge.net/" target="_blank" rel="external">http://vimdoc.sourceforge.net/</a></li>
<li>vim维基中文文档：<a href="https://wiki.archlinux.org/index.php/Vim_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">https://wiki.archlinux.org/index.php/Vim_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87</a>)</li>
</ol>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29378196&auto=0&height=66"></iframe>

<p>本文出自<a href="http://maxiecloud.com" target="_blank" rel="external">Maxie’s Notes</a>博客，转载请务必保留此出处。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
<!--author：maxie（马驰原）-->
<!--QQ：17045930-->
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;Vim是一个高度可配置的文本编辑器，用于创建和更改任何类型的文本非常高效。&lt;br&gt;它与大多数UNIX系统、Linux系统和Apple OS X一起被列为“vi”&lt;br&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;vim的功能包括：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;广泛的插件系统&lt;/li&gt;
&lt;li&gt;支持数百种编程语言和文件格式&lt;/li&gt;
&lt;li&gt;强大的搜索和替换功能&lt;/li&gt;
&lt;li&gt;与许多工具集成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://ww2.sinaimg.cn/large/006tNbRwly1fecxo9nswuj31040rw77l.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux基础知识" scheme="http://yoursite.com/categories/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之十四  [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%8D%81%E5%9B%9B/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之十四/</id>
    <published>2017-04-02T12:50:05.000Z</published>
    <updated>2017-04-02T13:48:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"> [^ ] 跟[! ]差在哪？ (RE: Regular Expression）<br></blockquote></p>
<hr>
<h3 id="Regular-Expression-正则表达式"><a href="#Regular-Expression-正则表达式" class="headerlink" title="Regular Expression (正则表达式)"></a>Regular Expression (正则表达式)</h3><hr>
<p>接下来的Regular Expression(RE) 可是个大题目，要讲的很多。<br>我这里当然不可能讲得很全。<br>只希望能带给大家一个基本的入门概念，就很足够了…</p>
<p>先来考一下英文好了：What is expression?<br>简单来说，就是”表达”，也就是人们在沟通的时候所要陈述的内容。</p>
<p>然而，生活中，表达方要清楚的将意思描述清楚，<br>而让接收方完整无误地领会，可不是件容易的事情。</p>
<p>因而才会出现那么多的”误会”, 真可叹句”表达不易”啊……</p>
<a id="more"></a>
<p>同样的情形也发生在计算机的数据处理过程中，<br>尤其是当我们在描述一段”文字内容”的时候….<br>那么，我们不禁要问：<br>有何方法可以让大家的误会降至最低程度，<br>而让表达的精确度达到最高程度呢？<br>答案就是”标准化”了，<br>也就是我们这里要谈的<code>Regular Expression</code>啦…^_^</p>
<p>然而，在进入<code>RE</code>介绍之前，不妨先让我们温习一下shell十三问之第4问，<br>那就是关于quoting的部分。</p>
<p><strong>关键是要能够区分 shell command line上的meta与literal的这两种不同的字符类型</strong>。</p>
<p>然后，我这里也跟你讲：<br><strong>RE 表达式里字符也分meta与literal这两种</strong>。</p>
<p>呵，不知亲爱的读者是否被我搞混乱了呢？… ^_^</p>
<p>这也难怪啦，因为这的确是最容易混淆的地方，<br>刚学<code>RE</code>的朋友很多时候，都死在这里！<br>因此，请特别小心理解哦…</p>
<p>简单而言，除非你将<code>RE</code>写在特定程序使用的脚本里，<br>否则，我们的<code>RE</code>也是通过 command line输入的。<br>然而，<br><strong>不少RE所使用的meta字符，跟shell 的meta字符是冲突的</strong>。</p>
<p>比方说，<br><strong><code>*</code>这个字符，在RE里是一个modifier(修饰符);而在command line上，确是wildcard(通配符)</strong>。</p>
<p>那么，我们该如何解决这样的冲突呢？<br>关键就是看你对shell十三问的第4问中所提的quoting是否足够理解了！</p>
<p>若你明白到<br><strong>shell quoting 就是用来在command line上关闭shell meta这一基本原理</strong>，<br>那你就能很轻松的解决 RE meta与shell meta的冲突问题了：<br><strong>用shell quoting 关闭掉shell meta就是了</strong>。<br>就这么简单… ^_^</p>
<p>再以刚提到<code>*</code>字符为例，<br>若在command line的path中没有quoting处理的话，<br>如abc* 就会被作为wildcard expression来扩充及重组了。<br>若将其置于quoting中，即”abc*“，则可以避免wildcard expand的处理。</p>
<p>好了，说了大半天，还没有进入正式的RE介绍呢….<br>大家别急，因为我的教学风格就是要先建立基础，循序渐进的… ^_^<br>因此, 我这里还要再啰嗦一个观念，才会到RE的说明啦…(哈…别打我…)</p>
<p>当我们在谈到RE时，千万别跟wildcard搞混在一起！<br>尤其是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">在command line的位置里，wildcard只作用于argument的path上；</div><div class="line">而RE却只用于&quot;字符串处理&quot; 的程序中，这与路径名一点关系也没有。</div></pre></td></tr></table></figure></p>
<blockquote>
<p> <strong>Tips:</strong><br> RE 所处理的字符串，通常是指纯文本或通过stdin读进的内容。</p>
</blockquote>
<p>okay，够了够了，我已看到一堆人开始出现不耐烦的样子了… ^_^<br>现在，就让我们登堂入室，揭开RE的神秘面纱吧，<br>这样可以放过我了吧？ 哈哈…</p>
<p>在RE的表达式里，主要分为两种字符：<code>literal</code>与<code>meta</code>。<br>所谓<code>literal</code>就是在RE里不具有特殊功能的字符，如abc，123等；<br>而<code>meta</code>,在RE里具有特殊的功能。<br>要关闭之，需要在<code>meta</code>之前使用escape()转义字符。</p>
<p>然而，在介绍<code>meta</code>之前，先让我们来认识一下字符组合(character set)会更好些。</p>
<p>一、所谓的char set就是将多个连续的字符作为一个集合。<br>例如：</p>
<table>
<thead>
<tr>
<th>char set</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>abc</td>
<td>表示abc三个连续的字符，但彼此独立而非集合。(可简单视为三个char set)</td>
</tr>
<tr>
<td>(abc)</td>
<td>表示abc这三个连续字符的集合。(可简单视为一个char set)</td>
</tr>
<tr>
<td>abc\</td>
<td>xyz</td>
<td>表示abc或xyz这两个char set之一</td>
</tr>
<tr>
<td>[abc]</td>
<td>表示单一字符，可为a或b或c;与wildcard的[abc]原理相同，称之为字符类。</td>
</tr>
<tr>
<td>[^abc]</td>
<td>表示单一字符，不为a或b或c即可。(与wildcard [!abc]原理相同)</td>
</tr>
<tr>
<td>.</td>
<td>表示任意单个字符，(与wildcard的?原理相同)</td>
</tr>
</tbody>
</table>
<p>note: abc|xyz  表示abc或xyz这两个char set之一</p>
<p>在认识了RE的char set这个概念之后，然后，在让我们多认识几个RE中常见的meta字符：</p>
<p>二、 锚点(anchor): 用以标识RE在句子中的位置所在。<br>常见的有：  </p>
<table>
<thead>
<tr>
<th>锚点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>表示句首。如，^abc表示以abc开头的句子。</td>
</tr>
<tr>
<td>$</td>
<td>表示句尾。如，abc$表示以abc结尾的句子。</td>
</tr>
<tr>
<td>\&lt;</td>
<td>表示词首。如，\&lt;abc表示以abc开头的词。</td>
</tr>
<tr>
<td>\&gt;</td>
<td>表示词尾。如，abc\&gt;表示以abc结尾的词。</td>
</tr>
</tbody>
</table>
<p>三、 修饰符(modifier)：独立表示时本身不具意义，专门用以修饰前一个char set出现的次数。<br>常见的有：</p>
<table>
<thead>
<tr>
<th>modifier</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>表示前一个char set出现0次或多次，即任意次。如ab*c表示a与c之间可以有0个或多个b。</td>
</tr>
<tr>
<td>?</td>
<td>表示前一个char set出现0次或1次，即至多出现1次。如ab?c 表示a与c之间可以有0个或1个b。</td>
</tr>
<tr>
<td>+</td>
<td>表示前一个char set出现1次或多次，即至少出现1次。如ab+c 表示a与c之间可以有1个或多个b。</td>
</tr>
<tr>
<td>{n}</td>
<td>表示前一个char set出现n次。如ab{n}c 表示a与c之间可以有n个b。</td>
</tr>
<tr>
<td>{n, }</td>
<td>表示前一个char set至少出现n次。如ab{n}c 表示a与c之间至少有n个b。</td>
</tr>
<tr>
<td>{n, m}</td>
<td>表示前一个char set至少出现n次，至多出现m次。如ab{n，m}c 表示a与c之间至少有n个b，至多有m个b。</td>
</tr>
</tbody>
</table>
<p>然而，当我们在识别modifier时，却很容易忽略”边界(boundary)字符”的重要性。</p>
<p>以<code>ab{3,5}c</code>为例，这里的a与c就是边界字符了。<br>若没有边界字符的帮忙，我们很容易做出错误的解读。<br>比方说: 我们用<code>ab{3,5}</code>这个RE（少了c这个边界字符)<br>可以抓到”abbbbbbbbbb”(a后面有10个b)的字符串吗？<br>从刚才的modifier的说明，我们一般认为，我们要的b是3到5个，<br>若超出了此范围，就不是我们所要表达的。<br>因此，我们或许会很轻率地认为这个RE抓不到结果（上述”abbbbbbbbbb”字符串）。</p>
<p>然而，答案却是可以的！为什么呢？<br>让我们重新解读<code>ab{3,5}</code>这个RE看看：<br>我们要表达的是a后接3到5个b即可，但3到5个b后面，我们却没有规定什么，<br>因此，在RE后面可以是任意的字符串，当然包括b也可以啦！(明白了吗？)</p>
<p>同样，我们用<code>b{3,5}c</code>也同样可以抓到”abbbbbbbbbbc”<br>这样的字符串。</p>
<p>但当我们用<code>ab{3,5}c</code>这样的RE时，<br>由于同时有a与c这连个边界字符，就截然不同了！</p>
<p>有空在思考一下，为何我们用下面这些RE都抓到abc这样的字符串呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x*</div><div class="line">ax*, abx*, ax*b</div><div class="line">abcx*, abx*c, ax*bc</div><div class="line">bx*c, bcx*, x*bc</div></pre></td></tr></table></figure></p>
<p>但, 若我们在这些RE前后分别加<code>^</code>与<code>$</code>这样的anchor，那又如何呢？</p>
<p>刚学RE时，只要能掌握上面这些基本的meta的大概就可以入门了。<br>一如前述，RE是一种规范化的文字表达式，<br>主要用于某些文字处理工具之间，如：<br>grep， perl， vi，awk，sed，等等，<br>常用于表示一段连续的字符串，查找和替换。</p>
<p>然而每种工具对RE表达式的具体解读或有一些细微差别，<br>不过节本原理还是一致的。<br>只要掌握RE的基本原理，那就一理通百理了，<br>只是在实践时，稍加变通即可。</p>
<p>比方以grep来说，<br>在Linux上，你可以找到grep，egrep，fgrep这些程序，<br>其差异大致如下：</p>
<p>grep： 传统的grep程序，在没有任何选项(options)的情况下，只输出符合RE字串的句子，<br> 其常见的选项如下：</p>
<table>
<thead>
<tr>
<th>选项 (option)</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>-v</td>
<td>反模式，  只输出“不含”RE的字符串的行。</td>
</tr>
<tr>
<td>-r</td>
<td>　递归模式，可同时处理所有层级的子目录里的文件</td>
</tr>
<tr>
<td>-q</td>
<td>静默模式，不输出任何结果(stderr 除外，常用于获取return value，符合为true，否则，为false.</td>
</tr>
<tr>
<td>-i</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>-w</td>
<td>整词匹配，类似 \<re\></re\></td>
</tr>
<tr>
<td>-n</td>
<td>同时输出行号</td>
</tr>
<tr>
<td>-l</td>
<td>输出匹配RE的文件名</td>
</tr>
<tr>
<td>-o</td>
<td>只输出匹配RE的字符串。(gnu新版独有，不见得所有版本支持)</td>
</tr>
<tr>
<td>-E</td>
<td>切换为egrep</td>
</tr>
</tbody>
</table>
<p>egrep：为grep的扩充版本，改良了许多传统grep不能或者不便的操作，</p>
<ul>
<li>grep下不支持<code>?</code>与<code>+</code>这两种meta，但egrep支持；</li>
<li>grep 不支持<code>a|b</code>或（<code>abc|xyz</code>）这类“或一”的匹配，但egrep支持；</li>
<li>grep 在处理<code>{n,m}</code>时，需要\{ 与 \}处理，但egrep不需。</li>
</ul>
<p>等诸如此类的。我个人建议能用egrep就不用grep啦…^_^</p>
<p>fgrep: 不作RE处理，表达式仅作一般的字符串处理，所有的meta均市区功能。</p>
<p>好了，关于RE的入门，我们暂时就介绍到这里。<br>虽然有点乱，且有些观念也不恨精确，<br>不过，姑且算是对大家的一个交差吧…^_^<br>若这两天有时间的话，我在举些范例来分析一下，以帮助大家更好的理解。<br>假如更有可能的话，也顺道为大家介绍一下sed这个工具。</p>
<hr>
<h3 id="Part-III-eval"><a href="#Part-III-eval" class="headerlink" title="Part-III eval"></a>Part-III eval</h3><hr>
<p>讲到command line的重组特性，<br>真的需要我们好好的加以解释的。</p>
<p>如此便能抽丝剥茧的一层层的将整个command line分析的<br>一清二楚，而不至于含糊。</p>
<p>假如这个重组的特性理解了，那我们介绍一个好玩的命令：<code>eval</code>.</p>
<p>我们在变量替换的过程中，常会碰到所谓的复式变量的问题：<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a=1</div><div class="line">A1=abc</div></pre></td></tr></table></figure></p>
<p>我们都知道<code>echo $A1</code>就可以得到abc的结果。<br>然而，我们能否用$A$a来取代$A1，而同一样替换为abc呢？</p>
<p>这个问题我们可用很轻松的用<code>eval</code>来解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eval echo \$A$a</div></pre></td></tr></table></figure></p>
<p>说穿了，<code>eval</code> 只不过是在命令行完成替换重组后，<br>在来一次替换重组罢了…<br>就是这么简单啦～～～ ^_^</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt; [^ ] 跟[! ]差在哪？ (RE: Regular Expression）&lt;br&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Regular-Expression-正则表达式&quot;&gt;&lt;a href=&quot;#Regular-Expression-正则表达式&quot; class=&quot;headerlink&quot; title=&quot;Regular Expression (正则表达式)&quot;&gt;&lt;/a&gt;Regular Expression (正则表达式)&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;接下来的Regular Expression(RE) 可是个大题目，要讲的很多。&lt;br&gt;我这里当然不可能讲得很全。&lt;br&gt;只希望能带给大家一个基本的入门概念，就很足够了…&lt;/p&gt;
&lt;p&gt;先来考一下英文好了：What is expression?&lt;br&gt;简单来说，就是”表达”，也就是人们在沟通的时候所要陈述的内容。&lt;/p&gt;
&lt;p&gt;然而，生活中，表达方要清楚的将意思描述清楚，&lt;br&gt;而让接收方完整无误地领会，可不是件容易的事情。&lt;/p&gt;
&lt;p&gt;因而才会出现那么多的”误会”, 真可叹句”表达不易”啊……&lt;/p&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之十三  [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%8D%81%E4%B8%89/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之十三/</id>
    <published>2017-04-02T12:49:59.000Z</published>
    <updated>2017-04-02T13:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">[^ ] 跟[! ]差在哪？ (wildcard)<br></blockquote>


<p>这个题目说穿了，<br>就是要探讨Wildcard与Regular Expression的差别的。<br>这也是很多初学shell的朋友很容易混淆的地方。</p>
<a id="more"></a>
<p>首先，让我们回到十三问之第2问，<br>再一次将我们提到的command line format 温习一次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">command_name options arguments</div></pre></td></tr></table></figure>
<p>同时，也再来理解一下，我在第5章所提到的变量替换的特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">先替换，再重组 command line!</div></pre></td></tr></table></figure></p>
<p>有了这个两个基础后，再让我们来看Wildcard是什么回事吧。</p>
<h3 id="Part-I-Wildcard-（通配符）"><a href="#Part-I-Wildcard-（通配符）" class="headerlink" title="Part-I Wildcard （通配符）"></a>Part-I Wildcard （通配符）</h3><hr>
<p>首先，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`Wildcard` 也是属于 `command line` 的处理工序，作用于 `arguments` 里的 `path` 之上。</div></pre></td></tr></table></figure></p>
<p>没错，它不用在<code>command_name</code>，也不用在<code>options</code>上。<br>而且，若argument不是path的话，那也与wildcard无关。</p>
<p>换句更为精确的定义来讲，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`wildcard`是一种命令行的路径扩展(path expansion)功能。</div></pre></td></tr></table></figure></p>
<p>提到这个扩展，那就不要忘了 command line的“重组”特性了！</p>
<p>是的，这与<code>变量替换</code>(variable subtitution)及<br><code>命令替换</code>(command substitution)的重组特性是一样的。</p>
<p>也就是在<code>wildcard</code>进行扩展后，<br>命令行会先完成重组，才会交给shell来处理。</p>
<p>了解了<code>wildcard</code>的扩展与重组特性后，<br>接下来，让我们了解一些常见的wildcard吧。 </p>
<table>
<thead>
<tr>
<th>wildcard</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配0个或多个字符</td>
</tr>
<tr>
<td>?</td>
<td>匹配任意单一字符</td>
</tr>
<tr>
<td>[list]</td>
<td>匹配list中任意单一字符</td>
</tr>
<tr>
<td>[!list]</td>
<td>匹配不在list中任意单一字符</td>
</tr>
<tr>
<td>{string1,string2,…}</td>
<td>匹配string1或者stsring2或者(…)中其一字符串</td>
</tr>
</tbody>
</table>
<p>Note:<br>  list 中可以指定单个字符，如abcd,<br> 也可以指定ASCII字符的起止范围，如 a-d。<br>  即[abcd] 与 [a-d] 是等价的，称为一个自定义的字符类。</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a*b     # a 与 b 之间可以有任意个字符（0个或多个），如aabcb, axyzb, a012b,ab等。</div><div class="line">a?b     # a 与 b 之间只能有一个字符，但该字符可以任意字符，如 aab, abb, acb, azb等。</div><div class="line">a[xyz]b # a 与 b 之间只能有一个字符，但这个字符只能是x或者y或者z，如：axb, ayb, azb这三个。</div><div class="line">a[!0-9]b# a 与 b 之间只能有一个字符，但这个字符不能是阿拉伯数字，如aab，ayb，a-b等。</div><div class="line">a&#123;abc,xyz,123&#125;b # a 与 b之间只能是abc或者xyz或者123这三个字串之一，扩展后是aabcb，axyzb，a123b。</div></pre></td></tr></table></figure></p>
<ol>
<li><p><code>[! ]</code> 中的<code>!</code> 只有放在第一位时，才有取反的功效。<br>eg:<br> <code>[!a]*</code> 表示当前目录下不以a开头的路径名称；<br> <code>/tmp/[a\!]*</code>表示/tmp目录下所有以a 或者 ! 开头的路径名称；</p>
<p> 思考：为何!前面要加\呢？提示是十三问之4.</p>
</li>
<li><p><code>[ - ]</code>中<code>-</code>左右两边均有字符时，才表示一个范围，否则,仅作<code>-</code>(减号)字符来处理。<br>举例：<br> <code>/tmp/*[-z]/[a-zA-Z]*</code> 表示/tmp 目录下所有以z或者-结尾的子目录中，<br> 以英文字母(不分大小写)开头的目录名称。</p>
</li>
<li><p>以*或?开头的wildcard不能匹配隐藏文件(即以.开头的文件名)。<br>eg:<br> <code>*.txt</code>并不能匹配<code>.txt</code>但能匹配1.txt这样的路径名。<br> 但1*txt及1?txt均可匹配1.txt这样的路径名。</p>
</li>
</ol>
<p>基本上，要掌握wildcard并不难，<br>只要多加练习，再勤于思考，就能灵活运用了。</p>
<p>再次提醒：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">别忘了wildcard的&quot;扩展&quot; + &quot;重组&quot; 这个重要特性，而且只作用在 argument的path上。</div></pre></td></tr></table></figure></p>
<p>比方说，<br>假如当前目录下有：<br>a.txt b.txt c.txt 1.txt 2.txt 3.txt 这几个文件。</p>
<p>当我们在命令行中执行<code>ls -l [0-9].txt</code>的命令行时，<br>因为wildcard处于argument的位置上，</p>
<p>于是根据匹配的路径，扩展为: 1.txt 2.txt 3.txt，<br>在重组出<code>ls -l 1.txt 2.txt 3.txt</code> 这样的命令行。</p>
<p>因此，你在命令行上敲 <code>ls -l [0-9].txt</code><br>与 <code>ls -l 1.txt 2.txt 3.txt</code> 输出的结果是一样，<br>原因就是在于此。</p>
<h2 id="shell是十三问的总结语"><a href="#shell是十三问的总结语" class="headerlink" title="shell是十三问的总结语"></a>shell是十三问的总结语</h2><hr>
<p>好了，该是到了结束的时候了。<br>婆婆妈妈地跟大家啰嗦了一堆shell的基础概念。</p>
<p>目的不是要告诉大家“答案”，而是要带给大家“启发”…</p>
<p>在日后的关于shell的讨论中，我或许经常用”连接”的方式<br>指引十三问中的内容。</p>
<p>以便我们在进行技术探讨时，彼此能有一些讨论的基础，<br>而不至于各说各话、徒费时力。</p>
<p>但更希望十三问能带给你更多的思考与乐趣，<br>至为重要的是通过实践来加深理解。</p>
<p>是的，我很重视<strong>实践</strong>与<strong>独立思考</strong>这两项学习要素。</p>
<p>若你能够掌握其中的真谛，那请容我说声：<br><strong>恭喜十三问你没白看了</strong> ^_^</p>
<p>p.s.<br>至于补充问题部分，我暂时不写了。<br>而是希望：</p>
<ol>
<li>大家补充题目。</li>
<li>一起来写心得。</li>
</ol>
<p>Good luck and happy studing！</p>
<hr>
<h2 id="shell十三问原作者网中人签名中的bash的fork-bomb"><a href="#shell十三问原作者网中人签名中的bash的fork-bomb" class="headerlink" title="##shell十三问原作者网中人签名中的bash的fork bomb"></a>##shell十三问原作者<strong><code>网中人</code></strong>签名中的bash的fork bomb</h2><p>最后，Markdown整理者补上本书的原作者<strong>网中人</strong>的个性签名：</p>
<blockquote>
<p><strong> 君子博学而日叁省乎己，则知明而行无过矣。</strong></p>
<p>一个能让系统shell崩溃的shell 片段：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:() &#123; :|:&amp; &#125;; :      # &lt;--- 这个别乱跑！好奇会死人的！</div><div class="line">echo &apos;十人|日一|十十o&apos; | sed &apos;s/.../&amp;\n/g&apos;   # &lt;--- 跟你讲就不听，再跑这个就好了...</div></pre></td></tr></table></figure>
<p>原来是一个bash的fork炸弹：ref：<a href="http://en.wikipedia.org/wiki/Fork_bomb" target="_blank" rel="external">http://en.wikipedia.org/wiki/Fork_bomb</a></p>
<p>整理后的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">:() &#123;</div><div class="line">	</div><div class="line">	:|:&amp;</div><div class="line">&#125;</div><div class="line">:</div></pre></td></tr></table></figure></p>
<blockquote>
<p>代码分析：</p>
<p>(即除最后一行外)</p>
<p>定义了一个 shell 函数，函数名是<code>:</code>，</p>
<p>而这个函数体执行一个后台命令<code>:|:</code> </p>
<p>即冒号命令(或函数，下文会解释)的输出<br>通过管道再传给冒号命令做输入</p>
<p>最后一行执行“:”命令</p>
</blockquote>
<p>在各种shell中运行结果分析：</p>
<blockquote>
<p>这个代码只有在 <strong>bash</strong> 中执行才会出现不断创建进程而耗尽系统资源的严重后果;</p>
<p>在 ksh (Korn shell), sh (Bourne shell)中并不会出现，</p>
<p>在 ksh88 和传统 unix Bourne shell 中冒号不能做函数名，</p>
<p>即便是在 unix-center freebsd 系统中的 sh 和 pdksh（ksh93 手边没有，没试）中冒号可以做函数名，但还是不会出现那个效果。</p>
<p>原因是 sh、ksh 中内置命令的优先级高于函数，所以执行“:”，<br>总是执行内置命令“:”而不是刚才定义的那个恐怖函数。</p>
<p>但是在 <strong>bash</strong> 中就不一样，bash 中函数的优先级高于内置命令，<br>所以执行“:”结果会导致不断的递归，而其中有管道操作，<br>这就需要创建两个子进程来实现，这样就会不断的创建进程而导致资源耗尽。</p>
</blockquote>
<p>众所周知，bash是一款极其强大的shell，提供了强大的交互与编程功能。</p>
<p>这样的一款shell中自然不会缺少“函数”这个元素来帮助程序进行模块化的高效开发与管理。<br>于是产生了由于其特殊的特性，bash拥有了fork炸弹。</p>
<p>Jaromil在2002年设计了最为精简的一个fork炸弹的实现。</p>
<blockquote>
<p>所谓fork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环.</p>
<p>fork炸弹并不需要有特别的权限即可对系统造成破坏。</p>
<p>fork炸弹实质是一个简单的递归程序。</p>
<p>由于程序是递归的，如果没有任何限制，</p>
<p>这会导致这个简单的程序迅速耗尽系统里面的所有资源.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;[^ ] 跟[! ]差在哪？ (wildcard)&lt;br&gt;&lt;/blockquote&gt;


&lt;p&gt;这个题目说穿了，&lt;br&gt;就是要探讨Wildcard与Regular Expression的差别的。&lt;br&gt;这也是很多初学shell的朋友很容易混淆的地方。&lt;/p&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之十二  [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%8D%81%E4%BA%8C/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之十二/</id>
    <published>2017-04-02T12:49:55.000Z</published>
    <updated>2017-04-02T13:43:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">for what？ while与until差在哪？<br></blockquote></p>
<hr>
<p>今天要介绍的是shell script设计中常见的<code>循环</code>(<code>loop</code>).<br>所谓的<code>loop</code>就是script中的一段在一定条件下反复执行的代码。</p>
<p>bash shell中常用的<code>loop</code>有如下三种：</p>
<ul>
<li>for</li>
<li>while</li>
<li>until</li>
</ul>
<a id="more"></a>
<p>###1. for loop</p>
<hr>
<p><code>for</code> loop 是从一个清单列表中读进变量的值，<br>并依次的循环执行<code>do</code>到<code>done</code>之间的命令行。<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for var in one two three four five</div><div class="line">do</div><div class="line">    echo -----------------</div><div class="line">	echo &apos;$var is &apos;$var</div><div class="line">	echo</div><div class="line">done</div></pre></td></tr></table></figure></p>
<blockquote>
<p> 上例的执行结果将会是：</p>
<ol>
<li><p>for会定义一个叫var的变量，其值依次是one two three four five。</p>
<ol>
<li><p>因为有5个变量值，因此，<code>do</code>与<code>done</code>之间的命令行会被循环执行5次。</p>
</li>
<li><p>每次循环均用<code>echo</code>产生3个句子。而第二行中不在hard quote之内的$var会被替换。</p>
</li>
<li><p>当最后一个变量值处理完毕，循环结束。</p>
</li>
</ol>
</li>
</ol>
</blockquote>
<p>我们不难看出，在<code>for</code> loop中，变量值的多寡，决定循环的次数。<br>然而，变量在循环中是否使用则不一定，得视设计需求而定。<br>倘若<code>for</code> loop没有使用in这个keyword来制变量清单的话，其值将从<br><code>$@</code>(或<code>$*</code>)中继承：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for var; do</div><div class="line">	......</div><div class="line">done</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Tips:</strong></p>
<p>若你忘记了`positional parameter, 请温习第9章…</p>
</blockquote>
<p><code>for</code> loop用于处理“清单”(list)项目非常方便，<br>其清单除了明确指定或从<code>postional parameter</code>取得之外，<br>也可以从<code>变量替换</code>或者<code>命令替换</code>取得…<br>(再一次提醒：别忘了命令行的“重组”特性)<br>然而，对于一些“累计变化”的项目(整数的加减)，for也能处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for ((i = 1; i &lt;= 10; i++))</div><div class="line">do</div><div class="line">	echo &quot;num is $i&quot;</div><div class="line">done</div></pre></td></tr></table></figure></p>
<h2 id="2-while-loop"><a href="#2-while-loop" class="headerlink" title="###2. while loop"></a>###2. while loop</h2><p>除了<code>for</code> loop, 上面的例子，<br>我们也可改用<code>while</code> loop来做到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">num=1</div><div class="line">while [ &quot;$num&quot; -le 10 ]; do</div><div class="line">	echo &quot;num is $num&quot;</div><div class="line">	num=$(($num + 1))</div><div class="line">done</div></pre></td></tr></table></figure></p>
<p><code>while</code> loop的原理与<code>for</code> loop稍有不同：<br>它不是逐次处理清单中的变量值，<br>而是取决于<code>while</code> 后面的命令行的return value：</p>
<ul>
<li>若为true， 则执行<code>do</code>与<code>done</code>之间的命令，<br>然后重新判断<code>while</code>后的return value。</li>
<li>若为false，则不再执行<code>do</code>与<code>done</code>之间的命令而结束循环。</li>
</ul>
<blockquote>
<p>分析上例：</p>
<ol>
<li><p>在<code>while</code>之前，定义变量num=1.</p>
<ol>
<li>然后测试(<code>test</code>)$num是否小于或等于10.</li>
</ol>
</li>
<li><p>结果为true，于是执行<code>echo</code>并将num的值加1.</p>
</li>
<li><p>再作第二轮测试，此时num的值为1+1=2，依然小于或等于10，因此，为true，循环继续。</p>
</li>
<li><p>直到num为10+1=11时，测试才会失败…于是结束循环。</p>
</li>
</ol>
</blockquote>
<p>我们不难发现：<br><strong>若<code>while</code>的测试结果永远为true的话，那循环将一直永久执行下去</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while:; do</div><div class="line">	echo looping...</div><div class="line">done</div></pre></td></tr></table></figure>
<p>上面的<strong><code>:</code>是bash的null command，不做任何动作，<br>除了返回true的return value</strong>。<br>因此这个循环不会结束，称作死循环。</p>
<p>死循环的产生有可能是故意设计的(如跑daemon)，<br>也可能是设计的错误。</p>
<p>若要结束死循环，可通过signal来终止(如按下ctrl-c).<br>(关于process与signal，等日后有机会再补充，十三问略过。)</p>
<h2 id="3-until-loop"><a href="#3-until-loop" class="headerlink" title="####3.until loop"></a>####3.until loop</h2><p>一旦你能够理解<code>while</code> loop的话，那就能理解<code>until</code> loop:<br>**与<code>while</code>相反， <code>until</code>是在return value 为false时进入循环，否则，结束。<br>因此，前面的例子，我们也可以轻松的用<code>until</code>来写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">num=1</div><div class="line">until [ ! &quot;$num&quot; -le 10 ]; do</div><div class="line">	echo &quot;num is $num&quot;</div><div class="line">	num=$(($num + 1))</div><div class="line">done</div></pre></td></tr></table></figure></p>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">num=1</div><div class="line"></div><div class="line">until [ &quot;$num&quot; -gt 10 ]; do</div><div class="line">	echo &quot;num is $num&quot;</div><div class="line">	num=$(($num + 1))</div><div class="line">done</div></pre></td></tr></table></figure>
<p>okay, 关于bash的三个常用的loop暂时介绍到这里。</p>
<h2 id="4-shell-loop中的break与continue"><a href="#4-shell-loop中的break与continue" class="headerlink" title="###4. shell loop中的break与continue"></a>###4. shell loop中的break与continue</h2><p>在结束本章之前，再跟大家补充两个loop有关的命令：</p>
<ul>
<li><code>break</code></li>
<li><code>continue</code><br>这两个命令常用在复合式循环里，<br>也就是<code>do ... done</code>之间又有更进一层的loop，<br>当然，用在单一循环中也未尝不可啦… ^_^</li>
</ul>
<p><code>break</code>用来中断循环，也就是强迫结束循环。<br>若<code>break</code>后面指定一个数值n的话，则从里向外中断第n个循环，<br>预设值为 <code>break 1</code>，也就是中断当前循环。<br>在使用break时，需要注意的是，它与<code>return</code>及<code>exit</code>是不同的：</p>
<ul>
<li><code>break</code>是结束loop；</li>
<li><code>return</code>是结束function；</li>
<li><code>exit</code>是结束script/shell;</li>
</ul>
<p>而<code>continue</code>则与<code>break</code>相反：强迫进入下一次循环动作.</p>
<p>若你理解不来的话，那你可简单的看成：<br>在<code>continue</code>在<code>done</code>之间的句子略过而返回到循环的顶端…</p>
<p>与<code>break</code>相同的是：<code>continue</code>后面也可以指定一个数值n，<br>以决定继续哪一层(从里往外计算)的循环，<br>预设值为 <code>continue 1</code>,也就是继续当前的循环。</p>
<p>在shell script设计中，若能善用loop，<br>将能大幅度提高script在复杂条件下的处理能力。<br>请多加练习吧…</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;for what？ while与until差在哪？&lt;br&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;今天要介绍的是shell script设计中常见的&lt;code&gt;循环&lt;/code&gt;(&lt;code&gt;loop&lt;/code&gt;).&lt;br&gt;所谓的&lt;code&gt;loop&lt;/code&gt;就是script中的一段在一定条件下反复执行的代码。&lt;/p&gt;
&lt;p&gt;bash shell中常用的&lt;code&gt;loop&lt;/code&gt;有如下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for&lt;/li&gt;
&lt;li&gt;while&lt;/li&gt;
&lt;li&gt;until&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之十一  [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%8D%81%E4%B8%80/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之十一/</id>
    <published>2017-04-02T12:49:51.000Z</published>
    <updated>2017-04-02T13:39:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">你要if还是case呢？<br></blockquote></p>
<hr>
<p>还记得我们在第10章所介绍的<code>return value</code>吗？</p>
<p>是的，接下来的介绍的内容与之有关，<br>若你的记忆也被假期所抵消的话，<br>那建议您还是回去温习温习再回来…</p>
<p>若你记得<code>return value</code>，我想你也应该记得了<br><code>&amp;&amp;</code> 与 <code>||</code> 什么意思吧?<br>用这两个符号再搭配 command group的话，<br>我们可让shell script变得更加聪明哦。<br>比方说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cmd1 &amp;&amp; &#123;</div><div class="line">    cmd2</div><div class="line">	cmd3</div><div class="line">	;</div><div class="line">&#125; || &#123;</div><div class="line">	cmd4</div><div class="line">	cmd5</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>意思是说：<br>若 cmd1的<code>return value</code>为true的话，<br>然后执行cmd2与cmd3，<br>否则执行cmd4与cmd5.</p>
<a id="more"></a>
<p>事实上， 我们在写shell script的时候，<br>经常需要用到这样、那样的条件<br>以作出不同的处理动作。<br>用<code>&amp;&amp;</code>与<code>||</code>的确可以达成条件执行的结果，<br>然而，从“人类语言”上来理解，<br>却不是那么直观。<br>更多时候，我们还是喜欢用<code>if...then...else...</code><br>这样的的keyword来表达条件执行。</p>
<p>在bash shell中，我们可以如此修改上一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if cmd1</div><div class="line">then</div><div class="line">	cmd2</div><div class="line">	cmd3</div><div class="line">else</div><div class="line">	cmd4</div><div class="line">	cmd5</div><div class="line">fi</div></pre></td></tr></table></figure></p>
<p>这也是我们在shell script中最常用的<code>if</code>判断式：<br> 只要<code>if</code>后面的command line返回true的return value<br> (我们常用<code>test</code>命令返回的return value)，<br> 然则就执行<code>then</code>后面的命令，否则，执行<code>else</code>之后的命令，<br> <code>fi</code>则是用来结束判断式的keyword。</p>
<p> 在<code>if</code>的判断式中，<code>else</code>部分可以不用，但<code>then</code>是必需的。<br> (若<code>then</code>后不想跑任何command，可用<code>:</code>这个<code>null command</code>代替)。<br> 当然，then或else后面，也可以再使用更进一层的条件判断式，<br> 这在shell script的设计上很常见。<br> 若有多项条件需要”依序”进行判断的话，<br> 那我们则可使用<code>elif</code>这样的keyword：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if cmd1; then</div><div class="line">    cmd2;</div><div class="line">elif cmd3; then</div><div class="line"> 	cmd4</div><div class="line">else</div><div class="line"> 	cmd5</div><div class="line">fi</div></pre></td></tr></table></figure>
<p> 意思是说：<br>     若cmd1为true，然则执行cmd2；<br>     否则在测试cmd3，若为true则执行cmd4；<br>     倘若cmd1与cmd3均不成立，那就执行cmd5。</p>
<p> <code>if</code>判断式的例子很常见，你可从很多shell script中<br> 看得到，我这里不再举例子了…</p>
<p> 接下来为要为大家介绍的是<code>case</code>判断式。<br> 虽然<code>if</code>判断式已可应付大部分的条件执行了，<br> 然而，在某些场合中，却不够灵活，<br> <strong>尤其是在string式样的判断上</strong>，比方如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">QQ() &#123;</div><div class="line">    echo -n &quot;Do you want to continue? (Yes/No): &quot;</div><div class="line"> 	read YN</div><div class="line"> 	if [ &quot;$YN&quot; = Y -o &quot;$YN&quot; = y -o &quot;$YN&quot; = &quot;Yes&quot; -o &quot;$YN&quot; = &quot;yes&quot; -o &quot;$YN&quot; = YES]</div><div class="line"> 	then</div><div class="line"> 		QQ</div><div class="line"> 	else</div><div class="line"> 		exit 0</div><div class="line"> 	fi	</div><div class="line">&#125;</div><div class="line"></div><div class="line">QQ</div></pre></td></tr></table></figure>
<p>从例中，我们看得出来，<br>最麻烦的部分是在判断YN的值可能有好几种样式。</p>
<p>聪明的你或许会如此修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> QQ() &#123;</div><div class="line"> 	echo -n &quot;Do you want to continue? (Yes/No): &quot;</div><div class="line"> 	read YN</div><div class="line"> 	if echo &quot;$YN&quot; | grep -q &apos;^[Yy]\([Ee][Ss]\)*$&apos;</div><div class="line"> 	then</div><div class="line"> 		QQ</div><div class="line"> 	else</div><div class="line"> 		exit 0</div><div class="line"> 	fi	</div><div class="line">&#125;</div><div class="line"></div><div class="line">QQ</div></pre></td></tr></table></figure></p>
<p>也就是用<code>Regular Expression</code>来简化代码。<br>(我们有机会，再来介绍<code>RE</code>)<br>只是…是否有其他更方便的方法呢？<br>有的，就是用<code>case</code>判断式即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> QQ() &#123;</div><div class="line"> 	echo -n &quot;Do you want to continue? (Yes/No): &quot;</div><div class="line"> 	read YN</div><div class="line"> 	case &quot;$YN&quot; in</div><div class="line"> 		[Yy]|[Yy][Ee][Ss])</div><div class="line"> 			QQ</div><div class="line"> 			;;</div><div class="line"> 		*)</div><div class="line"> 			exit 0</div><div class="line"> 			;;</div><div class="line"> 	esac</div><div class="line">&#125;</div><div class="line"></div><div class="line">QQ</div></pre></td></tr></table></figure></p>
<p>我们常用的<code>case</code>的判断式来判断某一变量<br>在不同的值(通常是string)时，作出不同的处理，<br>比方说， <strong>判断script参数，以执行不同的命令</strong>。</p>
<p>若你有兴趣，且用linux系统的话，<br>不妨挖一挖<code>/etc/init.d/*</code>中的那堆script中的<code>case</code>用法.<br>如下就是一例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">case &quot;$1&quot; in</div><div class="line">	start)</div><div class="line">		start</div><div class="line">		;;</div><div class="line">	stop)</div><div class="line">		stop</div><div class="line">		;;</div><div class="line">	status)</div><div class="line">		rhstatus</div><div class="line">		;;</div><div class="line">	restart|reload)</div><div class="line">		restart</div><div class="line">		;;</div><div class="line">	condrestart)</div><div class="line">		[ -f /var/lock/subsys/syslog ] &amp;&amp; restart || :</div><div class="line">		;;</div><div class="line"></div><div class="line">	*)</div><div class="line">		echo $&quot;Usage: $0 &#123;start|stop|status|restart|condrestart&#125;&quot;</div><div class="line">		exit 1</div><div class="line">esac</div></pre></td></tr></table></figure></p>
<p>(若你对 postional parameter的印象已经模糊了，请重看第9章吧。)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;你要if还是case呢？&lt;br&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;还记得我们在第10章所介绍的&lt;code&gt;return value&lt;/code&gt;吗？&lt;/p&gt;
&lt;p&gt;是的，接下来的介绍的内容与之有关，&lt;br&gt;若你的记忆也被假期所抵消的话，&lt;br&gt;那建议您还是回去温习温习再回来…&lt;/p&gt;
&lt;p&gt;若你记得&lt;code&gt;return value&lt;/code&gt;，我想你也应该记得了&lt;br&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 与 &lt;code&gt;||&lt;/code&gt; 什么意思吧?&lt;br&gt;用这两个符号再搭配 command group的话，&lt;br&gt;我们可让shell script变得更加聪明哦。&lt;br&gt;比方说：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;cmd1 &amp;amp;&amp;amp; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    cmd2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	cmd3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; || &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	cmd4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	cmd5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;意思是说：&lt;br&gt;若 cmd1的&lt;code&gt;return value&lt;/code&gt;为true的话，&lt;br&gt;然后执行cmd2与cmd3，&lt;br&gt;否则执行cmd4与cmd5.&lt;/p&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之十  [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%8D%81/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之十/</id>
    <published>2017-04-02T12:49:48.000Z</published>
    <updated>2017-04-02T14:01:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">&gt;与&lt; 差在哪？<br></blockquote>




<h4 id="1-文件描述符-fd-File-Descriptor"><a href="#1-文件描述符-fd-File-Descriptor" class="headerlink" title="1. 文件描述符(fd, File Descriptor)"></a>1. 文件描述符(fd, File Descriptor)</h4><hr>
<p>谈到<code>I/O redirection</code>,不妨先让我们认识一下<code>File Descriptor</code>(<code>fd</code>，文件描述符)。</p>
<p>进程的运算，在大部分情况下，都是进行数据(data)的处理，<br>这些数据从哪里，读进来？又输出到哪里呢？<br>这就是file descriptor(fd)的功用了。</p>
<p>在shell的进程中，最常使用的<code>fd</code>大概有三个，分别为:</p>
<ul>
<li>0：standard Input (<code>STDIN</code>) </li>
<li>1: standard output(<code>STDOUT</code>)</li>
<li>2: standard Error output （<code>STDERR</code>）</li>
</ul>
<p>在标准情况下，这些fd分别跟如下设备(device)关联：</p>
<ul>
<li><code>stdin</code>(0): keyboard</li>
<li><code>stdout</code>(1): monitor</li>
<li><code>stderr</code>(2): monitor</li>
</ul>
<a id="more"></a>
<blockquote>
<p><strong>Tips:</strong><br>linux中的文件描述符(fd)用整数表示。<br>linux中任何一个进程都默认打开三个文件,<br>这三个文件对应的文件描述符分别是：0, 1, 2;<br>即stdin, stdout, stderr.</p>
</blockquote>
<p>我们可以用如下命令测试一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ mail -s test root</div><div class="line">this is a test mail。</div><div class="line">please skip.</div><div class="line">^d (同时按下ctrl 跟d键)</div></pre></td></tr></table></figure></p>
<p>很明显，<code>mail</code>进程所读进的数据，就是从<br><code>stdin</code> 也就是keyboard读进的。<br>不过，不见得每个进程的<code>stdin</code>都跟<code>mail</code>一样<br>从<code>keyboard</code>读进，因为进程的作者可以从文件参数读进<code>stdin</code>，<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/passwd</div></pre></td></tr></table></figure></p>
<p>但，要是<code>cat</code>之后没有文件参数则如何呢？<br>哦， 请你自己玩玩看…^_^<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Tips:</strong></p>
<p>请留意数据输出到哪里去了，<br>最后别忘了按<code>ctrl+d</code>(<code>^d</code>), 退出stdin输入。</p>
</blockquote>
<p>至于<code>stdout</code>与<code>stderr</code>，嗯…等我有空再续吧…^_^<br>还是，有哪位前辈来玩接龙呢？</p>
<p>相信，经过上一个练习后，<br>你对<code>stdin</code>与<code>stdout</code>应该不难理解了吧？<br>然后，让我们看看<code>stderr</code>好了。</p>
<p>事实上，<code>stderr</code>没什么难理解的：<br>说白了就是“错误信息”要往哪里输出而已…<br>比方说, 若读进的文件参数不存在的，<br>那我们在monitor上就看到了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls no.such.file</div><div class="line">ls: no.such.file: No such file or directory</div></pre></td></tr></table></figure>
<p>若同一个命令，同时成生<code>stdout</code>与<code>stderr</code>呢？<br>那还不简单，都送到monitor来就好了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ touch my.file</div><div class="line">$ ls my.file on.such.file</div><div class="line">ls: no.such.file: No such file or directory</div><div class="line">my.file</div></pre></td></tr></table></figure></p>
<p>okay, 至此，关于fd及其名称、还有相关联的设备，<br>相信你已经没问题了吧？</p>
<hr>
<h4 id="2-I-O-重定向-I-O-Redirection"><a href="#2-I-O-重定向-I-O-Redirection" class="headerlink" title="2. I/O 重定向(I/O Redirection)"></a>2. I/O 重定向(I/O Redirection)</h4><p>那好，接下来让我们看看如何改变这些fd的预设数据通道。</p>
<ul>
<li>用<code>&lt;</code> 来改变读进的数据通道(stdin),使之从指定的文件读进。</li>
<li>用<code>&gt;</code> 来改变输出的数据通道(stdout，stderr),使之输出到指定的文件。</li>
</ul>
<hr>
<h5 id="2-1-输入重定向n-lt-input-redirection"><a href="#2-1-输入重定向n-lt-input-redirection" class="headerlink" title="2.1 输入重定向n&lt;(input redirection)"></a>2.1 输入重定向<code>n&lt;</code>(input redirection)</h5><p>比方说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat &lt; my.file</div></pre></td></tr></table></figure></p>
<p>就是从my.file读入数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mail -s test root &lt; /etc/passwd</div></pre></td></tr></table></figure>
<p>则是从/etc/passwd读入…</p>
<p>这样一来，stdin将不再是从keyboard读入，<br>而是从指定的文件读入了…</p>
<p>严格来说，<strong><code>&lt;</code>符号之前需要指定一个fd的(之前不能有空白)，但因为0是<code>&lt;</code>的预设值，因此，<code>&lt;</code>与<code>0&lt;</code>是一样的*</strong>。</p>
<p>okay，这样好理解了吧？</p>
<p>那要是用两个<code>&lt;</code>，即<code>&lt;&lt;</code>又是啥呢？<br><strong>这是所谓的<code>here document</code>,<br>它可以让我们输入一段文本，<br>直到读到<code>&lt;&lt;</code> 后指定的字符串</strong>。</p>
<p>比方说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ cat &lt;&lt;EOF</div><div class="line">first line here</div><div class="line">second line here</div><div class="line">third line here</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>这样的话, <code>cat</code>会读入3个句子，<br>而无需从keyboard读进数据且要等到(ctrl+d, ^d)结束输入。</p>
<hr>
<h5 id="2-2-重定向输出-gt-n-output-redirection"><a href="#2-2-重定向输出-gt-n-output-redirection" class="headerlink" title="2.2 重定向输出&gt;n(output redirection)"></a>2.2 重定向输出<code>&gt;n</code>(output redirection)</h5><p>当你搞懂了<code>0&lt;</code> 原来就是改变<code>stdin</code>的数据输入通道之后，<br>相信要理解如下两个redirection就不难了：</p>
<ul>
<li><code>1&gt;</code> #改变stdout的输出通道；</li>
<li><code>2&gt;</code> #改变stderr的输出通道；</li>
</ul>
<p>两者都是将原来输出到monitor的数据，<br>重定向输出到指定的文件了。</p>
<p><strong>由于1是<code>&gt;</code>的预设值，<br>因此，<code>1&gt;</code>与<code>&gt;</code>是相同的，都是改变<code>stdout</code></strong>.</p>
<p>用上次的ls的例子说明一下好了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls my.file no.such.file 1&gt;file.out</div><div class="line">ls: no.such.file: No such file or directory</div></pre></td></tr></table></figure></p>
<p>这样monitor的输出就只剩下<code>stderr</code>的输出了，<br>因为<code>stdout</code>重定向输出到文件file.out去了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls my.file no.such.file 2&gt;file.err</div><div class="line">my.file</div></pre></td></tr></table></figure>
<p>这样monitor就只剩下了<code>stdout</code>,<br>因为<code>stderr</code>重定向输出到文件file.err了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ls my.file no.such.file 1&gt;file.out 2&gt;file.err</div></pre></td></tr></table></figure>
<p>这样monitor就啥也没有了，<br>因为<code>stdout</code>与<code>stderr</code>都重定向输出到文件了。</p>
<p>呵呵，看来要理解<code>&gt;</code>一点也不难啦是不？ 没骗你吧？ ^_^<br><strong>不过有些地方还是要注意一下的</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ls my.file no.such.file 1&gt;file.both 2&gt;file.both</div></pre></td></tr></table></figure>
<p>假如<code>stdout</code>(1)与<code>stderr</code>(2)都同时在写入file.both的话，<br>则是采取”覆盖”的方式：后来写入覆盖前面的。</p>
<p>让我们假设一个<code>stdout</code>与<code>stderr</code>同时写入到file.out的情形好了；</p>
<ul>
<li>首先<code>stdout</code>写入10个字符</li>
<li>然后<code>stderr</code>写入6个字符</li>
</ul>
<p>那么，这时原本的<code>stdout</code>输出的10个字符，<br>将被<code>stderr</code>输出的6个字符覆盖掉了。</p>
<p>那如何解决呢？所谓山不转路转，路不转人转嘛，<br>我们可以换一个思维：<br>将<code>stderr</code>导进<code>stdout</code><br>或者将<code>stdout</code>导进到<code>stderr</code>,<br>而不是大家在抢同一份文件，不就行了。<br>bingo就是这样啦：</p>
<ul>
<li>2&gt;&amp;1 #将<code>stderr</code>并进<code>stdout</code>输出</li>
<li>1&gt;&amp;2 或者 &gt;&amp;2 #将<code>stdout</code>并进<code>stderr</code>输出。</li>
</ul>
<p>于是，前面的错误操作可以改写为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls my.file no.such.file 1&gt;file.both 2&gt;&amp;1</div><div class="line">$ ls my.file no.such.file 2&gt;file.both &gt;&amp;2</div></pre></td></tr></table></figure></p>
<p>这样，不就皆大欢喜了吗？ ~~~ ^_^</p>
<p>不过，光解决了同时写入的问题还不够，<br>我们还有其他技巧需要了解的。<br>故事还没有结束，别走开广告后，我们在回来….</p>
<hr>
<h5 id="2-3-I-O重定向与linux中的-dev-null"><a href="#2-3-I-O重定向与linux中的-dev-null" class="headerlink" title="2.3 I/O重定向与linux中的/dev/null"></a>2.3 I/O重定向与linux中的<code>/dev/null</code></h5><p>okay，这次不讲I/O Redirection, 请佛吧…<br>(有没有搞错？<code>网中人</code>是否头壳烧坏了？…)嘻~~~^_^</p>
<p>学佛的最高境界，就是”四大皆空”。<br>至于是空哪四大块，我也不知，因为我还没有到那个境界..<br>这个“空”字,却非常值得反复把玩：<br>—色即是空，空即是色<br>好了，施主要是能够领会”空”的禅意，那离修成正果不远了。</p>
<p> 在linux的文件系统中，有个设备文件: <code>/dev/null</code>.<br> 许多人都问过我，那是什么玩意儿？<br> 我跟你说好了，那就是”空”啦。</p>
<p> 没错空空如也的空就是null了…<br> 请问施主是否忽然有所顿悟了呢？<br> 然则恭喜了。</p>
<p> 这个null在 I/O Redirection中可有用的很呢？</p>
<ul>
<li>将fd <code>1</code>跟fd <code>2</code>重定向到/dev/null去，就可忽略stdout, stderr的输出。</li>
<li>将fd <code>0</code>重定向到/dev/null，那就是读进空(nothing).</li>
</ul>
<p>比方说，我们在执行一个进程时，会同时输出到stdout与stderr，<br>假如你不想看到stderr(也不想存到文件)， 那就可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls my.file no.such.file 2&gt;/dev/null</div><div class="line">my.file</div></pre></td></tr></table></figure></p>
<p>若要相反：只想看到stderr呢？<br>还不简单将stdout，重定向的/dev/null就行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls my.file no.such.file &gt;/dev/null</div><div class="line">ls: no.such.file: No such file or directory</div></pre></td></tr></table></figure></p>
<p>那接下来，假如单纯的只跑进程，而不想看到任何输出呢？<br>哦，这里留了一手，上次没讲的法子,专门赠与有缘人… ^_^<br>除了用 <code>&gt;/dev/null 2&gt;&amp;1</code>之外，你还可以如此：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ls my.file no.such.file &amp;&gt;/dev/null</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Tips:</strong></p>
<p>将&amp;&gt;换成&gt;&amp;也行！</p>
</blockquote>
<hr>
<h5 id="2-4-重定向输出append-gt-gt"><a href="#2-4-重定向输出append-gt-gt" class="headerlink" title="2.4 重定向输出append (&gt;&gt;)"></a>2.4 重定向输出append (<code>&gt;&gt;</code>)</h5><p>okay？ 请完佛，接下来，再让我们看看如下情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;1&quot; &gt; file.out</div><div class="line">$ cat file.out</div><div class="line">1</div><div class="line">$ echo &quot;2&quot; &gt; file.out</div><div class="line">$ cat file.out</div><div class="line">2</div></pre></td></tr></table></figure></p>
<p>看来，我们在重定向stdout或stderr进一个文件时，<br>似乎永远只能获得最后一次的重定向的结果.<br>那之前的内容呢？</p>
<p>呵呵，要解决这个问题，很简单啦，将<code>&gt;</code>换成<code>&gt;&gt;</code> 就好了；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;3&quot; &gt;&gt; file.out</div><div class="line">$ cat file.out</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure></p>
<p>如此一来，被重定向的文件的之前的内容并不会丢失，<br>而新的内容则一直追加在最后面去。so easy?…</p>
<p>但是，只要你再次使用<code>&gt;</code>来重定向输出的话，<br>那么，原来文件的内容被truncated(清洗掉)。<br>这是，你要如何避免呢？<br>—-备份， yes，我听到了，不过，还有更好的吗？<br>既然与施主这么有缘分，老衲就送你一个锦囊妙法吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ set -o noclobber</div><div class="line">$ echo &quot;4&quot; &gt; file.out</div><div class="line">-bash：file: cannot overwrite existing file.</div></pre></td></tr></table></figure></p>
<p>那，要如何取消这个限制呢?<br>哦，将<code>set -o</code>换成 <code>set +o</code>就行了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ set +o noclobber</div><div class="line">$ echo &quot;5&quot; &gt; file.out</div><div class="line">$ cat file.out</div><div class="line">5</div></pre></td></tr></table></figure></p>
<p>再问：那有办法不取消而又“临时”改写目标文件吗？<br>哦，佛曰：不可告也。<br>啊，<del>~开玩笑的，开玩笑啦</del>~^_^，<br>哎，早就料到人心是不足的了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ set -o noclobber</div><div class="line">$ echo &quot;6&quot; &gt;| file.out</div><div class="line">$ cat file.out</div><div class="line">6</div></pre></td></tr></table></figure></p>
<p>留意到没有：<br><strong>在<code>&gt;</code>后面加个<code>|</code>就好，<br>注意： <code>&gt;</code>与<code>|</code>之间不能有空白哦</strong>…</p>
<hr>
<h5 id="2-5-I-O-Redirection的优先级"><a href="#2-5-I-O-Redirection的优先级" class="headerlink" title="2.5 I/O Redirection的优先级"></a>2.5 I/O Redirection的优先级</h5><p>呼….(深呼吸吐纳一下吧)~~~ ^_^<br>再来还有一个难题要你去参透呢:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;some text here&quot; &gt;file</div><div class="line">$ cat &lt; file</div><div class="line">some text here</div><div class="line">$cat &lt; file &gt;file.bak</div><div class="line">$cat &lt; file.bak</div><div class="line">some text here</div><div class="line">$cat &lt; file &gt;file</div></pre></td></tr></table></figure></p>
<p>嗯？注意到没有？<br>—怎么最后那个cat命令看到file是空的呢？<br>why？ why？ why？</p>
<p>前面提到：<code>$cat &lt; file &gt; file</code>之后，<br>原本有内容的文件，结果却被清空了。<br>要理解这个现象其实不难，<br>这只是priority的问题而已：<br><strong> 在IO Redirection中, stdout与stderr的管道先准备好，<br>才会从stdin读入数据。</strong><br>也就是说，在上例中，<code>&gt;file</code>会将file清空，<br>然后才读入 <code>&lt; file</code>。<br>但这时候文件的内容已被清空了，因此就变成了读不进任何数据。</p>
<p>哦，<del>~原来如此</del>~^_^<br>那…如下两例又如何呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cat &lt;&gt; file</div><div class="line">$ cat &lt; file &gt;&gt;file</div></pre></td></tr></table></figure></p>
<p>嗯…同学们，这两个答案就当练习题喽，<br>下课前交作业。</p>
<blockquote>
<p><strong>Tips:</strong><br>我们了解到<code>&gt;file</code>能够快速把文件file清空；<br>或者使用<code>:&gt;file</code>同样可以清空文件，<br><code>:&gt;file</code>与<code>&gt;file</code>的功能：<br>若文件file存在，则将file清空; 否则，创建空文件file (等效于<code>touch file</code>);<br>二者的差别在于<code>&gt;file</code>的方式不一定在所有的shell的都可用。</p>
<p><code>exec 5&lt;&gt;file; echo &quot;abcd&quot; &gt;&amp;5; cat &lt;&amp;5</code><br>将file文件的输入、输出定向到文件描述符5，<br>从而描述符5可以接管file的输入输出；<br>因此，<code>cat &lt;&gt;file</code>等价于<code>cat &lt; file</code>。</p>
<p>而<code>cat &lt; file &gt;&gt;file</code>则使file内容成几何级数增长。</p>
</blockquote>
<p>好了， I/O Redirection也快讲完了，<br>sorry,因为我也只知道这么多而已啦<del>~嘻</del>~^_^<br>不过，还有一样东东是一定要讲的，各位观众(请自行配乐~!#@$%):<br>就是<code>pipe line</code>也。</p>
<hr>
<h5 id="2-6-管道-pipe-line"><a href="#2-6-管道-pipe-line" class="headerlink" title="2.6 管道(pipe line)"></a>2.6 管道(pipe line)</h5><p>谈到<code>pipe line</code>，我相信不少人都不会陌生：<br>我们在很多command line上常看到<code>|</code>符号就是pipe line了。</p>
<p>不过，pipe line究竟是什么东东呢？<br>别急别急…先查一下英文字典，看看pipe是什么意思？<br>没错他就是“水管”的意思…<br>那么，你能想象一下水管是怎样一个根接一根的吗？<br>又， 每根水管之间的input跟output又如何呢？<br>灵光一闪：原来pipe line的I/O跟水管的I/O是一模一样的：<br><strong>上一个命令的stdout接到下一个命令的stdin去了</strong><br>的确如此。不管在command line上使用了多少个pipe line，<br>前后两个command的I/O是彼此连接的<br>(恭喜：你终于开放了 ^_^ )</p>
<p>不过…然而…但是… …stderr呢？<br>好问题不过也容易理解：<br>若水管漏水怎么办？<br>也就是说：在pipe line之间,<br>前一个命令的stderr是不会接进下一个命令的stdin的，<br>其输出，若不用2&gt;file的话，其输出在monitor上来。<br>这点请你在pipe line运用上务必要注意的。</p>
<p>那，或许你有会问:<br><strong>有办法将stderr也喂进下一个命令的stdin吗？</strong><br>(贪得无厌的家伙)，方法当然是有的，而且，你早已学习过了。<br>提示一下就好：**请问你如何将stderr合并进stdout一同输出呢？<br>若你答不出来，下课后再来问我…(如果你脸皮足够厚的话…)</p>
<p>或许，你仍意犹未尽，或许，你曾经碰到过下面的问题：<br>在<code>cmd1 | cmd2 | cmd3 | ...</code><br>这段pipe line中如何将cmd2的输出保存到一个文件呢？</p>
<p>若你写成<code>cmd1 | cmd2 &gt;file | cmd3</code>的话，<br>那你肯定会发现<code>cmd3</code>的stdin是空的，(当然了，你都将<br>水管接到别的水池了)<br>聪明的你或许会如此解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cmd1 | cmd2 &gt;file; cmd3 &lt; file</div></pre></td></tr></table></figure></p>
<p>是的，你可以这样做，但最大的坏处是：<br>file I/O会变双倍，在command执行的整个过程中，<br>file I/O是最常见的最大效能杀手。<br>凡是有经验的shell操作者，都会尽量避免或降低file I/O的频度。</p>
<p>那上面问题还有更好的方法吗？<br>有的，那就是<code>tee</code>命令了。<br><strong>所谓的<code>tee</code>命令是在不影响原本I/O的情况下，<br>将stdout赋值到一个文件中去。</strong><br>因此，上面的命令行，可以如此执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cmd1 | cmd2 | tee file | cmd3</div></pre></td></tr></table></figure></p>
<p>在预设上，<code>tee</code>会改写目标文件，<br>若你要改为追加内容的话，那可用-a参数选项。</p>
<p>基本上，pipe line的应用在shell操作上是非常广泛的。<br>尤其是在text filtering方面，<br>如，cat, more, head, tail, wc, expand, tr,<br>grep, sed, awk…等等文字处理工具。<br>搭配起pipe line 来使用，你会觉得 command line<br>原来活得如此精彩的。<br>常让人有“众里寻他千百度，蓦然回首，那人却在灯火阑珊处”之感…</p>
<p>好了，关于I/O Redirection的介绍就到此告一段落。<br>若日后，有空的话，在为大家介绍其他在shell上好玩的东西。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&amp;gt;与&amp;lt; 差在哪？&lt;br&gt;&lt;/blockquote&gt;




&lt;h4 id=&quot;1-文件描述符-fd-File-Descriptor&quot;&gt;&lt;a href=&quot;#1-文件描述符-fd-File-Descriptor&quot; class=&quot;headerlink&quot; title=&quot;1. 文件描述符(fd, File Descriptor)&quot;&gt;&lt;/a&gt;1. 文件描述符(fd, File Descriptor)&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;谈到&lt;code&gt;I/O redirection&lt;/code&gt;,不妨先让我们认识一下&lt;code&gt;File Descriptor&lt;/code&gt;(&lt;code&gt;fd&lt;/code&gt;，文件描述符)。&lt;/p&gt;
&lt;p&gt;进程的运算，在大部分情况下，都是进行数据(data)的处理，&lt;br&gt;这些数据从哪里，读进来？又输出到哪里呢？&lt;br&gt;这就是file descriptor(fd)的功用了。&lt;/p&gt;
&lt;p&gt;在shell的进程中，最常使用的&lt;code&gt;fd&lt;/code&gt;大概有三个，分别为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0：standard Input (&lt;code&gt;STDIN&lt;/code&gt;) &lt;/li&gt;
&lt;li&gt;1: standard output(&lt;code&gt;STDOUT&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;2: standard Error output （&lt;code&gt;STDERR&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在标准情况下，这些fd分别跟如下设备(device)关联：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stdin&lt;/code&gt;(0): keyboard&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stdout&lt;/code&gt;(1): monitor&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stderr&lt;/code&gt;(2): monitor&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之九  [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E4%B9%9D/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之九/</id>
    <published>2017-04-02T12:49:45.000Z</published>
    <updated>2017-04-02T13:30:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">&amp;&amp; 与 || 差在哪？<br></blockquote></p>
<hr>
<p>一路走来，很辛苦吧？也很快乐吧？ ^_^</p>
<p>在解答本章题目之前，先让我们了解一个概念：<br>return value。</p>
<p>我们在shell下跑的每一个command或function，<br>在结束的时候都会传回父进程一个值，称为 <code>return value</code>。</p>
<p>在shell command line中可用<code>$?</code>，<br>这个变量得到最”新”的一个<code>return value</code>，<br>也就是刚刚结束的那个进程传回的值。</p>
<p><code>Return Value</code>(RV)的取值为0-255之间，<br>由进程或者script的作者自行定义：</p>
<ul>
<li><p>若在script里，用exit RV 来指定其值;<br>若没有指定, 在结束时，以最后一个命令的RV，为script的RV值。</p>
</li>
<li><p>若在function里，则用return RV 来代替exit RV即可。</p>
</li>
</ul>
<a id="more"></a>
<p><strong><code>Return Value</code>的作用：用来判断进程的退出状态(exit status)</strong>.<br>进程的退出状态有两种：</p>
<ul>
<li>0值为”真”(true)</li>
<li>非0值为”假”(false)</li>
</ul>
<p>举个例子来说明好了：<br>假设当前目录内有一个my.file的文件， 而no.file是不存在的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ touch my.file</div><div class="line">$ ls my.file</div><div class="line">$ echo $? #first echo</div><div class="line">0</div><div class="line">$ ls no.file</div><div class="line">ls: no.file: No such file or directory</div><div class="line">$ echo $?     #second echo</div><div class="line">1</div><div class="line">$ echo $?     #third echo</div><div class="line">0</div></pre></td></tr></table></figure></p>
<p>上例的：</p>
<ul>
<li>第一个echo是关于<code>ls my.file</code>的RV，可得到0的值，因此为true。</li>
<li>第二个echo是关于<code>ls no.file</code>的RV，得到非0的值，因此为false。</li>
<li>第三个echo是关于<code>echo $?</code>的RV，得到0值， 因此为true。</li>
</ul>
<p>请记住：<br>每一个command在结束时，都会返回<code>return value</code>，不管你跑什么命令…<br>然而，有一个命令却是“专门”用来测试某一条而返回<code>return value</code>，<br>以供true或false的判断， 它就是<code>test</code>命令。</p>
<p>若你用的是bash， 请在command line下，<br>打<code>man test</code>，或者 <code>man bash</code> 来了解这个<code>test</code>的用法。<br>这是你可用作参考的最精准的文件了，要是听别人说的，仅作参考就好…</p>
<p>下面，我只简单作一些辅助说明，其余的一律以 <code>man</code>为准：<br>首先，<code>test</code>的表达式，我们称为expression，其命令格式有两种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">test expression</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ expression ]</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Note:</strong></p>
<p>请务必注意 <code>[]</code> 之间的空白键!</p>
</blockquote>
<p>用哪一种格式无所谓，都是一样的效果。<br>(我个人比较喜欢后者…)</p>
<p>其次，bash的<code>test</code>目前支持的测试对象只有三种：</p>
<ul>
<li>string：字符串，也就是纯文字。</li>
<li>integer：整数(0或正整数、不含负数或小数)</li>
<li>file: 文件</li>
</ul>
<p>请初学者，一定要搞清楚这三者的差异，<br>因为<code>test</code>所使用的expression是不一样的。</p>
<p>以A=123这个变量为例：</p>
<ul>
<li><p><code>[ &quot;$A&quot; = 123 ]</code> #是字符串测试，测试$A是不是1、2、3这三个字符。</p>
</li>
<li><p><code>[ &quot;$A&quot; -eq 123 ]</code> #是整数测试，以测试$A是否等于123.</p>
</li>
<li><p><code>[-e &quot;$A&quot; ]</code> #文件测试，测试123这份文件是否存在.</p>
</li>
</ul>
<p>第三，<br>当expression测试为“真”时， <code>test</code>就返回0(true)的<code>return value</code>;<br>否则，返回非0(false).</p>
<p>若在 expression 之前加一个<code>!</code>(感叹号)，则在expression为假时，return value为0,<br>否则, return value 为非0值。</p>
<p>同时，<code>test</code>也允许多重复合测试：</p>
<ul>
<li>expression1 -a expression2 #当两个expression都为true，返回0，否则，返回非0；</li>
<li>expression1 -o expression2 #当两个expression均为false时，返回非0，否则，返回0；</li>
</ul>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ -d &quot;$file&quot;  -a  -x &quot;$file&quot; ]</div></pre></td></tr></table></figure></p>
<p>表示当$file是一个目录，且同时具有x权限时，test才会为true。</p>
<p>第四，在command line中使用<code>test</code>时，请别忘记命令行的“重组”特性，<br>也就是在碰到meta时，会先处理meta，在重新组建命令行。<br>(这个概念在第2章和第4章进行了反复强调)</p>
<p>比方说， 若<code>test</code>碰到变量或者命令替换时，<br>若不能满足 expression的格式时，将会得到语法错误的结果。</p>
<p>举例来说好了：</p>
<p>关于<code>[ string1 = string2 ]</code>这个test格式，<br>在等号两边必须要有字符串，其中包括空串(null串,可用soft quote或者hard quote取得)。</p>
<p>假如$A目前没有定义，或被定义为空字符串的话，<br>那如下的用法将会失败：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ unset A</div><div class="line">$ [ $A = abc ]</div><div class="line">[: =: unary oprator expected</div></pre></td></tr></table></figure></p>
<p>这是因为命令行碰到$这个meta时，会替换$A的值，<br>然后，再重组命令行，那就变成了：<br><code>[ = abc ]</code>,<br>如此一来，=的左边就没有字符串存在了，<br>因此，造成test的语法错误。<br>但是，下面这个写法则是成立的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ [ &quot;$A&quot; = abc ]</div><div class="line">$ echo $?</div><div class="line">1</div></pre></td></tr></table></figure>
<p>这是因为命令行重组后的结果为：<br><code>[ &quot;&quot; = abc ]</code>,<br>由于等号的左边我们用soft quote得到一个空串，<br>而让test的语法得以通过…</p>
<p>读者诸君，请务必留意这些细节哦，<br>因为稍一不慎，将会导致<code>test</code>的结果变了个样。<br>若您对<code>test</code>还不是很有经验的话，<br>那在使用test时，不妨先采用如下这一个”法则”:</p>
<p><strong> 若在<code>test</code>中碰到变量替换，用soft quote是最保险的*</strong>。</p>
<p>若你对quoting不熟的话，请重新温习第四章的内容吧…^_^</p>
<p>okay, 关于更多的<code>test</code>的用法，老话一句：请看其man page (<code>man test</code>)吧！^_^</p>
<p>虽然洋洋洒洒读了一大堆，或许你还在嘀咕…那…那个<code>return value</code>有啥用？</p>
<p>问得好:<br>告诉你：return value的作用可大了，<br>若你想要你的shell变”聪明”的话，就全靠它了：<br>有了return value， 我们可以让shell根据不同的状态做不同的事情…</p>
<p>这时候，才让我来揭晓本章的答案吧~~~~^_^</p>
<p><code>&amp;&amp;</code> 与 <code>||</code> 都是用来”组建” 多个command line用的；</p>
<ul>
<li><code>command1 &amp;&amp; command2</code> # command2只有在command1的RV为0(true)的条件下执行。</li>
<li><code>command1 || command2</code> # command2 只有在command1的RV为非0(false)的条件下执行。</li>
</ul>
<p>以例子来说好了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ A=123</div><div class="line">$ [ -n &quot;$A&quot; ] &amp;&amp; echo &quot;yes! it&apos;s true.&quot;</div><div class="line">yes! it&apos;s true.</div><div class="line">$ unset A</div><div class="line">$ [ -n &quot;$A&quot; ] &amp;&amp; echo &quot;yes! it&apos;s true.&quot;</div><div class="line">$ [ -n &quot;$A&quot; ] || echo &quot;no, it&apos;s Not true.&quot;</div><div class="line">no, it&apos;s Not true</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Note:</strong></p>
<p><code>[ -n string ]</code>是测试string长度大于0, 则为true。</p>
</blockquote>
<p>上例中，第一个<code>&amp;&amp;</code>命令之所以会执行其右边的<code>echo</code>命令，<br>是因为上一个<code>test</code>返回了0的RV值；<br>但第二个，就不会执行，因为<code>test</code>返回了非0的结果…<br>同理，<code>||</code>右边的<code>echo</code>会被执行，却正是因为左边的<code>test</code>返回非0所引起的。</p>
<p>事实上，我们在同一个命令行中，可用多个<code>&amp;&amp;</code> 或 <code>||</code> 来组建呢。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ A=123</div><div class="line">$ [ -n &quot;$A&quot; ] &amp;&amp; echo &quot;yes! it&apos;s true.&quot; || echo &quot;no, it&apos;s Not ture.&quot;</div><div class="line">yes! it&apos;s true.</div><div class="line">$ unset A</div><div class="line">$ [ -n &quot;$A&quot; ] &amp;&amp; echo &quot;yes! it&apos;s true.&quot; || echo &quot;no, it&apos;s Not ture.&quot;</div><div class="line">no, it&apos;s Not true</div></pre></td></tr></table></figure></p>
<p>怎样，从这一刻开始，你是否觉得我们的shell是“很聪明”的呢？ ^_^</p>
<p>好了，最后布置一道练习题给大家做做看：<br>下面的判断是：当$A被赋值时，在看看其是否小于100，否则输出too big！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ A=123</div><div class="line">$ [ -n &quot;$A&quot; ] &amp;&amp; [ &quot;$A&quot; -lt 100 ] || echo &apos;too big!&apos;</div><div class="line">$ too big!</div></pre></td></tr></table></figure></p>
<p>若我取消A，照理说，应该不会输出文字啊，(因为第一个条件不成立)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ unset A</div><div class="line">$ [ -n &quot;$A&quot; ] &amp;&amp; [ &quot;$A&quot; -lt 100 ] || echo &apos;too big!&apos;</div><div class="line">$ too big!</div></pre></td></tr></table></figure></p>
<p>为何上面的结果也可得到呢？<br>又如何解决呢？</p>
<blockquote>
<p><strong>Tips:</strong></p>
<p>修改的方法有很多种，<br>其中一种方法可以利用第7章中介绍过 <code>command group</code>…</p>
</blockquote>
<p>快告诉我答案，其余免谈….</p>
<p>解决方法1：<code>sub-shell</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ unset A</div><div class="line">$ [ -n &quot;$A&quot; ] &amp;&amp; ( [ &quot;$A&quot; -lt 100 ] || echo &apos;too big!&apos; )</div></pre></td></tr></table></figure></p>
<p>解决方法二：<code>command group</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ unset A</div><div class="line">$ [ -n &quot;$A&quot; ] &amp;&amp; &#123; [ &quot;$A&quot; -lt 100 ] || echo &apos;too big!&apos;&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&amp;amp;&amp;amp; 与 || 差在哪？&lt;br&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一路走来，很辛苦吧？也很快乐吧？ ^_^&lt;/p&gt;
&lt;p&gt;在解答本章题目之前，先让我们了解一个概念：&lt;br&gt;return value。&lt;/p&gt;
&lt;p&gt;我们在shell下跑的每一个command或function，&lt;br&gt;在结束的时候都会传回父进程一个值，称为 &lt;code&gt;return value&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在shell command line中可用&lt;code&gt;$?&lt;/code&gt;，&lt;br&gt;这个变量得到最”新”的一个&lt;code&gt;return value&lt;/code&gt;，&lt;br&gt;也就是刚刚结束的那个进程传回的值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Return Value&lt;/code&gt;(RV)的取值为0-255之间，&lt;br&gt;由进程或者script的作者自行定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;若在script里，用exit RV 来指定其值;&lt;br&gt;若没有指定, 在结束时，以最后一个命令的RV，为script的RV值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;若在function里，则用return RV 来代替exit RV即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
</feed>
