<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Maxie&#39;s Notes</title>
  <subtitle>Stay hungry , Stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-04-02T12:50:20.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>阿蓝</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>shell十三问之十七</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%8D%81%E4%B8%83/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之十七/</id>
    <published>2017-04-02T12:50:20.000Z</published>
    <updated>2017-04-02T12:50:20.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>shell十三问之十六</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%8D%81%E5%85%AD/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之十六/</id>
    <published>2017-04-02T12:50:12.000Z</published>
    <updated>2017-04-02T12:50:12.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>shell十三问之十五</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%8D%81%E4%BA%94/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之十五/</id>
    <published>2017-04-02T12:50:09.000Z</published>
    <updated>2017-04-02T12:50:09.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>shell十三问之十四</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%8D%81%E5%9B%9B/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之十四/</id>
    <published>2017-04-02T12:50:05.000Z</published>
    <updated>2017-04-02T12:50:05.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>shell十三问之十三</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%8D%81%E4%B8%89/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之十三/</id>
    <published>2017-04-02T12:49:59.000Z</published>
    <updated>2017-04-02T12:49:59.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>shell十三问之十二</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%8D%81%E4%BA%8C/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之十二/</id>
    <published>2017-04-02T12:49:55.000Z</published>
    <updated>2017-04-02T12:49:55.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>shell十三问之十一</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%8D%81%E4%B8%80/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之十一/</id>
    <published>2017-04-02T12:49:51.000Z</published>
    <updated>2017-04-02T12:49:51.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>shell十三问之十</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%8D%81/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之十/</id>
    <published>2017-04-02T12:49:48.000Z</published>
    <updated>2017-04-02T12:49:48.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>shell十三问之九</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E4%B9%9D/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之九/</id>
    <published>2017-04-02T12:49:45.000Z</published>
    <updated>2017-04-02T12:49:45.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>shell十三问之八</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%85%AB/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之八/</id>
    <published>2017-04-02T12:49:41.000Z</published>
    <updated>2017-04-02T12:49:41.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>shell十三问之七</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E4%B8%83/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之七/</id>
    <published>2017-04-02T12:49:39.000Z</published>
    <updated>2017-04-02T12:49:39.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>shell十三问之六</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%85%AD/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之六/</id>
    <published>2017-04-02T12:49:36.000Z</published>
    <updated>2017-04-02T12:49:36.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>shell十三问之五 [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E4%BA%94/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之五/</id>
    <published>2017-04-02T12:49:33.000Z</published>
    <updated>2017-04-02T13:12:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">问var=value 在export前后的差在哪?<br></blockquote>

<hr>
<p>这次让我们暂时丢开<code>command line</code>,<br>先了解一下bash变量(variable)吧…</p>
<p>所谓的变量，就是利用一个固定的”名称”(name),<br>来存取一段可以变化的”值”(value)。</p>
<a id="more"></a>
<h3 id="1-变量设定-set"><a href="#1-变量设定-set" class="headerlink" title="1. 变量设定(set)"></a>1. 变量设定(set)</h3><p>在bash中， 你可以用”=”来设定或者重新定义变量的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name=value</div></pre></td></tr></table></figure></p>
<p>在设定变量的时候，得遵守如下规则：</p>
<ul>
<li>等号左右两边不能使用分隔符号(IFS),也应避免使用shell的保留元字符(meta charactor); </li>
<li>变量的名称(name)不能使用$符号;</li>
<li>变量的名称(name)的首字符不能是数字(number)。</li>
<li>变量的名称(name)的长度不可超过256个字符。</li>
<li>变量的名称(name)及变量的值的大小写是有区别的、敏感的(case sensitive，) </li>
</ul>
<p>如下是一些变量设定时常见的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A= B #=号前后不能有IFS</div><div class="line">1A=B #变量名称不能以数字开头</div><div class="line">$A=B #变量的名称里有$</div><div class="line">a=B  #这跟a=b是不同的,(这不是错误，提醒windows用户)</div></pre></td></tr></table></figure></p>
<p>如下则是可以接受的设定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A=&quot; B&quot; #IFS被关闭，参考前面的quoting章节</div><div class="line">A1=B   #并非以数字开头</div><div class="line">A=$B   #$可用在变量的值内</div><div class="line">This_Is_A_Long_Name=b #可用_连接较长的名称或值，且有大小区别；</div></pre></td></tr></table></figure></p>
<h3 id="2-变量替换-substitution"><a href="#2-变量替换-substitution" class="headerlink" title="2. 变量替换(substitution)"></a>2. 变量替换(substitution)</h3><p>shell 之所以强大，其中的一个因素是它可以在命令行中对变量作<br>替换(substitution)处理。<br>在命令行中使用者可以使用$符号加上变量名称(除了用=定义变量名称之外)，<br>将变量值给替换出来，然后再重新组建命令行。</p>
<p>比方:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ A=ls</div><div class="line">$ B=la</div><div class="line">$ C=/tmp</div><div class="line">$ $A -$B $C</div></pre></td></tr></table></figure></p>
<p>以上命令行的第一个<code>$</code>是<code>shell prompt</code>, 并不在命令行之内。<br>必须强调的是，我们所提的变量替换，只发生在<code>command line</code>上面。<br>(是的，请让我们再次回到命令行吧！) 仔细分析,最后那行<br><code>command line</code>,不难发现在被执行前(在输入<code>CR</code>字符之前)，<br><code>$</code>符号对每一个变量作替换处理(将变量的值替换出来再重组命令行),<br>最后会得出如下命令行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -la /tmp</div></pre></td></tr></table></figure></p>
<p>还记得第二章，我请大家”务必理解”的那两句吗？<br>若你忘了，我这里重贴一遍：</p>
<blockquote>
<p><strong>Note:</strong></p>
<p>若从技术的细节来看，<code>shell</code>会依据<code>IFS</code>(Internal Field Seperator)<br>将<code>command line</code>所输入的文字拆解为”字段”(word/field)。<br>然后再针对特殊字符(meta)先作处理，最后重组整行<code>command line</code>。</p>
</blockquote>
<p>这里的<code>$</code>就是<code>command line</code>中最经典的meta之一了，<br>就是作变量替换的。在日常的shell操作中，<br>我们常会使用<code>echo</code>命令来查看特定的变量的值，<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo $A -$B $C</div></pre></td></tr></table></figure></p>
<p>我们已学过，<code>echo</code>命令只单纯将其argument送至”标准输出”(stdout, 通常是我们的屏幕)。<br>所以上面的命令会在屏幕上得到如下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -al /tmp</div></pre></td></tr></table></figure></p>
<p>这是由于<code>echo</code>命令在执行时，会先将<code>$A</code> (ls)、<code>$B</code> (la)跟<code>$C</code> (/tmp)给替换出来；<br>利用shell对变量的替换处理能力，我们在设定变量时就更为灵活了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A=B</div><div class="line">B=$A</div></pre></td></tr></table></figure></p>
<p>这样，B的变量值就可继承A变量”当时”的变量值了。<br>不过，不要以”数学逻辑”来套用变量的设定，比方说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A=B</div><div class="line">B=C</div></pre></td></tr></table></figure></p>
<p>这样，并不会让A的变量值变成C。再如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A=B</div><div class="line">B=$A</div><div class="line">A=C</div></pre></td></tr></table></figure></p>
<p>同样也不会让B的值变成C。</p>
<p>上面是单纯定义了两个不同名称的变量：<br>A 与 B, 它们的取值分别是C与B。</p>
<p>若变量被重复定义的话，则原有值为新值所取代。(这不正是”可变的量”吗？^_^)<br>当我们在设定变量的时候，请记住这点：<strong>用一个名称存储一个数值</strong>， 仅此而已。</p>
<p>此外， 我们也可以利用命令行的变量替换能力来”扩充”(append)变量的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A=B:C:D</div><div class="line">A=$A:E</div></pre></td></tr></table></figure></p>
<p>这样， 第一行我们设定A的值为”B:C:D”,<br>然后,第二行再将值扩充为”B:C:D:E”。</p>
<p>上面的扩充的范例，我们使用分隔符号(:)来达到扩充的目的，<br>要是没有分隔符的话，如下是有问题的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A=BCD</div><div class="line">B=$AE</div></pre></td></tr></table></figure></p>
<p>因为第二次是将A的值继承$AE的替换结果，而非$A再加E。<br>要解决此问题，我们可用更严谨的替换处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A=BCD</div><div class="line">A=$&#123;A&#125;E</div></pre></td></tr></table></figure></p>
<p>上例中，我们使用{}将变量名称范围给明确定义出来，<br>如此一来， 我们就可以将A的变量值从BCD给扩充为BCDE。</p>
<blockquote>
<p><strong>Tips:</strong><br>关于${name}事实上还可以做到更多的变量处理能力，<br>这些均属于比较进阶阶段的变量处理，现阶段暂不介绍了，<br>请大家自行参考资料。</p>
</blockquote>
<h3 id="3-export-变量"><a href="#3-export-变量" class="headerlink" title="3. export 变量"></a>3. export 变量</h3><p>严格来说，我们在当前shell中所定义的变量，均属于<br>“本地变量”(local variable), 只有经过<code>export</code>命令的<br>“输出”处理，才能成为”环境变量”(environment variable)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ A=B</div><div class="line">$ export A</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ export A=B</div></pre></td></tr></table></figure></p>
<p>经过<code>export</code>输出处理之后，变量A就能成为一个环境变量<br>供其后的命令使用。在使用<code>export</code>的时候，请别忘记<br>shell在命令行对变量的”替换”(substitution)处理。<br>比方说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ A=B</div><div class="line">$ B=C</div><div class="line">$ export $A</div></pre></td></tr></table></figure></p>
<p>上面的命令并未将A输出为”环境变量”，而是将B导出<br>这是因为在这个命令行中，$A会首先被替换为B,然后在”塞回”<br>作<code>export</code>的参数。</p>
<p>要理解这个<code>export</code>，事实上需要从process(进程)的角度来理解才能透彻。<br>我们将于下一章为大家说明process(进程)的概念，敬请留意。</p>
<h4 id="4-取消变量-unset"><a href="#4-取消变量-unset" class="headerlink" title="4. 取消变量(unset)"></a>4. 取消变量(unset)</h4><p>要取消一个变量，在bash中可使用<code>unset</code>命令来处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unset A</div></pre></td></tr></table></figure></p>
<p>与<code>export</code>一样，<code>unset</code>命令行，也同样会作<br>变量替换(这其实是shell的功能之一)，<br>因此:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ A=B</div><div class="line">$ B=C</div><div class="line">$ unset $A</div></pre></td></tr></table></figure></p>
<p>事实上，所取消的是变量B而不是A。</p>
<p>此外，变量一旦经过unset取消之后，<br>其结果是将整个变量拿掉，而不是取消变量的值。</p>
<p>如下两行其实是很不一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ A=</div><div class="line">$ unset A</div></pre></td></tr></table></figure></p>
<p>第一行只是将变量A设定为”空值”(null value),<br>但第二行则是让变量A不存在。<br>虽然用眼睛来看，<br>这两种变量的状态在如下的命令结果中都是一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ A=</div><div class="line">$ echo $A</div><div class="line"></div><div class="line">$ unset A</div><div class="line">$ echo $A</div></pre></td></tr></table></figure></p>
<p>请学员务必能识别null value 与 unset的本质区别，<br>这在一些进阶的变量处理上是很严格的。</p>
<p>比方说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ str=    #设为null</div><div class="line">$ var=$&#123;str=expr&#125; #定义var</div><div class="line">$ echo $var</div><div class="line"></div><div class="line">$ echo $str</div><div class="line"></div><div class="line">$ unset str #取消str</div><div class="line">$ var=$&#123;str=expr&#125; #定义var</div><div class="line">$ echo $var</div><div class="line">expr</div><div class="line">$ echo $str</div><div class="line">expr</div></pre></td></tr></table></figure></p>
<p>聪明的读者(yes, you!)，稍加思考的话，<br>应该不难发现为何同样的var=${str=expr}<br>在str为null与unset之下的不同吧？<br>若你看不出来，那可能是如下原因之一：</p>
<ul>
<li>你太笨了</li>
<li>不了解 var=${str=expr} 这个进阶处理</li>
<li>对本篇说明还没有来得及消化吸收</li>
<li>我讲得不好</li>
</ul>
<p>不知，您选哪个呢？…… ^_^.</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;问var=value 在export前后的差在哪?&lt;br&gt;&lt;/blockquote&gt;

&lt;hr&gt;
&lt;p&gt;这次让我们暂时丢开&lt;code&gt;command line&lt;/code&gt;,&lt;br&gt;先了解一下bash变量(variable)吧…&lt;/p&gt;
&lt;p&gt;所谓的变量，就是利用一个固定的”名称”(name),&lt;br&gt;来存取一段可以变化的”值”(value)。&lt;/p&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之四 [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E5%9B%9B/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之四/</id>
    <published>2017-04-02T12:49:30.000Z</published>
    <updated>2017-04-02T13:10:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">“”(双引号)与’’(单引号)差在哪？<br></blockquote></p>
<hr>
<p>还是回到我们的<code>command line</code>来吧…</p>
<p>经过前面两章的学习，应该很清楚当你在<code>shell prompt</code>后面敲打键盘,<br>直到按下<code>Enter</code>键的时候，你输入的文字就是<code>command line</code>了，<br>然后<code>shell</code>才会以进程的方式执行你所交给它的命令。<br>但是，你又可知道：你在<code>command line</code>中输入的每一个文字，<br>对<code>shell</code>来说，是有类别之分的呢？</p>
<p>简单而言，(我不敢说精确的定义，注1),<br><code>command line</code>的每一个<code>charactor</code>, 分为如下两种：</p>
<ul>
<li>literal：也就是普通的纯文字，对<code>shell</code>来说没特殊功能；</li>
<li>meta: 对<code>shell</code>来说，具有特定功能的特殊保留元字符。</li>
</ul>
<a id="more"></a>
<blockquote>
<p><strong>Note:</strong></p>
<p>对于<code>bash shell</code>在处理<code>comamnd line</code>的顺序说明，<br>请参考O’Reilly出版社的<strong>Learning the Bash Shell，2nd Edition</strong>，<br>第177-180页的说明，尤其是178页的流程图：Figure 7-1 …</p>
</blockquote>
<p><code>literal</code>没什么好谈的，<br>像abcd、123456这些”文字”都是literal…(so easy? ^_^)<br>但meta却常使我们困惑…(confused?)<br>事实上，前两章，我们在<code>command line</code>中已碰到两个<br>似乎每次都会碰到的meta：</p>
<ul>
<li><code>IFS</code>：有<code>space</code>或者<code>tab</code>或者<code>Enter</code>三者之一组成(我们常用space)</li>
<li><code>CR</code>: 由<code>Enter</code>产生；</li>
</ul>
<p><code>IFS</code>是用来拆解<code>command line</code>中每一个词(word)用的，<br>因为<code>shell command line</code>是按词来处理的。<br>而<code>CR</code>则是用来结束<code>command line</code>用的，这也是为何我们敲<code>Enter</code>键，<br>命令就会跑的原因。</p>
<p>除了常用的<code>IFS</code>与<code>CR</code>, 常用的meta还有：</p>
<table>
<thead>
<tr>
<th>meta字符</th>
<th>meta字符作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>设定变量</td>
</tr>
<tr>
<td>$</td>
<td>作变量或运算替换(请不要与<code>shell prompt</code>混淆)</td>
<td>命令</td>
</tr>
<tr>
<td>&gt;</td>
<td>输出重定向(重定向stdout)</td>
</tr>
<tr>
<td>&lt;</td>
<td>输入重定向(重定向stdin)</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>命令管道</td>
</tr>
<tr>
<td>&amp;</td>
<td>重定向file descriptor或将命令至于后台(bg)运行</td>
</tr>
<tr>
<td>()</td>
<td>将其内部的命令置于nested subshell执行，或用于运算或变量替换</td>
</tr>
<tr>
<td>{}</td>
<td>将期内的命令置于non-named function中执行，或用在变量替换的界定范围</td>
</tr>
<tr>
<td>;</td>
<td>在前一个命令执行结束时，而忽略其返回值，继续执行下一个命令</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>在前一个命令执行结束时，若返回值为true，继续执行下一个命令</td>
</tr>
<tr>
<td>\</td>
<td>\</td>
<td></td>
<td>在前一个命令执行结束时，若返回值为false，继续执行下一个命令</td>
</tr>
<tr>
<td>!</td>
<td>执行histroy列表中的命令</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>假如我们需要在<code>command line</code>中将这些保留元字符的功能关闭的话，<br>就需要quoting处理了。</p>
<p>在<code>bash</code>中，常用的quoting有以下三种方法：</p>
<ul>
<li>hard quote：’’(单引号)，凡在hard quote中的所有meta均被关闭；</li>
<li>soft quote：””(双引号)，凡在soft quote中大部分meta都会被关闭，但某些会保留(如$);</li>
<li>escape: \ (反斜杠)，只有在紧接在escape(跳脱字符)之后的单一meta才被关闭；</li>
</ul>
<blockquote>
<p><strong>Note:</strong></p>
<p> 在soft quote中被豁免的具体meta清单，我不完全知道，<br> 有待大家补充，或通过实践来发现并理解。</p>
</blockquote>
<p>下面的例子将有助于我们对quoting的了解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ A=B C #空白符未被关闭，作为IFS处理</div><div class="line">$ C：command not found.</div><div class="line">$ echo $A</div><div class="line"></div><div class="line">$ A=&quot;B C&quot; #空白符已被关掉，仅作为空白符</div><div class="line">$ echo $A</div><div class="line">B C</div></pre></td></tr></table></figure></p>
<p>在第一个给A变量赋值时，由于空白符没有被关闭，<br><code>command line</code> 将被解释为：<br><code>A=B 然后碰到&lt;IFS&gt;，接着执行C命令</code><br>在第二次给A变量赋值时，由于空白符被置于soft quote中，<br>因此被关闭，不在作为<code>IFS</code>；<br><code>A=B&lt;space&gt;C</code><br>事实上，空白符无论在soft quote还是在hard quote中，<br>均被关闭。Enter键字符亦然：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ A=`B</div><div class="line">&gt; C</div><div class="line">&gt; &apos;</div><div class="line">$ echo &quot;$A&quot;</div><div class="line">B</div><div class="line">C</div></pre></td></tr></table></figure>
<p>在上例中，由于<code>enter</code>被置于hard quote当中，因此不再作为<code>CR</code>字符来处理。<br>这里的<code>enter</code>单纯只是一个断行符号(new-line)而已，<br>由于<code>command line</code>并没得到<code>CR</code>字符，<br>因此进入第二个<code>shell prompt</code>(<code>PS2</code>, 以&gt;符号表示)，<br><code>command line</code>并不会结束，直到第三行，<br>我们输入的<code>enter</code>并不在hard quote里面，<br>因此没有被关闭，<br>此时，<code>command line</code>碰到<code>CR</code>字符，于是结束，交给shell来处理。</p>
<p>上例的<code>Enter</code>要是被置于soft quote中的话，<code>CR</code>字符也会同样被关闭：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ A=&quot;B</div><div class="line">&gt; C</div><div class="line">&gt; &quot;</div><div class="line">$ echo $A</div><div class="line">B C</div></pre></td></tr></table></figure>
<p>然而，由于 <code>echo $A</code>时的变量没有置于soft quote中，<br>因此，当变量替换完成后，并作命令行重组时，<code>enter</code>被解释为<code>IFS</code>，<br>而不是new-line字符。</p>
<p>同样的，用escape亦可关闭CR字符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ A=B\</div><div class="line">&gt; C\</div><div class="line">&gt;</div><div class="line">$ echo $A</div><div class="line">BC</div></pre></td></tr></table></figure></p>
<p>上例中的，第一个<code>enter</code>跟第二个<code>enter</code>均被escape字符关闭了，<br>因此也不作为<code>CR</code>来处理，但第三个<code>enter</code>由于没有被escape，<br>因此，作为<code>CR</code>结束<code>command line</code>。<br>但由于<code>enter</code>键本身在shell meta中特殊性，在 \ escape字符后面<br>仅仅取消其<code>CR</code>功能， 而不保留其IFS功能。</p>
<p>你或许发现光是一个<code>enter</code>键所产生的字符，就有可能是如下这些可能：</p>
<ul>
<li>CR</li>
<li>IFS</li>
<li>NL(New Line)</li>
<li>FF(Form Feed)</li>
<li>NULL</li>
<li>…</li>
</ul>
<p>至于，什么时候解释为什么字符，这个我就没法去挖掘了，<br>或者留给读者君自行慢慢摸索了…^-^</p>
<p>至于soft quote跟hard quote的不同，主要是对于某些meta的关闭与否，以$来做说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ A=B\ C</div><div class="line">$ echo &quot;$A&quot;</div><div class="line">B C</div><div class="line">$ echo &apos;$A&apos;</div><div class="line">$A</div></pre></td></tr></table></figure></p>
<p>在第一个<code>echo</code>命令行中，$被置于soft quote中，将不被关闭，<br>因此继续处理变量替换，<br>因此，<code>echo</code>将A的变量值输出到屏幕，也就是”B C”的结果。</p>
<p>在第二个<code>echo</code>命令行中，$被置于hard quote中，则被关闭，<br>因此，$只是一个$符号，并不会用来做变量替换处理，<br>因此结果是$符号后面接一个A字母：$A.</p>
<blockquote>
<p> <strong>练习与思考:</strong> 如下结果为何不同？</p>
<p> tips: 单引号和双引号，在quoting中均被关闭了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ A=B\ C</div><div class="line">$ echo &apos;&quot;$A&quot;&apos;  #最外面的是单引号</div><div class="line">&quot;$A&quot;</div><div class="line">$ echo &quot;&apos;$A&apos;&quot;  #最外面的是双引号</div><div class="line">&apos;B C&apos;</div></pre></td></tr></table></figure>
<hr>
<p>在CU的shell版里，我发现很多初学者的问题，<br>都与quoting的理解有关。<br>比方说，若我们在awk或sed的命令参数中，<br>调用之前设定的一些变量时，常会问及为何不能的问题。</p>
<p>要解决这些问题，关键点就是：<strong>区分出 shell meta 与 command meta</strong></p>
<p>前面我们提到的那些meta，都是在command line中有特殊用途的，<br>比方说{}就是将一系列的command line置于不具名的函数中执行(可简单视为command block)，<br>但是，awk却需要用{}来区分出awk的命令区段(BEGIN,MAIN,END).<br>若你在command line中如此输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk &#123;print $0&#125; 1.txt</div></pre></td></tr></table></figure></p>
<p>由于{}在shell中并没有关闭，那shell就将{print $0}视为command block，<br>但同时没有<code>;</code>符号作命令分隔，因此，就出现awk语法错误结果。</p>
<p>要解决之，可用hard quote:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk &apos;&#123;print $0&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>上面的hard quote应好理解，就是将原来的<br>{、<space>、$、}这几个shell meta关闭，<br>避免掉在shell中遭到处理，而完整的成为awk的参数中command meta。</space></p>
<blockquote>
<p><strong>Note:</strong></p>
<p>awk中使用的$0 是awk中内建的field nubmer，而非awk的变量，<br>awk自身的变量无需使用$.</p>
</blockquote>
<p>要是理解了hard quote的功能，在来理解soft quote与escape就不难：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">awk &quot;&#123;print \$0&#125;&quot; 1.txt</div><div class="line">awk \&#123;print \$0\&#125; 1.txt</div></pre></td></tr></table></figure></p>
<p>然而，若要你改变awk的$0的0值是从另一个shell变量中读进呢？<br>比方说：已有变量$A的值是0， 那如何在<code>command line</code>中解决<br>awk的$$A呢？<br>你可以很直接否定掉hard quote的方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;&#123;print $$A&#125;&apos; 1.txt</div></pre></td></tr></table></figure></p>
<p>那是因为$A的$在hard quote中是不能替换变量的。</p>
<p>聪明的读者(如你！)，经过本章的学习，我想，你应该可以理解为<br>为何我们可以使用如下操作了吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A=0</div><div class="line">awk &quot;&#123;print \$$A&#125;&quot; 1.txt</div><div class="line">awk  \&#123;print\ \$$A\&#125; 1.txt</div><div class="line">awk &apos;&#123;print $&apos;$A&apos;&#125;&apos; 1.txt</div><div class="line">awk &apos;&#123;print $&apos;&quot;$A&quot;&apos;&#125;&apos; 1.txt</div></pre></td></tr></table></figure></p>
<p>或许，你能给出更多方案… ^_^</p>
<p>更多练习：</p>
<ul>
<li><a href="http://bbs.chinaunix.net/forum/viewtopic.php?t=207178" target="_blank" rel="external">http://bbs.chinaunix.net/forum/viewtopic.php?t=207178</a><br>一个关于read命令的小问题：<br>很早以前觉得很奇怪：执行read命令，然后读取用户输入给变量赋值，<br>但如果输入是以空格键开始的话，这空格会被忽略，比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">read a  #输入：    abc</div><div class="line">echo &quot;$a&quot; #只输出abc</div></pre></td></tr></table></figure>
</li>
</ul>
<p>原因:<br>    变量a的值，从终端输入的值是以IFS开头，而这些IFS将被shell解释器忽略(trim)。<br>    应该与shell解释器分词的规则有关；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">read a  #输入：\ \ \ abc</div><div class="line">echo &quot;$a&quot; #只输出abc</div></pre></td></tr></table></figure>
<p>需要将空格字符转义</p>
<blockquote>
<p><strong>Note:</strong> </p>
<p> IFS   Internal field separators, normally  space,  tab,  and newline (see Blank Interpretation section).<br> ……<br> Blank Interpretation<br>  After parameter and command  substitution,  the  results  of substitution<br>  are scanned for internal field separator characters (those found in IFS)<br>  and split  into  distinct  arguments  where  such characters are found.<br>  Explicit null arguments (“” or  ‘’)  are  retained.<br>  Implicit  null  arguments(those  resulting  from  parameters that have no values)<br>  are removed.<br>  (refre to: man sh)</p>
</blockquote>
<p>解决思路：</p>
<ol>
<li>shell command line 主要是将整行line给分解(break down)为每一个单词(word);</li>
<li>而词与词之间的分隔符就是IFS (Internal Field Seperator)。</li>
<li>shell会对command line作处理(如替换，quoting等), 然后再按词重组。(注：别忘了这个重组特性)</li>
<li>当你用IFS来事开头一个变量值，那shell会先整理出这个词，然后在重组command line。<br>5.然而，你将IFS换成其他，那shell将视你哪些space/tab为“词”，而不是IFS。那在重组时，可以得到这些词。</li>
</ol>
<p>若你还是不理解，那来验证一下下面这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ A=&quot;  abc&quot; </div><div class="line">$ echo $A</div><div class="line">abc</div><div class="line">$ echo &quot;$A&quot; #note1</div><div class="line">   abc</div><div class="line">$ old_IFS=$IFS</div><div class="line">$ IFS=;</div><div class="line">$ echo $A</div><div class="line">   abc</div><div class="line">$ IFS=$old_IFS</div><div class="line">$ echo $A</div><div class="line">abc</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Note:</strong></p>
<ol>
<li><p>这里是用 soft quoting 将里面的 space 关闭，使之不是 meta(IFS)，<br>而是一个literal(white space);</p>
</li>
<li><p>IFS=; 意义是将IFS设置为空字符，因为;是shell的元字符(meta);</p>
</li>
</ol>
</blockquote>
<p>问题二：为什么多做了几个分号，我想知道为什么会出现空格呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ a=&quot;;;;test&quot;                              </div><div class="line">$ IFS=&quot;;&quot;                                  </div><div class="line">$ echo $a                                  </div><div class="line">   test                                                                         </div><div class="line">$ a=&quot;   test&quot;                              </div><div class="line">$ echo $a                                  </div><div class="line">   test                                                                         </div><div class="line">$ IFS=&quot; &quot;                                  </div><div class="line">$ echo $a                                  </div><div class="line">test</div></pre></td></tr></table></figure></p>
<p>解答：</p>
<p>这个问题，出在<code>IFS=;</code>上。<br>因为这个<code>;</code>在问题一中的command line上是一个meta,<br>并非<code>&quot;;&quot;</code>符号本身。<br>因此，<code>IFS=;</code>是将IFS设置为 null charactor<br>(不是space、tab、newline)。</p>
<p>要不是试试下面这个代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ old_IFS=$IFS</div><div class="line">$ read A</div><div class="line">;a;b;c</div><div class="line">$ echo $A</div><div class="line">;a;b;c</div><div class="line">$ IFS=&quot;;&quot;  #Note2</div><div class="line">$ echo $A</div><div class="line">a b c</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Note:</strong></p>
<p>要关闭<code>;</code>可用<code>&quot;;&quot;</code>或者<code>&#39;;&#39;</code>或者<code>\;</code>。</p>
</blockquote>
<ul>
<li><a href="http://bbs.chinaunix.net/forum/viewtopic.php?t=216729" target="_blank" rel="external">http://bbs.chinaunix.net/forum/viewtopic.php?t=216729</a></li>
</ul>
<p>思考问题二：文本处理：读文件时，如何保证原汁原味。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cat file | while read i</div><div class="line">do</div><div class="line">   echo $i</div><div class="line">done</div></pre></td></tr></table></figure></p>
<p>文件file的行中包含若干空，经过read只保留不重复的空格。<br>如何才能所见即所得。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cat file | while read i</div><div class="line">do</div><div class="line">   echo &quot;X$&#123;i&#125;X&quot;</div><div class="line">done</div></pre></td></tr></table></figure>
<p>从上面的输出，可以看出read，读入是按整行读入的;<br>不能原汁原味的原因：</p>
<ol>
<li>如果行的起始部分有IFS之类的字符，将被忽略;</li>
<li><code>echo $i</code>的解析过程中，首先将$i替换为字符串，<br>然后对echo 字符串中字符串分词，然后命令重组，输出结果;<br>在分词，与命令重组时，可能导致多个相邻的IFS转化为一个;</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cat file | while read i</div><div class="line">do</div><div class="line">  echo &quot;$i&quot;</div><div class="line">done</div></pre></td></tr></table></figure>
<p>以上代码可以解决原因2中的，command line的分词和重组导致meta字符丢失；<br>但仍然解决不了原因1中，read读取行时，忽略行起始的IFS meta字符。</p>
<p>回过头来看上面这个问题：为何要原汁原味呢？<br>cat命令就是原汁原味的，只是shell的read、echo导致了某些shell的meta字符丢失;</p>
<p>如果只是IFS meta的丢失，可以采用如下方式：<br>将IFS设置为null，即<code>IFS=;</code>,<br>在此再次重申此处<code>;</code>是shell的meta字符,而不是literal字符;<br>因此要使用literal的    <code>;</code>应该是<code>\;</code><br>或者关闭meta 的(soft/hard) quoting的<code>&quot;;&quot;</code>或者<code>&#39;;&#39;</code>。</p>
<p>因此上述的解决方案是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">old_IFS=$IFS</div><div class="line">IFS=; #将IFS设置为null</div><div class="line">cat file | while read i</div><div class="line">do</div><div class="line">  echo &quot;$i&quot;</div><div class="line">done</div><div class="line">IFS=old_IFS #恢复IFS的原始值</div></pre></td></tr></table></figure></p>
<p>现在，回过头来看这个问题，为什么会有这个问题呢；<br>其本源的问题应该是没有找到解决原始问题的最合适的方法，<br>而是采取了一个迂回的方式来解决了问题；</p>
<p>因此，我们应该回到问题的本源，重新审视一下，问题的本质。<br>如果要精准的获取文件的内容，应该使用od或者hexdump会更好些。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;“”(双引号)与’’(单引号)差在哪？&lt;br&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;还是回到我们的&lt;code&gt;command line&lt;/code&gt;来吧…&lt;/p&gt;
&lt;p&gt;经过前面两章的学习，应该很清楚当你在&lt;code&gt;shell prompt&lt;/code&gt;后面敲打键盘,&lt;br&gt;直到按下&lt;code&gt;Enter&lt;/code&gt;键的时候，你输入的文字就是&lt;code&gt;command line&lt;/code&gt;了，&lt;br&gt;然后&lt;code&gt;shell&lt;/code&gt;才会以进程的方式执行你所交给它的命令。&lt;br&gt;但是，你又可知道：你在&lt;code&gt;command line&lt;/code&gt;中输入的每一个文字，&lt;br&gt;对&lt;code&gt;shell&lt;/code&gt;来说，是有类别之分的呢？&lt;/p&gt;
&lt;p&gt;简单而言，(我不敢说精确的定义，注1),&lt;br&gt;&lt;code&gt;command line&lt;/code&gt;的每一个&lt;code&gt;charactor&lt;/code&gt;, 分为如下两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;literal：也就是普通的纯文字，对&lt;code&gt;shell&lt;/code&gt;来说没特殊功能；&lt;/li&gt;
&lt;li&gt;meta: 对&lt;code&gt;shell&lt;/code&gt;来说，具有特定功能的特殊保留元字符。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之三  [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E4%B8%89/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之三/</id>
    <published>2017-04-02T12:49:27.000Z</published>
    <updated>2017-04-02T13:08:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">别人echo、你也echo，是问echo知多少？<br></blockquote></p>
<hr>
<p>承接上一章介绍的<code>command line</code>, 这里我们用<code>echo</code>这个命令加以进一步说明。</p>
<blockquote>
<p> <strong>温习</strong><br> 标准的<code>command line</code>三个组成部分：<code>command_name option argument</code></p>
</blockquote>
<p><code>echo</code>是一个非常简单、直接的Linux命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> argument</div></pre></td></tr></table></figure>
<p><code>echo</code>将argument送出到<code>标准输出</code>(<code>stdout</code>),通常是在监视器(monitor)上输出。</p>
<a id="more"></a>
<p><strong>Note：</strong></p>
<blockquote>
<p>在linux系统中任何一个进程默认打开三个文件：stdin、stdout、stderr.</p>
<p>stdin  标准输入</p>
<p>stdout 标准输出</p>
<p>stderr 标准错误输出</p>
</blockquote>
<p>为了更好理解，不如先让我们先跑一下<code>echo</code>命令好了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$echo</div><div class="line"></div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>你会发现只有一个空白行，然后又回到了<code>shell prompt</code>上了。<br>这是因为<code>echo</code>在预设上，在显示完argument之后，还会送出以一个换行符号<br>(<code>new-line charactor</code>).<br>但是上面的command <code>echo</code>并没有任何argument，那结果就只剩一个换行符号。<br>若你要取消这个换行符号， 可以利用<code>echo</code>的<code>-n</code> 选项:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$echo -n</div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>不妨让我们回到<code>command line</code>的概念上来讨论上例的echo命令好了：<br><code>command line</code>只有command_name(<code>echo</code>)及option(<code>-n</code>),并没有显示任何<code>argument</code>。</p>
<p>要想看看<code>echo</code>的<code>argument</code>，那还不简单接下来，你可以试试如下的输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$echo first line</div><div class="line">first line</div><div class="line">$echo -n first line</div><div class="line">first line $</div></pre></td></tr></table></figure></p>
<p>以上两个<code>echo</code>命令中，你会发现<code>argument</code>的部分显示在你的屏幕，<br>而换行符则视 <code>-n</code> 选项的有无而别。<br>很明显的，第二个<code>echo</code>由于换行符被取消了，<br>接下来的<code>shell prompt</code>就接在输出结果的同一行了… ^_^。</p>
<p>事实上，<code>echo</code>除了<code>-n</code> 选项之外，常用选项有：</p>
<ul>
<li>-e: 启用反斜杠控制字符的转换(参考下表)</li>
<li>-E: 关闭反斜杠控制字符的转换(预设如此)</li>
<li>-n: 取消行末的换行符号(与-e选项下的\c字符同意)</li>
</ul>
<p>关于<code>echo</code>命令所支持的反斜杠控制字符如下表：</p>
<table>
<thead>
<tr>
<th></th>
<th>转义字符</th>
<th>字符的意义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>\a</td>
<td>ALERT / BELL(从系统的喇叭送出铃声)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\b</td>
<td>BACKSPACE, 也就是向左退格键</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\c</td>
<td>取消行末之换行符号</td>
</tr>
<tr>
<td></td>
<td>\E</td>
<td>ESCAPE, 脱字符键</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\f</td>
<td>FORMFEED, 换页字符</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\n</td>
<td>NEWLINE,  换行字符</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\r</td>
<td>RETURN,  回车键</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\t</td>
<td>TAB, 表格跳位键</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\v</td>
<td>VERTICAL TAB, 垂直表格跳位键</td>
<td></td>
</tr>
<tr>
<td></td>
<td>\n</td>
<td>ASCII 八进制编码(以x开头的为十六进制)，此处的n为数字</td>
</tr>
<tr>
<td></td>
<td>\</td>
<td>反斜杠本身</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Note：</strong><br>上述表格的资料来自O’Reilly出版社的<strong>Learning the Bash Shell, 2nd Ed</strong>.</p>
</blockquote>
<p>或许，我们可以通过实例来了解<code>echo</code>的选项及控制字符：</p>
<p>例一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ echo -e &quot;a\tb\tc\n\d\te\tf&quot;</div><div class="line">a    b	c</div><div class="line">d	e	f</div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>上例中，用\t来分割abc还有def，及用\n将def换至下一行。</p>
<p>例二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$echo -e &quot;\141\011\142\011\143\012\144\011\145\011\146&quot;</div><div class="line">a	b	c</div><div class="line">d	e	f</div></pre></td></tr></table></figure></p>
<p>与例一中结果一样，只是使用ASCII八进制编码。</p>
<p>例三：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$echo -e &quot;\x61\x09\x62\x09\x63\x0a\x64\x09\x65\x09\x66&quot;</div><div class="line">a	b	c</div><div class="line">d	e	f</div></pre></td></tr></table></figure></p>
<p>与例二差不多，只是这次换用ASCII的十六进制编码。</p>
<p>例四：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$echo -ne &quot;a\tb\tc\nd\te\bf\a&quot;</div><div class="line">a       b       c</div><div class="line">d       f $</div></pre></td></tr></table></figure></p>
<p>因为e字母后面是退格键(\b)，因此输出结果就没有e了。<br>在结束的时听到一声铃响，是\a的杰作。<br>由于同时使用了-n选项，因此<code>shell prompt</code>紧接在第二行之后。<br>若你不用-n的话，那你在\a后再加个\c，也是同样的效果。</p>
<p>事实上，在日后的<code>shell</code>操作及<code>shell script</code>设计上，<br><code>echo</code>命令是最常被使用的命令之一。<br>比方说，使用<code>echo</code>来检查变量值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ A=B</div><div class="line">$ echo $A</div><div class="line">B</div><div class="line">$ echo $?</div><div class="line">0</div></pre></td></tr></table></figure></p>
<blockquote>
<p> <strong>Note:</strong><br> 关于变量的概念，我们留到以下的两章跟大家说明。</p>
</blockquote>
<p>好了，更多的关于<code>command line</code>的格式， 以及<code>echo</code>命令的选项，<br>请您自行多加练习、运用了…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;别人echo、你也echo，是问echo知多少？&lt;br&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;承接上一章介绍的&lt;code&gt;command line&lt;/code&gt;, 这里我们用&lt;code&gt;echo&lt;/code&gt;这个命令加以进一步说明。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; &lt;strong&gt;温习&lt;/strong&gt;&lt;br&gt; 标准的&lt;code&gt;command line&lt;/code&gt;三个组成部分：&lt;code&gt;command_name option argument&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;echo&lt;/code&gt;是一个非常简单、直接的Linux命令：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; argument&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;echo&lt;/code&gt;将argument送出到&lt;code&gt;标准输出&lt;/code&gt;(&lt;code&gt;stdout&lt;/code&gt;),通常是在监视器(monitor)上输出。&lt;/p&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之二  [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E4%BA%8C/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之二/</id>
    <published>2017-04-02T12:49:24.000Z</published>
    <updated>2017-04-02T13:00:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">shell prompt(PS1)与Carriage Return(CR)关系<br></blockquote>


<hr>
<p>当你成功登陆一个shell终端的文字界面之后，大部分的情形下，<br>你会在屏幕上看到一个不断闪烁的方块或者底线(视不同的版本而别)，<br>我们称之为<code>游标</code>(<code>cursor</code>).<br><code>cursor</code>作用就是告诉你接下来你从键盘输入的按键所插入的位置，<br>且每输入一个键，<code>cursor</code>便向右移动一个格子，<br>如果连续输入太多的话，则自动接在下一行输入。</p>
<p>假如你刚完成登陆，还没有输入任何按键之前，<br>你所看到的<code>cursor</code>所在的位置的同一行的左边部分，我们称之为<code>提示符</code>(<code>prompt</code>)。</p>
<a id="more"></a>
<p><code>提示符</code>的格式或因不同的版本而各有不同，<br>在Linux上，只需留意最接近<code>游标</code>的一个提示符号，通常是如下两者之一：</p>
<ul>
<li>$: 给一般用户账号使用;</li>
<li>#: 给root(管理员)账号使用;</li>
</ul>
<p>事实上，shell prompt的意思很简单：<br>告诉shell使用者，您现在可以输入命令行了。</p>
<p>我们可以说，使用者只有在得到shell prompt才能打命令行，<br>而<code>cursor</code>是指示键盘在命令行的输入位置，使用者每输入一个键，<br><code>cursor</code>就往后移动一个格，直到碰到命令行读进<code>CR</code>(<code>Carriage Return</code>, 由<code>Enter</code>键产生)字符为止。<br> <code>CR</code>的意思也很简单：<br>使用者告诉shell：老兄，你可以执行的我命令行了。<br>严格来说：<br>所谓的命令行， 就是在<code>shell prompt</code>与<code>CR</code>之间所输入的文字。</p>
<p>(<strong>question：为何我们这里坚持使用<code>CR</code>字符而不说<code>Enter</code>按键呢？<br>答案在后面的学习中给出</strong>)。</p>
<p>不同的命令可以接受的命令的格式各有不同，<br>一般情况下，一个标准的命令行格式为如下所列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">command-name options argument</div></pre></td></tr></table></figure></p>
<p>若从技术的细节上来看，<br>shell会依据<code>IFS</code>(<code>Internal Field Seperator</code>) 将 command line<br>所输入的文字给拆解为<code>字段</code>(<code>word</code>).<br>然后在针对特殊的字符(meta)先做处理，最后在重组整行command line。</p>
<p>(<strong>注意：请务必理解以上两句的意思，我们日后的学习中常回到这里思考</strong>。)</p>
<p>其中<code>IFS</code>是shell预设使用的字段位分隔符号，可以由一个及多个如下按键组成：</p>
<ul>
<li>空白键(White Space)</li>
<li>表格键(Tab)</li>
<li>回车键(Enter)</li>
</ul>
<p>系统可以接受的命令的名称(command-name)可以从如下途径获得：</p>
<ul>
<li>确定的路径所指定的外部命令</li>
<li>命令的别名(alias)</li>
<li>shell内建命令(built-in)</li>
<li>$PATH之下的外部命令</li>
</ul>
<p>每一个命令行均必须包含命令的名称，这是不能缺少的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;shell prompt(PS1)与Carriage Return(CR)关系&lt;br&gt;&lt;/blockquote&gt;


&lt;hr&gt;
&lt;p&gt;当你成功登陆一个shell终端的文字界面之后，大部分的情形下，&lt;br&gt;你会在屏幕上看到一个不断闪烁的方块或者底线(视不同的版本而别)，&lt;br&gt;我们称之为&lt;code&gt;游标&lt;/code&gt;(&lt;code&gt;cursor&lt;/code&gt;).&lt;br&gt;&lt;code&gt;cursor&lt;/code&gt;作用就是告诉你接下来你从键盘输入的按键所插入的位置，&lt;br&gt;且每输入一个键，&lt;code&gt;cursor&lt;/code&gt;便向右移动一个格子，&lt;br&gt;如果连续输入太多的话，则自动接在下一行输入。&lt;/p&gt;
&lt;p&gt;假如你刚完成登陆，还没有输入任何按键之前，&lt;br&gt;你所看到的&lt;code&gt;cursor&lt;/code&gt;所在的位置的同一行的左边部分，我们称之为&lt;code&gt;提示符&lt;/code&gt;(&lt;code&gt;prompt&lt;/code&gt;)。&lt;/p&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell十三问之一  [转载]</title>
    <link href="http://yoursite.com/2017/04/02/shell%E5%8D%81%E4%B8%89%E9%97%AE%E4%B9%8B%E4%B8%80/"/>
    <id>http://yoursite.com/2017/04/02/shell十三问之一/</id>
    <published>2017-04-02T12:49:19.000Z</published>
    <updated>2017-04-02T12:58:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">何为shell？<br></blockquote></p>
<hr>
<p> <code>shell</code>是什么东西之前，不妨让我们重新审视<code>使用者</code>和<code>计算机系统</code>的关系：<br>（此处为使用者和计算机系统的关系图）</p>
<p>我们知道计算机的运作不能离开硬件，但使用者却无法直接操作硬件，<br>硬件的驱动只能通过一种称为“<code>操作系统</code>(<code>OS</code>，<code>Opertating System</code>)”的软件来管控。<br>事实上，我们每天所谈的“<code>linux</code>”，严格来说只是一个<code>操作系统</code>(<code>OS</code>),<br>我们称之为“<code>内核</code>(<code>kernel</code>)”。</p>
<p>然而，从使用者的角度来说，使用者没有办法直接操作一个<code>kernel</code>，<br>而是通过<code>kernel</code>的“外壳”程序，也就是所谓的<code>shell</code>，来与<code>kernel</code>沟通。<br>这也正是<code>kernel</code>跟<code>shell</code>的形象命名的的关系。如图：<br> （此处为kernel–&gt;shell关系图；)</p>
<a id="more"></a>
<p>从技术的角度来说，<code>shell</code>是一个使用者与系统的<code>交互界面(interface)</code>,<br>只能让使用者通过<code>命令行</code>(<code>command line</code>)来使用系统来完成工作。<br>因此，<code>shell</code>最简单的定义就是—-<code>命令解释器</code>( <code>Command Interpreter</code>):</p>
<ul>
<li>将使用者的命令翻译给kernel来处理；</li>
<li>同时，将kernel的处理结果翻译给使用者。</li>
</ul>
<p>每次当我们完成<code>系统登入</code>(<code>login</code>), 我们就取得一个交互模式的shell，<br>也称之为<code>login shell</code> 或者 <code>primary shell</code>。</p>
<p>若从<code>进程</code>(<code>process</code>)的角度来说，我们在shell所下达的命令，均是shell所产生的<code>子进程</code>。<br>这种现象，我暂可称之为<code>fork</code>。</p>
<p>如果是执行<code>shell脚本</code>(<code>shell script</code>)的话，脚本中命令则是由另一个非交互模式的<br><code>子shell</code>(<code>sub shell</code>)来执行的。 也就是primary shell产生sub shell的进程，而该sub shell<br>进程再产生script中所有命令的进程。<br> (关于进程，我们日后有机会在补充)</p>
<p>这里， 我们必须知道：<code>kernel</code> 与 <code>shell</code> 是不同的两套软件，而且都是可以被替换的：</p>
<ul>
<li>不同的<code>OS</code>使用不同的<code>kernel</code>;</li>
<li>同一个kernel之上，也可以使用不同的<code>shell</code>;</li>
</ul>
<p>在<code>Linux</code>的预设系统中，通常可以找到好几种不同的<code>shell</code>,<br>且通常会被记录在如下文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/shells</div></pre></td></tr></table></figure></p>
<p>不同的<code>shell</code>有着不同的功能，且彼此各异，或者说“大同小异”。<br>常见的<code>shell</code>主要分为两大主流：</p>
<ol>
<li>sh：<ul>
<li>burne shell (sh)</li>
<li>burne again shell (bash)</li>
</ul>
</li>
<li>csh：<ul>
<li>c shell (csh)</li>
<li>tc shell (tcsh)</li>
<li>korn shell (ksh)<br>(FIXME)</li>
</ul>
</li>
</ol>
<p>大部分的Linux操作系统的预设shell都是<code>bash</code>，其原因大致如下两种：</p>
<ul>
<li>自由软件</li>
<li>功能强大<br>bash是gnu project最成功的产品之一，自推出以来深受广大<code>Unix</code>用户的喜爱，<br>且也逐渐成为不少组织的系统标准。</li>
</ul>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=79938&auto=0&height=66"></iframe>



<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
<!--author：maxie（马驰原）-->
<!--QQ：17045930-->
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;何为shell？&lt;br&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt; &lt;code&gt;shell&lt;/code&gt;是什么东西之前，不妨让我们重新审视&lt;code&gt;使用者&lt;/code&gt;和&lt;code&gt;计算机系统&lt;/code&gt;的关系：&lt;br&gt;（此处为使用者和计算机系统的关系图）&lt;/p&gt;
&lt;p&gt;我们知道计算机的运作不能离开硬件，但使用者却无法直接操作硬件，&lt;br&gt;硬件的驱动只能通过一种称为“&lt;code&gt;操作系统&lt;/code&gt;(&lt;code&gt;OS&lt;/code&gt;，&lt;code&gt;Opertating System&lt;/code&gt;)”的软件来管控。&lt;br&gt;事实上，我们每天所谈的“&lt;code&gt;linux&lt;/code&gt;”，严格来说只是一个&lt;code&gt;操作系统&lt;/code&gt;(&lt;code&gt;OS&lt;/code&gt;),&lt;br&gt;我们称之为“&lt;code&gt;内核&lt;/code&gt;(&lt;code&gt;kernel&lt;/code&gt;)”。&lt;/p&gt;
&lt;p&gt;然而，从使用者的角度来说，使用者没有办法直接操作一个&lt;code&gt;kernel&lt;/code&gt;，&lt;br&gt;而是通过&lt;code&gt;kernel&lt;/code&gt;的“外壳”程序，也就是所谓的&lt;code&gt;shell&lt;/code&gt;，来与&lt;code&gt;kernel&lt;/code&gt;沟通。&lt;br&gt;这也正是&lt;code&gt;kernel&lt;/code&gt;跟&lt;code&gt;shell&lt;/code&gt;的形象命名的的关系。如图：&lt;br&gt; （此处为kernel–&amp;gt;shell关系图；)&lt;/p&gt;
    
    </summary>
    
      <category term="shell十三问" scheme="http://yoursite.com/categories/shell%E5%8D%81%E4%B8%89%E9%97%AE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>开源堡垒机JumpServer的安装</title>
    <link href="http://yoursite.com/2017/04/02/%E5%BC%80%E6%BA%90%E5%A0%A1%E5%9E%92%E6%9C%BAJumpServer%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2017/04/02/开源堡垒机JumpServer的安装/</id>
    <published>2017-04-02T10:09:53.000Z</published>
    <updated>2017-04-02T12:24:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">完全开源、极致省力、界面美观、功能完整<br><br>    –JumpServer的特性<br></blockquote>

<p>Jumpserver Jumpserver 是一款由python编写开源的跳板机(堡垒机)系统，实现了跳板机应有的功能。基于ssh协议来管理，客户端无需安装agent。</p>
<!-- 标签 方式，要求版本在0.4.5或以上 -->
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jumpserver.jpg" class="full-image" alt="jumpserver"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<a id="more"></a>
<p><strong>支持常见系统:</strong></p>
<ol>
<li>CentOS, RedHat, Fedora, Amazon Linux</li>
<li>Debian</li>
<li>SUSE, Ubuntu</li>
<li>FreeBSD</li>
<li>其他ssh协议硬件设备</li>
</ol>
<h3 id="安装JumpServer"><a href="#安装JumpServer" class="headerlink" title="安装JumpServer"></a>安装JumpServer</h3><div class="note primary"><p>安装的环境为CentOS7</p>
</div>
<p> 此次具体安装过程如下：</p>
<h4 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1.安装依赖"></a>1.安装依赖</h4><p><code>yum install -y git</code></p>
<p><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fe8k1n4x18j313i08q0u5.jpg" alt=""></p>
<h4 id="2-下载JumpSerer"><a href="#2-下载JumpSerer" class="headerlink" title="2.下载JumpSerer"></a>2.下载JumpSerer</h4><p>注意安装时当前所在的工作目录，不要在/root目录下安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /opt</div><div class="line">git <span class="built_in">clone</span> https://github.com/jumpserver/jumpserver.git</div></pre></td></tr></table></figure>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fe8kadz13vj313i05w40f.jpg" alt=""></p>
<h4 id="3-开始安装JumpServer"><a href="#3-开始安装JumpServer" class="headerlink" title="3.开始安装JumpServer"></a>3.开始安装JumpServer</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> jumpserver/install/</div><div class="line">./install.py</div></pre></td></tr></table></figure>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fe8kd37km2j313k0eiad1.jpg" alt=""><br><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fe8kew6owij313i07cju1.jpg" alt=""><br>这里如果之前安装过MySQL就无需再安装了。<br>jumpserver自动配置的数据库，用户名是：jumpserver；密码是5Lov@wife<br><img src="https://ww2.sinaimg.cn/large/006tNbRwly1fe8khw9eadj313k06c75y.jpg" alt=""><br>这里是为之后管理员创建普通用户，在创建时直接给用户的邮箱发送账号和密码。<br><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fe8knu8cxhj313i04s0t9.jpg" alt=""><br><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fe8kpsafusj313i05ct93.jpg" alt=""><br>这里为管理员设置密码，接下来就是登陆ip看看我们的jumpserver是否运行正常！<br><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fe8kr4o3b0j313i07owfx.jpg" alt=""></p>
<h3 id="验证JumpServer"><a href="#验证JumpServer" class="headerlink" title="验证JumpServer"></a>验证JumpServer</h3><p>浏览器输入 123.56.100.148:8000<br>就可以查看我们搭建的jumpserver是否成功了！</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fe8kyg57apj31hc0uuq4i.jpg" alt=""></p>
<p><strong>果真搭起来了，让我们输入密码进入吧</strong></p>
<p><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fe8kyzcmyfj31hc0uun31.jpg" alt=""></p>
<p><strong>这里的主机是我搭起来之后添加的。。 :)</strong></p>
<p><em>至此，Centos7搭建JumpServer开源堡垒机的教程就完啦！</em></p>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=79938&auto=0&height=66"></iframe>


<p>本文出自<a href="http://maxiecloud.com" target="_blank" rel="external">Maxie’s Notes</a>博客，转载请务必保留此出处。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
<!--author：maxie（马驰原）-->
<!--QQ：17045930-->
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;完全开源、极致省力、界面美观、功能完整&lt;br&gt;&lt;br&gt;    –JumpServer的特性&lt;br&gt;&lt;/blockquote&gt;

&lt;p&gt;Jumpserver Jumpserver 是一款由python编写开源的跳板机(堡垒机)系统，实现了跳板机应有的功能。基于ssh协议来管理，客户端无需安装agent。&lt;/p&gt;
&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;
&lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;/images/jumpserver.jpg&quot; class=&quot;full-image&quot; alt=&quot;jumpserver&quot; /&gt;&lt;meta itemprop=&quot;width&quot; content=&quot;auto&quot;&gt;&lt;meta itemprop=&quot;height&quot; content=&quot;auto&quot;&gt;&lt;/span&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="堡垒机" scheme="http://yoursite.com/tags/%E5%A0%A1%E5%9E%92%E6%9C%BA/"/>
    
      <category term="开源" scheme="http://yoursite.com/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="jumpserver" scheme="http://yoursite.com/tags/jumpserver/"/>
    
  </entry>
  
  <entry>
    <title>Linux用户和用户组管理</title>
    <link href="http://yoursite.com/2017/03/30/Linux%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2017/03/30/Linux用户和用户组管理/</id>
    <published>2017-03-30T11:02:48.000Z</published>
    <updated>2017-03-31T12:39:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">共产主义是一种伪科学, 演变成一种伪宗教, 最终表现为僵化的集权式的邪恶政治集团!<br><br>Richard Pipes (《共产主义实录》作者)</blockquote>


<blockquote>
<p>Linux系统是一个多用户、多任务的操作系统<br>任何一个要想使用系统内部资源的用户，必须首先向Linux系统管理员申请一个账号，然后以这个用户的身份登录到系统中。这个账号一方面可以帮助系统管理员对使用系统的用户进行管理，并限制他们对系统资源的访问；另一方面也可以为用户提供安全性保护。每个用户账号都拥有一个惟一的用户名和各自的口令。用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。 </p>
</blockquote>
<h4 id="Linux下用户的角色分类"><a href="#Linux下用户的角色分类" class="headerlink" title="Linux下用户的角色分类"></a>Linux下用户的角色分类</h4><p>Linux下用户是根据角色定义的，具体分为三种角色：</p>
<ol>
<li>管理员：默认为<strong>root</strong>用户（<strong>UID=0</strong>），拥有对操作系统最高管理权限（甚至可以kill itself）</li>
<li>普通用户：只能对自己目录下的文件进行访问和修改，具有登陆系统的权限。</li>
<li>系统用户（<strong>伪用户</strong>）：这类用户的特点是不能登录操作系统，他们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</li>
</ol>
<h4 id="用户和组的关系"><a href="#用户和组的关系" class="headerlink" title="用户和组的关系"></a>用户和组的关系</h4><p>用户和用户组的<strong>对应关系</strong>有：一对一、一对多、多对一和多对多。<br>下图展示了这种关系：</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fe53jbpg39j30br066q3o.jpg" alt=""></p>
<a id="more"></a>
<p>  <strong>一对一</strong>：即一个用户可以存在一个组中，也可以是组中的唯一成员。<br>  <strong>一对多</strong>：即一个用户可以存在多个用户组中。那么此用户具有多个组的共同权限。<br>  <strong>多对一</strong>：多个用户可以存在一个组中，这些用户具有和组相同的权限。<br>  <strong>多对多</strong>：多个用户可以存在多个组中。其实就是上面三个对应关系的扩展。</p>
<hr>
<h4 id="用户组的概念"><a href="#用户组的概念" class="headerlink" title="用户组的概念"></a>用户组的概念</h4><p><strong>用户组</strong>是具有相同特征用户的逻辑集合，有时我们需要让很多个用户具有相同的权限，比如查看、修改、删除一个目录下的文件。一种方法是分别对每个用户进行权限的授权，如果用户数特别多的话，这样显然不符合我们省事的宗旨；另一种方法就是建立一个小组，把这些需要拥有权限的用户们加到这个组中，然后让这个组具有对这个目录下的文件，查看、修改、删除的权限，这样组内用户都具有了和组一样的权限。</p>
<p>这就是用户组，将用户分组是Linux系统中对用户进行管理及控制访问权限。</p>
<hr>
<h4 id="安全上下文的概念"><a href="#安全上下文的概念" class="headerlink" title="安全上下文的概念"></a>安全上下文的概念</h4><p>我们都知道<strong>程序=指令+数据</strong></p>
<p>在Linux运行中的程序是以<strong>进程</strong>（process）的方式存在的。</p>
<p>进程是应用的实际载体，是系统资源分配和调度的基本单位。</p>
<p>Linux中每个进程都会由发起者，而这个进程能够做的事情，取决去发起进程的发起者的权限。</p>
<hr>
<h4 id="用户和用户组的主要配置文件"><a href="#用户和用户组的主要配置文件" class="headerlink" title="用户和用户组的主要配置文件"></a>用户和用户组的主要配置文件</h4><table>
<thead>
<tr>
<th>配置文件位置</th>
<th>存储的信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>/etc/passwd</td>
<td>用户及其属性信息</td>
</tr>
<tr>
<td>/etc/group</td>
<td>用户组及其属性信息</td>
</tr>
<tr>
<td>/etc/shadow</td>
<td>用户和其对应的密码及其相关属性</td>
</tr>
<tr>
<td>/etc/gshadow</td>
<td>用户组密码及其相关属性</td>
</tr>
</tbody>
</table>
<h5 id="系统用户配置文件-etc-passwd"><a href="#系统用户配置文件-etc-passwd" class="headerlink" title="系统用户配置文件(/etc/passwd)"></a>系统用户配置文件(/etc/passwd)</h5><p>此文件是Linux用户管理中最重要的一个文件。这个文件记录了Linux系统中每个用户的一些基本属性，并且对所有用户可读。</p>
<p>文件内每一行记录对应一个用户，其格式和具体含义具体如下：</p>
<blockquote>
<p>用户名:密码占位符:UID:GID:注释信息:用户家目录:用户默认shell</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># head /etc/passwd</span></div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">bin:x:1:1:bin:/bin:/sbin/nologin</div><div class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</div><div class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</div><div class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</div></pre></td></tr></table></figure>
<p><strong>passwd文件每个字段的详细含义</strong></p>
<p><strong>用户名</strong>：用户账号的字符串。</p>
<p><strong>密码占位符</strong>：这个位置在之前是存放着用户的密码，但是由于考虑每个用户都能访问，这样对于系统的安全性是不安全的。所以现在许多Linux版本都使用了shadow技术，把真正加密后的用户口令存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如用“x”或者“*”来表示。 </p>
<p><strong>用户标识号</strong>：用户的UID，每个用户都有一个UID，并且是唯一的，通常UID号的取值范围是0～65535，<strong>0是超级用户root的标识号</strong>。而在Linux系统中，普通用户UID默认从<strong>500</strong>开始，<strong>**开始是从</strong>1000**开始。UID是Linux下确认用户权限的标志，用户的角色和权限都是通过UID来实现的，因此多个用户公用一个UID是非常危险的，会造成系统权限和管理的混乱，例如将普通用户的UID设置为0后，这个普通用户就具有了root用户的权限，这是极度危险的操作。因此要尽量保持用户UID的唯一性。</p>
<p><strong>组标识号</strong>：组的GID，与用户的UID类似，这个字段记录了用户所属的用户组。它对应着/etc/group文件中的一条记录。</p>
<p><strong>注释性描述</strong>：字段是对用户的描述信息，比如用户的email，住址。</p>
<p><strong>家目录</strong>：也就是用户登录到系统之后默认所处的目录，也可以叫做用户的主目录、家目录、根目录等等。</p>
<p><strong>默认shell</strong>：就是用户登录系统后默认使用的命令解释器，shell是用户和linux内核之间的接口，用户所作的任何操作，都是通过shell传递给系统内核的。linux下常用的shell有sh、bash、csh、zsh等，管理员可以根据用户的习惯，为每个用户设置不同的shell。</p>
<hr>
<h5 id="用户影子文件-etc-shadow"><a href="#用户影子文件-etc-shadow" class="headerlink" title="用户影子文件(/etc/shadow)"></a>用户影子文件(/etc/shadow)</h5><p>用户影子文件，由于/etc/passwd文件是所有用户都可读的，这样会导致用户的密码容易泄露。因此Linux将密码信息从/etc/passwd中分离出来。单独的放到了一个文件中，这个文件就是/etc/shadow，该文件只有root用户拥有读权限，从而保证了用户密码的安全性。</p>
<p><strong>/etc/shadow文件内容的格式：</strong></p>
<blockquote>
<p>用户名:加密口令:最近一次修改密码的时间:密码最短使用期限:密码最长使用时间:警告时间:密码过期时间:保留字段</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># head /etc/shadow</span></div><div class="line">root:<span class="variable">$6</span><span class="variable">$VmyBrA3R5Q</span>.fFp/:17246:0:99999:7:::</div><div class="line">bin:*:16659:0:99999:7:::</div></pre></td></tr></table></figure>
<hr>
<h5 id="用户组配置文件-etc-group"><a href="#用户组配置文件-etc-group" class="headerlink" title="用户组配置文件(/etc/group)"></a>用户组配置文件(/etc/group)</h5><p>用户组配置文件，用户组的所有信息都存放在此文件中</p>
<p><strong>/etc/group文件内容的格式：</strong></p>
<blockquote>
<p>组名:口令:组标识号:组内用户列表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># head /etc/group</span></div><div class="line">root:x:0:</div><div class="line">bin:x:1:</div></pre></td></tr></table></figure>
<h5 id="创建用户时默认配置文件（-etc-login-defs"><a href="#创建用户时默认配置文件（-etc-login-defs" class="headerlink" title="创建用户时默认配置文件（/etc/login.defs)"></a>创建用户时默认配置文件（/etc/login.defs)</h5><p>下面是Centos的/etc/login.defs文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">CentOS版本信息：</div><div class="line"></div><div class="line">LSB Version:    :core-4.1-amd64:core-4.1-noarch</div><div class="line">Distributor ID: CentOS</div><div class="line">Description:    CentOS Linux release 7.2.1511 (Core)</div><div class="line">Release:        7.2.1511</div><div class="line">Codename:       Core</div><div class="line"></div><div class="line">配置文件：</div><div class="line"></div><div class="line">MAIL_DIR        /var/spool/mail  <span class="comment">#当创建用户时，同时在/var/spool/mail中创建一个用户mail文件</span></div><div class="line">PASS_MAX_DAYS   99999 <span class="comment">#指定密码保持有效最大天数</span></div><div class="line">PASS_MIN_DAYS   0   <span class="comment">#表示自从上次修改密码以来多少天后用户才被允许修改密码 </span></div><div class="line">PASS_MIN_LEN    5   <span class="comment">#指定密码最小长度</span></div><div class="line">PASS_WARN_AGE   7   <span class="comment">#密码到期前多少天系统警告用户密码即将到期</span></div><div class="line"></div><div class="line">UID_MIN                  1000   <span class="comment">#UID最小为1000</span></div><div class="line">UID_MAX                 60000   <span class="comment">#最大UID为60000</span></div><div class="line"></div><div class="line">SYS_UID_MIN               201   <span class="comment">#系统用户UID最小为201</span></div><div class="line">SYS_UID_MAX               999   <span class="comment">#系统用户UID最大为999</span></div><div class="line"></div><div class="line">CREATE_HOME     yes     <span class="comment">#是否创建用户主目录</span></div><div class="line"></div><div class="line">UMASK           077     <span class="comment">#系统的UMASK码</span></div><div class="line"></div><div class="line">USERGROUPS_ENAB yes     <span class="comment">#是否为用户创建与之同名的用户组</span></div><div class="line"></div><div class="line">ENCRYPT_METHOD SHA512   <span class="comment">#系统加密算法</span></div></pre></td></tr></table></figure>
<h5 id="主目录配置文件-etc-skel目录下）"><a href="#主目录配置文件-etc-skel目录下）" class="headerlink" title="主目录配置文件(/etc/skel目录下）"></a>主目录配置文件(/etc/skel目录下）</h5><p>在创建一个新用户后，会在新用户的主目录下看到类似.bash_profile, .bashrc, .bash_logout等文件，这些文件是怎么来的呢，如果我想让新建立的用户在主目录下默认拥有自己指定的配置文件，该如何设置呢？<br>/etc/skel目录就是解决这个问题的，/etc/skel目录定义了新建用户在主目录下默认的配置文件，更改/etc/skel目录下的内容就可以改变新建用户默认主目录的配置文件信息。</p>
<hr>
<h4 id="用户和组管理命令"><a href="#用户和组管理命令" class="headerlink" title="用户和组管理命令"></a>用户和组管理命令</h4><h5 id="用户管理命令："><a href="#用户管理命令：" class="headerlink" title="用户管理命令："></a>用户管理命令：</h5><p><strong>添加新的账号使用useradd命令</strong></p>
<p>其语法如下：</p>
<blockquote>
<p>  useradd [OPTIONS] LOGIN<br>  useradd    选项   用户名</p>
</blockquote>
<p>其中各选项以及含义如下：</p>
<pre><code>-u UID：指定用户的UID
-o：不检查UID的唯一性
-g GID：指定GID，也可以使用组名来指定
-c COMMENT：指定用户的注释信息
-d HOME_DIR：以指定的路径为用户的家目录，默认在/home下创建
-s SHELL：指明用户使用的shell
-G GROUP1[,GROUP2,…]：为用户指明附加组，组需实现存在
-r：创建系统用户
-M：不创建用户的家目录
-m：默认选项，创建用户的家目录
</code></pre><p>实例1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># useradd -d /usr/maxie -s /bin/csh maxie</div></pre></td></tr></table></figure>
<p>此命令创建了一个用户<code>maxie</code>，其中<code>-d</code>选项为用户指定其家目录位置，<code>-s</code>选项指定用户使用的默认shell为csh。</p>
<p>实例2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># useradd -u 1006 -g insieme -G root,maxie cloud</div></pre></td></tr></table></figure>
<p>此命令创建了一个用户<code>cloud</code>，其中<code>-u</code>选项是指定用户的UID，<code>-g</code>选项指定用户的主组为insime，<code>-G</code>选项为用户指明其附加组</p>
<p><strong>修改用户属性使用usermod命令</strong></p>
<p>使用usermod命令可以修改账号的相关属性，比如：用户UID、家目录、用户主组、登录shell登录shell等等。</p>
<p>其语法如下：</p>
<blockquote>
<p>usermod [OPTIONS] LOGIN<br>usermod  选项     用户名</p>
</blockquote>
<p>其中各选项以及含义如下：</p>
<pre><code>-c&lt;备注&gt;：修改用户帐号的备注文字； 
-d&lt;登入目录&gt;：修改用户的家目录； 
-e&lt;有效期限&gt;：修改帐号的有效期限； 
-f&lt;缓冲天数&gt;：修改在密码过期后多少天即关闭该帐号； 
-g&lt;群组&gt;：修改用户所属的群组； 
-G&lt;群组&gt;：修改用户所属的附加群组； 
-l&lt;帐号名称&gt;：修改用户帐号名称； 
-L：锁定用户密码，使密码无效；直接修改/etc/shaodw文件，在密码前加!号即可
-s：修改用户登入后所使用的shell； 
-u：修改用户ID； 
-U：解除密码锁定。
</code></pre><p>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># usermod -s /bin/zsh -l maxiecloud -g cloud maxie</div></pre></td></tr></table></figure>
<p>此命令将用户<code>maxie</code>的登录shell改为zsh，用户名改为maxiecloud，主组改为cloud组。</p>
<p><strong>删除用户使用userdel命令</strong></p>
<p>如果一个账号不再使用，可以从系统中删除，必要时还要删除用户的家目录。</p>
<p>其语法格式如下：</p>
<blockquote>
<p>userdel [OPTIONS] LOGIN<br>userdel 选项      用户名</p>
</blockquote>
<p>常用选项：</p>
<p>-r：删除用户的同时，删除用户的家目录</p>
<p>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># userdel -r maxiecloud</div></pre></td></tr></table></figure>
<p>此命令删除了<code>maxiecloud</code>用户以及其家目录。</p>
<p><strong>修改用户密码使用passwd命令</strong></p>
<p>用户账号刚创建时没有密码，但是被系统锁定，无法使用，必须为其制定密码后才能登陆系统。</p>
<p>其语法格式如下：</p>
<blockquote>
<p>passwd [OPTIONS] LOGIN<br>passwd 选项       用户名</p>
</blockquote>
<p>其中各选项以及含义如下：</p>
<pre><code>--stdin：从标准输入接收用户密码
-l:锁定指定用户
-u:解锁指定用户
-e:强制用户下次登录修改密码
-n mindays: 指定最短使用期限
-x maxdays： 最大使用期限
-w warndays： 提前多少天开始警告
-i inactivedays： 非活动期限
-d：使账户无口令（密码）
</code></pre><p>实例1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># passwd cloud</div><div class="line">New password:******* </div><div class="line">Re-enter new password:*******</div></pre></td></tr></table></figure>
<p>此命令为<code>cloud</code>用户修改密码。</p>
<p>密码设定策略：</p>
<pre><code>1. 使用数字、大写字母、字符、数字、特殊符号组合
2. 足够长（大于8位）
3. 使用随机密码
4. 定期更换（生产环境：平均2个月修改一次）
</code></pre><p>实例2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># passwd -d cloud</div></pre></td></tr></table></figure>
<p>此命令为<code>cloud</code>用户指定空口令，下次cloud用户登录时，系统不再询问口令。</p>
<h5 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h5><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<p><strong>增加一个新的用户组使用groupadd命令</strong></p>
<p>其语法如下：</p>
<blockquote>
<p>groupadd [OPTIONS] GROUP<br>groupadd 选项       用户组</p>
</blockquote>
<p>其中各选项以及含义如下：</p>
<pre><code>-g GID 指定新用户组的组标识号（GID）。
-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。
</code></pre><p>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># groupadd maxie</div></pre></td></tr></table></figure>
<p>此命令向系统添加了一个新组maxie，新组的GID是在当前已有的最大GID号的基础上加1</p>
<p><strong>删除一个已有的用户组使用groupdel命令</strong></p>
<p>其语法如下：</p>
<blockquote>
<p>groupdel [OPTIONS] GROUP<br>groupdel 选项       用户组</p>
</blockquote>
<p>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># groupdel maxie</div></pre></td></tr></table></figure>
<p>此命令从系统中删除组<code>maxie</code></p>
<p><strong>修改用户组的属性使用groupmod命令</strong></p>
<p>其语法如下：</p>
<blockquote>
<p>groupmod [OPTIONS] GROUP<br>groupmod 选项       用户组</p>
</blockquote>
<p>其中各选项以及含义如下：</p>
<pre><code>-g GID 为用户组指定新的组标识号。
-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。
-n新用户组 将用户组的名字改为新名字
</code></pre><p>实例1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># groupmod -g 102 maxie</div></pre></td></tr></table></figure>
<p>此命令将组<code>maxie</code>的GID改为102</p>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=37653063&auto=0&height=66"></iframe>

<p>本文出自<a href="http://maxiecloud.com" target="_blank" rel="external">Maxie’s Notes</a>博客，转载请务必保留此出处。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
<!--author：maxie（马驰原）-->
<!--QQ：17045930-->
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;共产主义是一种伪科学, 演变成一种伪宗教, 最终表现为僵化的集权式的邪恶政治集团!&lt;br&gt;&lt;br&gt;Richard Pipes (《共产主义实录》作者)&lt;/blockquote&gt;


&lt;blockquote&gt;
&lt;p&gt;Linux系统是一个多用户、多任务的操作系统&lt;br&gt;任何一个要想使用系统内部资源的用户，必须首先向Linux系统管理员申请一个账号，然后以这个用户的身份登录到系统中。这个账号一方面可以帮助系统管理员对使用系统的用户进行管理，并限制他们对系统资源的访问；另一方面也可以为用户提供安全性保护。每个用户账号都拥有一个惟一的用户名和各自的口令。用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;Linux下用户的角色分类&quot;&gt;&lt;a href=&quot;#Linux下用户的角色分类&quot; class=&quot;headerlink&quot; title=&quot;Linux下用户的角色分类&quot;&gt;&lt;/a&gt;Linux下用户的角色分类&lt;/h4&gt;&lt;p&gt;Linux下用户是根据角色定义的，具体分为三种角色：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;管理员：默认为&lt;strong&gt;root&lt;/strong&gt;用户（&lt;strong&gt;UID=0&lt;/strong&gt;），拥有对操作系统最高管理权限（甚至可以kill itself）&lt;/li&gt;
&lt;li&gt;普通用户：只能对自己目录下的文件进行访问和修改，具有登陆系统的权限。&lt;/li&gt;
&lt;li&gt;系统用户（&lt;strong&gt;伪用户&lt;/strong&gt;）：这类用户的特点是不能登录操作系统，他们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;用户和组的关系&quot;&gt;&lt;a href=&quot;#用户和组的关系&quot; class=&quot;headerlink&quot; title=&quot;用户和组的关系&quot;&gt;&lt;/a&gt;用户和组的关系&lt;/h4&gt;&lt;p&gt;用户和用户组的&lt;strong&gt;对应关系&lt;/strong&gt;有：一对一、一对多、多对一和多对多。&lt;br&gt;下图展示了这种关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/006tNbRwly1fe53jbpg39j30br066q3o.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux基础知识" scheme="http://yoursite.com/categories/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="user" scheme="http://yoursite.com/tags/user/"/>
    
      <category term="command" scheme="http://yoursite.com/tags/command/"/>
    
  </entry>
  
  <entry>
    <title>shadowsock VPS CentOS 完整安装教程</title>
    <link href="http://yoursite.com/2017/03/28/shadowsock-vps%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/03/28/shadowsock-vps安装教程/</id>
    <published>2017-03-28T14:07:11.000Z</published>
    <updated>2017-03-29T00:24:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>首先需要在购买的VPS上安装<code>Python</code>、<code>pip</code>和<code>shadowsocks</code></strong></p>
<blockquote>
<p>  yum install python-setuptools &amp;&amp; easy_install pip</p>
<p>  pip install shadowsocks</p>
</blockquote>
<a id="more"></a>
<p><strong>对shadowsocks进行配置</strong></p>
<blockquote>
<p>  vi /etc/shadowsocks.json</p>
</blockquote>
<p>shadowsocks.json文件内容如下：</p>
<blockquote>
<pre><code>{ &quot;server&quot;:&quot;你的 IP地址&quot;, 

&quot;server_port&quot;:&quot;自定义端口&quot;, 

&quot;local_address&quot;:&quot;127.0.0.1&quot;, 

&quot;local_port&quot;:1080, 

&quot;password&quot;:&quot;MyPass&quot;, 

&quot;timeout&quot;:600,

 &quot;method&quot;:&quot;rc4-md5&quot; }
</code></pre></blockquote>
<p>复制完成后，按 Esc 键退出编辑模式，此时putty黑框左下角的 – INSERT – 字样消失，按下 : 键，输入 wq 后回车，此时文件保存完毕并退出了vi编辑器。（“ : ”的输入方法为“Shift+字母L右侧的分号键”）</p>
<p><strong>各参数意义：</strong></p>
<p>server:服务器（VPS）IP地址</p>
<p>server_port：服务器端口</p>
<p>local_port:本地端端口</p>
<p>password:用来加密的密码</p>
<p>timeout:超时时间（秒）</p>
<p>method:加密方法，可选择 “bf-cfb”, “aes-256-cfb”, “des-cfb”, “rc4″</p>
<p><strong>继续配置shadowsocks服务</strong></p>
<blockquote>
<p>   vi /etc/supervisord.conf</p>
</blockquote>
<p>将以下内容复制到此文件的尾部。在vi中光标快速到文件尾部，使用大写<code>G键</code>即可；使用<code>o键</code>即可在文件尾部下的一行开始输入文本。</p>
<blockquote>
<p>[program:shadowsocks]<br>command=ssserver -c /etc/shadowsocks.json<br>autostart=true<br>autorestart=true<br>user=root<br>log_stderr=true<br>logfile=/var/log/shadowsocks.log</p>
</blockquote>
<p>复制完成后，按下回车键给文件尾部留出空行，然后按 Esc 键退出编辑模式，此时putty黑框左下角的 – INSERT – 字样消失，按下 : 键，输入 wq 后回车，此时文件保存完毕并退出了vi编辑器。</p>
<p><strong>编辑Linux下开机启动任务文件</strong></p>
<blockquote>
<p>   vi /etc/rc.local</p>
</blockquote>
<p>将以下内容，复制到此文件的空行处即可。</p>
<blockquote>
<p>service supervisord start</p>
</blockquote>
<p>复制完成后，按下回车键给文件尾部留出空行，然后按 Esc 键退出编辑模式，此时putty黑框左下角的 – INSERT – 字样消失，按下 : 键，输入 wq 后回车，此时文件保存完毕并退出了vi编辑器。</p>
<p><strong>如果你vps的操作系统是CentOS7，则需要关闭防火墙firewall</strong></p>
<p><strong>防火墙开启需要设置的端口</strong></p>
<blockquote>
<p>firewall-cmd –zone=public –add-port=443/tcp –permanent</p>
</blockquote>
<p><strong>各参数含义：</strong></p>
<p>–zone：作用域</p>
<p>–add-port=8388/tcp：添加端口，格式为：端口/通讯协议</p>
<p>–permanent：永久生效，没有此参数重启后失效</p>
<p><strong>设置完防火墙后，需要重启防火墙</strong></p>
<blockquote>
<p>firewall-cmd –reload</p>
</blockquote>
<p><strong>最后执行命令</strong></p>
<blockquote>
<p>   reboot</p>
</blockquote>
<p>此时，你的VPS重新启动，服务端已经完全配置完毕，使用shadowsocks客户端即可实现科学上网。</p>
<p><strong>如果不想重启vps，则执行以下命令，即可立即使ss生效</strong></p>
<blockquote>
<p>ssserver -c /etc/shadowsocks.json -d start</p>
</blockquote>
<hr>
<p><strong>shadowsocks客户端配置</strong></p>
<p>至此，shadowsocks的服务端已经部署完成。剩下的就是下载客户端安装到你的手机和电脑上，记得修改客户端的相关设置保持和你的服务端参数一致。</p>
<blockquote>
<p><a href="https://play.google.com/store/apps/details?id=com.github.shadowsocks" target="_blank" rel="external">Android客户端下载链接</a></p>
<p><a href="https://github.com/shadowsocks/shadowsocks-windows" target="_blank" rel="external">Windows客户端下载链接</a></p>
<p><a href="https://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-%E5%B8%AE%E5%8A%A9" target="_blank" rel="external">MacOS客户端下载链接</a></p>
<p><a href="https://itunes.apple.com/us/app/shadowrocket-for-shadowsocks/id932747118" target="_blank" rel="external">IOS客户端下载链接</a></p>
</blockquote>
<p><strong>至此，关于在VPS上搭建shadowsocks的教程已经全部讲解完毕。如果有什么问题，可以在留言区留言。</strong></p>
<hr>
<p>本文出自<a href="http://maxiecloud.com" target="_blank" rel="external">Maxie’s Notes</a>博客，转载请务必保留此出处。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fdzc80odsuj30gn0ilq5m.jpg" alt=""></p>
<!--author：maxie（马驰原）-->
<!--QQ：17045930-->
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;首先需要在购买的VPS上安装&lt;code&gt;Python&lt;/code&gt;、&lt;code&gt;pip&lt;/code&gt;和&lt;code&gt;shadowsocks&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  yum install python-setuptools &amp;amp;&amp;amp; easy_install pip&lt;/p&gt;
&lt;p&gt;  pip install shadowsocks&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="shadowsocks" scheme="http://yoursite.com/categories/shadowsocks/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="vps" scheme="http://yoursite.com/tags/vps/"/>
    
      <category term="shadowsocks" scheme="http://yoursite.com/tags/shadowsocks/"/>
    
  </entry>
  
</feed>
